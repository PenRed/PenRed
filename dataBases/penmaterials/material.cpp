//#include "errors.h"
#include <cstring>
#include <stdio.h>
#include <math.h>
#include "errors.cpp"

//
//
//    Copyright (C) 2019-2021 Universitat de València - UV
//    Copyright (C) 2019-2021 Universitat Politècnica de València - UPV
//
//    This file is part of PenRed: Parallel Engine for Radiation Energy Deposition.
//
//    PenRed is free software: you can redistribute it and/or modify
//    it under the terms of the GNU Affero General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    PenRed is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU Affero General Public License for more details.
//
//    You should have received a copy of the GNU Affero General Public License
//    along with PenRed.  If not, see <https://www.gnu.org/licenses/>. 
//
//    contact emails:
//
//        vicent.gimenez.alventosa@gmail.com (Vicent Giménez Alventosa)
//        vicente.gimenez@uv.es (Vicente Giménez Gómez)
//    
//

//This code is a literal translation to C++ of the original PENELOPE routines
//written in FORTRAN used to construct the materials using the PENELOPE database.
//Notice that our translation uses the very same database that the original code,
//specifically the 2018 version. Following, we append the copyright disclaimer of
//the original FORTRAN source:

/*
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C      M    M    AA   TTTTTT  EEEEEE  RRRRR   IIII    AA    L          C
C      MM  MM   A  A    TT    E       R    R   II    A  A   L          C
C      M MM M  A    A   TT    E       R    R   II   A    A  L          C
C      M    M  AAAAAA   TT    EEEE    RRRRR    II   AAAAAA  L          C
C      M    M  A    A   TT    E       R   R    II   A    A  L          C
C      M    M  A    A   TT    EEEEEE  R    R  IIII  A    A  LLLLLL     C
C                                                                      C
C                                                   (version 2018).    C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C  PENELOPE/PENGEOM (version 2018)                                     C
C  Copyright (c) 2001-2018                                             C
C  Universitat de Barcelona                                            C
C                                                                      C
C  Permission to use, copy, modify, distribute and sell this software  C
C  and its documentation for any purpose is hereby granted without     C
C  fee, provided that the above copyright notice appears in all        C
C  copies and that both that copyright notice and this permission      C
C  notice appear in all supporting documentation. The Universitat de   C
C  Barcelona makes no representations about the suitability of this    C
C  software for any purpose. It is provided "as is" without express    C
C  or implied warranty.                                                C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  This program generates material definition files for PENELOPE, which
C  contain tables of physical properties, interaction cross sections and
C  other particle transport characteristics. These data are extracted
C  from the database, which consists of the following 995 ASCII files
C  contained in the directory './pendbase/pdfiles':
C
C* PDATCONF.P14: atomic ground-state configurations, ionisation energies
C     and central values of the one-electron shell Compton profiles for
C     the elements, from hydrogen to einsteinium (Z=1-99).
C
C* PDCOMPOS.PEN: prepared composition data for 280 different materials
C     of radiological interest (adapted from Berger, NISTIR 4999, 1992).
C
C* MATERIAL-LIST.TXT: list of materials included in the PDCOMPOS.P08
c     file, with their identification numbers.
C
C* PDRELAX.P11: data on atomic relaxation, extracted from the LLNL
C     Evaluated Atomic Data Library.
C
C* 99 files named PDEELZZ.P08 with ZZ=atomic number (01-99). These
C     files contain tables of total cross sections and first and second
C     transport cross sections for elastic scattering of electrons and
C     positrons by neutral free atoms, generated by the program ELSEPA.
C     The same grid of energies, that covers the interval from 50 eV
C     up to 1 GeV, is used for all elements.
C
C* 99 files named EELDXZZZ.P08 with ZZZ=atomic number (001-099). These
C     files contain tables of differential cross sections for elastic
C     scattering of electrons by free neutral atoms. They where
C     generated by using the program ELSEPA and cover the energy
C     interval from 50 eV to 100 MeV.
C
C* 99 files named PELDXZZZ.P08 with ZZZ=atomic number (001-099). These
C     files contain tables of differential cross sections for elastic
C     scattering of positrons by free neutral atoms. They where
C     generated by using the program ELSEPA and cover the energy
C     interval from 50 eV to 100 MeV.
C
C* 99 files named PDEBRZZ.P08 that contain electron bremsstrahlung data.
C     These files were produced from the database of Seltzer and Berger.
C     The same grid of energies for all elements.
C
C* PDBRANG.P08: parameters of the intrinsic angular distribution of
C     bremsstrahlung photons. Determined by fitting the set of benchmark
C     partial-wave shape functions of Kissel, Quarles and Pratt.
C
C* 99 files named PDAFFZZ.P08, ZZ=atomic number (01-99), with tables of
C     atomic form factors and incoherent scattering functions of neutral
C     free atoms, extracted from the EPDL97 data library of Cullen et al.
C
C* 99 files named PDGRAZZ.P08 with ZZ=atomic number (01-99). These
C     files contain tables of anomalous scattering factors and total
C     cross sections for Rayleigh scattering of photons by neutral free
C     atoms, extracted from the EPDL97 data library of Cullen et al.
C
C* 99 files named PDGPPZZ.P11 with cross sections for pair and triplet
C     production in the field of neutral atoms, obtained from the XCOM
C     program of Berger and Hubbell. The same energy grid for all
C     elements.
C
C* 99 files named PDGPHZZ.P12, containing total atomic photoelectric
C     cross sections and partial cross sections for inner (K, L, M, and
C     N) shells, generated from the EPDL97 data library of Cullen et al.
C
C* 99 files named PDESIZZ.P14 with cross sections for ionisation of
C     inner (K, L, M, and N) shells by electron impact, generated from
C     the distorted-wave and plane-wave Born approximations.
C
C* 99 files named PDPSIZZ.P14 with cross sections for ionisation of
C     inner (K, L, M, and N) shells by positron impact, generated from
C     the distorted-wave and plane-wave Born approximations.
C
C  A material is completely characterised by its chemical composition,
C  i.e., elements present and number of atoms of each element in a
C  molecule (=stoichiometric index), mass density and mean excitation
C  energy. Alloys and mixtures are treated as compounds, with stoichio-
C  metric indexes equal or proportional to the percent number of atoms
C  of each element. Information about the material is supplied by the
C  user from the keyboard, following the prompts from 'material', or
C  read from the PDCOMPOS.PEN file, which contains information for 280
C  different materials. In the case of compounds, 'molecular' cross
C  sections are obtained by means of the additivity rule, i.e. as the
C  sum of the atomic cross sections.
C
C  To obtain the executable file 'material.exe', compile and link the
C  source files 'material.f', 'penelope.f', and 'rita.f'. The file
C  'material.exe' must be placed in the directory 'pendbase', which
C  contains the subdirectory 'pdfiles' with the database files.
C
C  NOTE: In the output file and in the simulation program, lengths are
C  given in cm and energies in eV. Consequently, total cross sections
C  are in cm**2, stopping powers in eV/cm, etc. However, macroscopic
C  cross sections listed in the input/output files are expressed in
C  mass-thickness units (mtu); 1 mtu = 1 g/cm**2.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER*4 (I-N)
      CHARACTER MFNAME*20
      MFNAME='null'
      CALL PEMATW(0,MFNAME)
      END
*/
#define MAXMAT  20
#define NEGP  200
#define NO 512			//****  E/P inelastic collisions.
#define NRP 8000		//  ****  Inner-shell ionisation by electron and positron impact.
#define NOCO 512		//  ****  Compton scattering.
#define NDIM 12000		//  ****  Photon simulation tables.
#define NBW 32			//  ****  Bremsstrahlung emission.
#define NEGP1 12000		//  ****  'Standard' energy grid.
#define REV 5.10998928E5	// Electron rest energy (eV)
#define AVOG 6.02214129E23	// Avogadro's number
#define SL 137.035999074	// Speed of light (1/alpha)
#define PI 3.1415926535897932	// Valor de PI
#define A0B 5.2917721092E-9	// Bohr radius (cm)
#define HREV 27.21138505	// Hartree energy (eV)

#define MINEGRID 50.0
#define MINDIMGRID 10.0

#define NQ 250
#define NEX 1024
#define NTP 12000

#define NP 150
#define NP2 300			//(NP2 = NP+NP)
#define NPMINUS1 149		//(NPM1 = NP-1)

#define NEM 10000
#define NOM 1000
#define ELRAD 2.8179403267E-13	// Class. electron radius (cm)
#define NA 606

typedef double (*FCT_SUMGA) (double);

namespace PENERROR_mod
{
  extern char REASON[128];	// Warning/error message.
  extern int IRETRN;		// Return code.
};

namespace PENELOPE_mod
{
  //  ****  Simulation parameters (must be defined before calling the
  //        initialisation subroutine PEINIT).

  //  ----  Absorption energies, EABS(KPAR,MAT).
  double EABS[3][MAXMAT] =
    { {50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0,
       50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0},
  {50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0,
   50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0},
  {50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0,
   50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0}
  };


  //  ----  Electron/positron transport parameters.
  double C1[MAXMAT] =
    { 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
    0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01
  };
  double C2[MAXMAT] =
    { 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
    0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01
  };
  double WCC[MAXMAT] =
    { 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2,
    1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2
  };
  double WCR[MAXMAT] =
    { 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2,
    1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2, 1.0E2
  };

  //  ****  Global information on the material system (defined by
  //        subroutine PEINIT).
  //  ----  Number of materials present.
  int NMAT;
  //  ----  Material densities and its reciprocals.
  double DEN[MAXMAT] = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
  };
  double RDEN[MAXMAT] = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
  };

};

namespace CDCSEP
{
#define NE 96
  double ETS[NE], ETL[NE], TH[NA], THR[NA], XMU[NA], XMUL[NA], ECS[NE],
    ETCS1[NE], ETCS2[NE], EDCS[NE][NA], PCS[NE], PTCS1[NE], PTCS2[NE],
    PDCS[NE][NA], DCSI[NA], DCSIL[NA], CSI, TCS1I, TCS2I;
#undef NE
};
namespace CGCO00
{
  // GCOaT, GCOaD (canvi de E --> EE, M --> MM, IO --> IOSC)
  double EE;
  int MM, IOSC;
};
namespace CEBR01
{
  const int NBE = 57;
  double EBT[NBE], XS[NBE][NBW], TXS[NBE], X[NBE], Y[NBE];
};
namespace CEBR02
{
  double P0[MAXMAT][NEGP][NBW];
};
namespace CEGRID
{
  // ****  Energy grid and interpolation constants for the current energy.
  double EMIN, EL, EU, ET[NEGP], DLEMP[NEGP], DLEMP1, DLFC, XEL, XE, XEK;
  int KE;
};
namespace COMPOS
{
  //  ****  Composition data.
  double STF[MAXMAT][30], ZT[MAXMAT], AT[MAXMAT], RHO[MAXMAT], VMOL[MAXMAT];
  int IZ[MAXMAT][30], NELEM[MAXMAT];

};
namespace CADATA
{
  //  ****  Element data.
  double EB[99][30], ALW[99][30], CP0[99][30];
  int IFI[99][30], IKS[99][30], NSHT[99];

//  *********************************************************************
//                       BLOCK DATA PENDAT
//  *********************************************************************
//      BLOCK DATA PENDAT

//  Physical data for the elements Z=1-99.

//  ************  Chemical symbols of the elements.
// COMPTE ! LASYMB[2] definida en moltes subrutines està mal. Ve del fortran char*2 LASYMB. ELIMINAR !

  char LASYMB[99][3] =
    { "H ", "He", "Li", "Be", "B ", "C ", "N ", "O ", "F ", "Ne", "Na", "Mg",
"Al", "Si", "P ", "S ", "Cl", "Ar", "K ", "Ca", "Sc", "Ti", "V ", "Cr", "Mn", "Fe", "Co",
"Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr", "Rb", "Sr", "Y ", "Zr", "Nb", "Mo",
"Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I ", "Xe", "Cs", "Ba", "La",
"Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu", "Hf",
"Ta", "W ", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn", "Fr",
"Ra", "Ac", "Th", "Pa", "U ", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es" };

  //  ************  Atomic weights (mean relative atomic masses).

  double ATW[99] =
    { 1.0079, 4.0026, 6.9410, 9.0122, 1.0811E1, 1.2011E1, 1.4007E1, 1.5999E1,
1.8998E1, 2.0179E1, 2.2990E1, 2.4305E1, 2.6982E1, 2.8086E1, 3.0974E1, 3.2066E1,
3.5453E1, 3.9948E1, 3.9098E1, 4.0078E1, 4.4956E1, 4.7880E1, 5.0942E1, 5.1996E1,
5.4938E1, 5.5847E1, 5.8933E1, 5.8690E1, 6.3546E1, 6.5390E1, 6.9723E1, 7.2610E1,
7.4922E1, 7.8960E1, 7.9904E1, 8.3800E1, 8.5468E1, 8.7620E1, 8.8906E1, 9.1224E1,
9.2906E1, 9.5940E1, 9.7907E1, 1.0107E2, 1.0291E2, 1.0642E2, 1.0787E2, 1.1241E2,
1.1482E2, 1.1871E2, 1.2175E2, 1.2760E2, 1.2690E2, 1.3129E2, 1.3291E2, 1.3733E2,
1.3891E2, 1.4012E2, 1.4091E2, 1.4424E2, 1.4491E2, 1.5036E2, 1.5196E2, 1.5725E2,
1.5893E2, 1.6250E2, 1.6493E2, 1.6726E2, 1.6893E2, 1.7304E2, 1.7497E2, 1.7849E2,
1.8095E2, 1.8385E2, 1.8621E2, 1.9020E2, 1.9222E2, 1.9508E2, 1.9697E2, 2.0059E2,
2.0438E2, 2.0720E2, 2.0898E2, 2.0898E2, 2.0999E2, 2.2202E2, 2.2302E2, 2.2603E2,
2.2703E2, 2.3204E2, 2.3104E2, 2.3803E2, 2.3705E2, 2.3905E2, 2.4306E2, 2.4707E2,
2.4707E2, 2.5108E2, 2.5208E2 };

  //  ************  Mean excitation energies of the elements (eV).

  double EPX[99] =
    { 19.2, 41.8, 40.0, 63.7, 76.0, 81.0, 82.0, 95.0, 115.0, 137.0, 149.0,
156.0, 166.0, 173.0, 173.0, 180.0, 174.0, 188.0, 190.0, 191.0, 216.0, 233.0, 245.0,
257.0, 272.0, 286.0, 297.0, 311.0, 322.0, 330.0, 334.0, 350.0, 347.0, 348.0, 343.0,
352.0, 363.0, 366.0, 379.0, 393.0, 417.0, 424.0, 428.0, 441.0, 449.0, 470.0, 470.0,
469.0, 488.0, 488.0, 487.0, 485.0, 491.0, 482.0, 488.0, 491.0, 501.0, 523.0, 535.0,
546.0, 560.0, 574.0, 580.0, 591.0, 614.0, 628.0, 650.0, 658.0, 674.0, 684.0, 694.0,
705.0, 718.0, 727.0, 736.0, 746.0, 757.0, 790.0, 790.0, 800.0, 810.0, 823.0, 823.0,
830.0, 825.0, 794.0, 827.0, 826.0, 841.0, 847.0, 878.0, 890.0, 902.0, 921.0, 934.0,
939.0, 952.0, 966.0, 980.0 };

  //  ************  Pair-production cross section parameters.

  //  ****  Screening parameter (R mc/hbar).
  double RSCR[99] =
    { 1.2281E2, 7.3167E1, 6.9228E1, 6.7301E1, 6.4696E1, 6.1228E1, 5.7524E1,
5.4033E1, 5.0787E1, 4.7851E1, 4.6373E1, 4.5401E1, 4.4503E1, 4.3815E1, 4.3074E1,
4.2321E1, 4.1586E1, 4.0953E1, 4.0524E1, 4.0256E1, 3.9756E1, 3.9144E1, 3.8462E1,
3.7778E1, 3.7174E1, 3.6663E1, 3.5986E1, 3.5317E1, 3.4688E1, 3.4197E1, 3.3786E1,
3.3422E1, 3.3068E1, 3.2740E1, 3.2438E1, 3.2143E1, 3.1884E1, 3.1622E1, 3.1438E1,
3.1142E1, 3.0950E1, 3.0758E1, 3.0561E1, 3.0285E1, 3.0097E1, 2.9832E1, 2.9581E1,
2.9411E1, 2.9247E1, 2.9085E1, 2.8930E1, 2.8721E1, 2.8580E1, 2.8442E1, 2.8312E1,
2.8139E1, 2.7973E1, 2.7819E1, 2.7675E1, 2.7496E1, 2.7285E1, 2.7093E1, 2.6911E1,
2.6705E1, 2.6516E1, 2.6304E1, 2.6108E1, 2.5929E1, 2.5730E1, 2.5577E1, 2.5403E1,
2.5245E1, 2.5100E1, 2.4941E1, 2.4790E1, 2.4655E1, 2.4506E1, 2.4391E1, 2.4262E1,
2.4145E1, 2.4039E1, 2.3922E1, 2.3813E1, 2.3712E1, 2.3621E1, 2.3523E1, 2.3430E1,
2.3331E1, 2.3238E1, 2.3139E1, 2.3048E1, 2.2967E1, 2.2833E1, 2.2694E1, 2.2624E1,
2.2545E1, 2.2446E1, 2.2358E1, 2.2264E1 };
  //  ****  Asymptotic triplet contribution (eta).
  double ETA[99] =
    { 1.1570, 1.1690, 1.2190, 1.2010, 1.1890, 1.1740, 1.1760, 1.1690, 1.1630,
1.1570, 1.1740, 1.1830, 1.1860, 1.1840, 1.1800, 1.1780, 1.1750, 1.1700, 1.1800, 1.1870,
1.1840, 1.1800, 1.1770, 1.1660, 1.1690, 1.1660, 1.1640, 1.1620, 1.1540, 1.1560, 1.1570,
1.1580, 1.1570, 1.1580, 1.1580, 1.1580, 1.1660, 1.1730, 1.1740, 1.1750, 1.1700, 1.1690,
1.1720, 1.1690, 1.1680, 1.1640, 1.1670, 1.1700, 1.1720, 1.1740, 1.1750, 1.1780, 1.1790,
1.1800, 1.1870, 1.1940, 1.1970, 1.1960, 1.1940, 1.1940, 1.1940, 1.1940, 1.1940, 1.1960,
1.1970, 1.1960, 1.1970, 1.1970, 1.1980, 1.1980, 1.2000, 1.2010, 1.2020, 1.2040, 1.2050,
1.2060, 1.2080, 1.2070, 1.2080, 1.2120, 1.2150, 1.2180, 1.2210, 1.2240, 1.2270, 1.2300,
1.2370, 1.2430, 1.2470, 1.2500, 1.2510, 1.2520, 1.2550, 1.2560, 1.2570, 1.2590, 1.2620,
1.2620, 1.2650 };

};

namespace CEIN
{
  //  ****  E/P inelastic collisions.
  double EXPOT[MAXMAT], OP2[MAXMAT], F[MAXMAT][NO], UI[MAXMAT][NO],
    WRI[MAXMAT][NO];
  int KZ[MAXMAT][NO], KS[MAXMAT][NO], NOSC[MAXMAT];
};

namespace CEIN00
{
  //  ****  Partial cross sections of individual shells/oscillators.
  // Associat a les routines PEMATR i EINaT solament.
  double SEH0[NO], SEH1[NO], SEH2[NO], SES0[NO], SES1[NO], SES2[NO], SET0[NO],
    SET1[NO], SET2[NO];
};

namespace CPIN00
{
  //  ****  Partial cross sections of individual shells/oscillators.
  // Associat a les routines PEMATR i PINaT solament. COMPTE !! Les variables del COMMON tene noms differents en les dues.
  double SPH0[NO], SPH1[NO], SPH2[NO], SPS0[NO], SPS1[NO], SPS2[NO], SPT0[NO],
    SPT1[NO], SPT2[NO];
};

namespace CGCO
{
  //  ****  Compton scattering.
  double FCO[MAXMAT][NOCO], UICO[MAXMAT][NOCO], FJ0[MAXMAT][NOCO],
    PTRSH[MAXMAT][NOCO];
  int KZCO[MAXMAT][NOCO], KSCO[MAXMAT][NOCO], NOSCCO[MAXMAT];
};

namespace CEBR
{
  //  ****  Bremsstrahlung emission.
  double WB[NBW], PBCUT[MAXMAT][NEGP], WBCUT[MAXMAT][NEGP],
    PDFB[MAXMAT][NEGP][NBW], DPDFB[MAXMAT][NEGP][NBW],
    PACB[MAXMAT][NEGP][NBW], ZBR2[MAXMAT];
};
namespace CEEL00
{
  //  ****  Elastic scattering of electrons and positrons.
  double EJT[NEGP], XE0[NEGP], XE1[NEGP], XE2[NEGP], XP0[NEGP], XP1[NEGP],
    XP2[NEGP], T1E0[NEGP], T2E0[NEGP], T1P0[NEGP], T2P0[NEGP], EJTL[NEGP],
    FJL[NEGP], A[NEGP], B[NEGP], C[NEGP], D[NEGP];
};
namespace CEIN01
{
  double EI, EE, CPS, AMOL, MOM;
};
namespace CPIN01
{
  double EI, CPS, BHA1, BHA2, BHA3, BHA4;
  int MOM;
};
namespace CSUMGA
{
  int IERGA, NCALL;		// Error code, no. of function calls.
};
namespace CSGAWR
{
  int ISGAW;			//Controls warning messages from SUMGA.
};

void PEMATW (int, char *);
void EGRID (double EMINu, double EMAXu);
void EELaW (int &, FILE *);
void ESIaW (int &, FILE *);
void PSIaW (int &, FILE *);
void EBRaW (int &, FILE *);
void BRaAW (double &, FILE *);
void GRAaW (int &, FILE *);
void GPHaW (int &, FILE *);
void GPPaW (double *, double *, double *, int &, int &);
void RELAXW (int &, FILE *);
void EELdW (int &, FILE *);
double RLMOM (double *X, double *FCT, double XC, int NPpar, int MOM);
void SPLINE (double *X, double *Y, double *A, double *B,
	     double *C, double *D, double S1, double SN, int N);
void FINDI (double *X, double XC, int N, int &I);
void ELINIT (int *IZ, double *STF, int &NELEM);
double RMOMX (double *X, double *PDF, double XD, double XU, int NPpar, int MOM);
void EINaT (double &E, double &WCCM, double &XH0, double &XH1, double &XH2,
	    double &XS0, double &XS1, double &XS2, double &XT1, double &XT2,
	    double &DELTA, int M);
void EBRaT (double &E, double &WCRM, double &XH0, double &XH1, double &XH2,
	    double &XS1, double &XS2, int M);
void PINaT (double &E, double &WCCM, double &XH0, double &XH1, double &XH2,
	    double &XS0, double &XS1, double &XS2, double &XT1, double &XT2,
	    double &DELTA, int M);
void PBRaT (double &E, double &WCRM, double &XH0, double &XH1, double &XH2,
	    double &XS1, double &XS2, int M);

void MERGE2 (double *X1, double *Y1, double *X2, double *Y2, double *XM,
	     double *YM, int &N1, int &N2, int &N);
void GCOaT (double &E, double &CS, int &M);
void EINaT1 (double &E, double &UK, double &WK, double DELTA, double &WCCM,
	     double &H0, double &H1, double &H2, double &S0, double &S1,
	     double &S2, double &R0, double &R1, double &R2);
void PINaT1 (double &E, double &UK, double &WK, double DELTA, double &WCCM,
	     double &H0, double &H1, double &H2, double &S0, double &S1,
	     double &S2, double &R0, double &R1, double &R2);
void SORT2 (double *X, double *Y, int &N);
double SUMGA (FCT_SUMGA FCT, double XL, double XU, double TOL);
double PINaDS (double RMU);
double EINaDS (double RMU);
double GCOaD (double CDT);

int main ()
{
  using namespace PENERROR_mod;

  //******************************************************
  //Fix the minimum number of exponent digits in MVS to 2 
#ifdef _MSC_VER
  unsigned int prev_exponent_format =
      _set_output_format(_TWO_DIGIT_EXPONENT);
#endif
  //******************************************************  
  
  char MFNAME[20];
  strcpy (MFNAME, "null");
  PEMATW (0, MFNAME);
  if (IRETRN != 0)
    {
      printf ("%s\n", REASON);
      printf ("IRETRN =%d\n", IRETRN);
    }
}

//  *********************************************************************
//                       SUBROUTINE EELaW
//  *********************************************************************
void EELaW (int &M, FILE * IWR)
{
  //  This subroutine generates a table of integrated cross sections for
  //  elastic scattering of electrons and positrons in material M, and
  //  writes it on the material definition file. Data are read from the
  //  files 'pdeelZZ.p08'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;
  using namespace CEEL00;

  char FILEN[12];
  char LDIG[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LDIG1[2], LDIG2[2];

  //  ****  Building the cross section table.

  for (int I = 0; I < NEGP; I++)
    {
      XE0[I] = 0.0;
      XE1[I] = 0.0;
      XE2[I] = 0.0;
      XP0[I] = 0.0;
      XP1[I] = 0.0;
      XP2[I] = 0.0;
    }

  int IZZ, IZZZ, NLD, NLD1, NLD2, NPTAB = 0;
  double WGHT;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      char straux[30];
      strcpy (straux, "./pdfiles/");
      IZZ = IZ[M][IEL];
      WGHT = STF[M][IEL];
      NLD = IZZ;
      NLD1 = NLD - 10 * (NLD / 10);
      NLD2 = (NLD - NLD1) / 10;
      LDIG1[0] = LDIG[NLD1 + 1 - 1];
      LDIG1[1] = '\0';
      LDIG2[0] = LDIG[NLD2 + 1 - 1];
      LDIG2[1] = '\0';
      strcpy (FILEN, "pdeel");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p08");
      strcat (straux, FILEN);
      FILE *pdeel_file = fopen (straux, "r");
      fscanf (pdeel_file, "%d%*[^\n]", &IZZZ);
      getc (pdeel_file);

      if (IZZZ != IZZ)
	{
	  ErrorFunction (1303);
	  return;
	}
      for (int I = 0; I < NEGP; I++)
	{
	  double XE0P, XE1P, XE2P, XP0P, XP1P, XP2P;
	  fscanf (pdeel_file, "%lf %lf %lf %lf %lf %lf %lf%*[^\n]", &EJT[I],
		  &XE0P, &XE1P, &XE2P, &XP0P, &XP1P, &XP2P);
	  getc (pdeel_file);
	  if (feof (pdeel_file))
	    {
	      break;
	    }

	  XE0[I] = XE0[I] + WGHT * XE0P;
	  XE1[I] = XE1[I] + WGHT * XE1P;
	  XE2[I] = XE2[I] + WGHT * XE2P;
	  XP0[I] = XP0[I] + WGHT * XP0P;
	  XP1[I] = XP1[I] + WGHT * XP1P;
	  XP2[I] = XP2[I] + WGHT * XP2P;
	  NPTAB = I + 1;
	}
      fclose (pdeel_file);
    }

  //  ****  Write final x-section table.

  fprintf (IWR,
	   " *** Electron and positron elastic cross sections,  NDATA =%4d\n",
	   NPTAB);
  for (int I = 0; I < NPTAB; I++)
    {
      fprintf (IWR, "%10.3E %11.5E %11.5E %11.5E %11.5E %11.5E %11.5E\n",
	       EJT[I], XE0[I], XE1[I], XE2[I], XP0[I], XP1[I], XP2[I]);
    }
}

//  *********************************************************************
//                       SUBROUTINE ESIaW
//  *********************************************************************
void ESIaW (int &M, FILE * IWR)
{
  //  This subroutine generates tables of cross sections for inner-shell
  //  ionisation by electron impact for the elements in material M and
  //  writes them on the material data file.

  //  Data are read from the files 'pdesiZZ.p14'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;

  char FILEN[12];
  char LDIG[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LDIG1[2], LDIG2[2];

  const int NES = 850;
  double E[NES], XESIR[NES][16];

  int IZZ, IZZZ, NLD, NLD1, NLD2, NSHR, NPTAB = 0;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      char straux[30];
      strcpy (straux, "./pdfiles/");
      IZZ = IZ[M][IEL];
      NLD = IZZ;
      NLD1 = NLD - 10 * (NLD / 10);
      NLD2 = (NLD - NLD1) / 10;
      LDIG1[0] = LDIG[NLD1 + 1 - 1];
      LDIG1[1] = '\0';
      LDIG2[0] = LDIG[NLD2 + 1 - 1];
      LDIG2[1] = '\0';
      strcpy (FILEN, "pdesi");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p14");
      strcat (straux, FILEN);
      FILE *pdfiles = fopen (straux, "r");
      fscanf (pdfiles, "%*16c%2d%*6c%2d%*[^\n]", &IZZZ, &NSHR);
      getc (pdfiles);
      if (IZZZ != IZZ)
	{
	  ErrorFunction (1308);
	  return;
	}
      if (NSHR > 16)
	{
	  ErrorFunction (1309);
	  return;
	}
      fscanf (pdfiles, "%*[^\n]");
      getc (pdfiles);
      fscanf (pdfiles, "%*[^\n]");
      getc (pdfiles);

      for (int IE = 0; IE < NES; IE++)
	{
	  if (feof (pdfiles))
	    {
	      break;
	    }
	  fscanf (pdfiles, "%lf", &E[IE]);
	  for (int IS = 0; IS < NSHR; IS++)
	    {

	      if (IS < NSHR - 1)
		{
		  fscanf (pdfiles, "%lf", &XESIR[IE][IS]);
		}
	      else
		{
		  fscanf (pdfiles, "%lf%*[^\n]", &XESIR[IE][IS]);
		  getc (pdfiles);
		}
	    }

	  NPTAB = IE + 1;
	  if (E[IE] > 0.999E9)
	    {
	      break;
	    }
	}
      fclose (pdfiles);
      fprintf (IWR,
	       " *** Electron ionisation cross sections,  IZ =%3d,  NSHELL =%3d,  NDATA =%4d\n",
	       IZZ, NSHR, NPTAB);
      for (int IE = 0; IE < NPTAB; IE++)
	{
	  fprintf (IWR, "%12.5E", E[IE]);
	  for (int IS = 0; IS < NSHR; IS++)
	    {
	      if (IS < NSHR - 1)
		{
		  fprintf (IWR, "%12.5E", XESIR[IE][IS]);
		}
	      else
		{
		  fprintf (IWR, "%12.5E\n", XESIR[IE][IS]);
		}
	    }
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE PSIaW
//  *********************************************************************
void PSIaW (int &M, FILE * IWR)
{
  //  This subroutine generates tables of cross sections for inner-shell
  //  ionisation by positron impact for the elements in material M and
  //  writes them on the material data file.

  //  Data are read from the files 'pdpsiZZ.p14'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;

  char FILEN[12];
  char LDIG[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LDIG1[2], LDIG2[2];

  const int NES = 800;

  double E[NES], XPSIR[NES][16];

  int IZZ, NLD, NLD1, NLD2, IZZZ, NSHR, NPTAB = 0;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      char straux[30];
      strcpy (straux, "./pdfiles/");
      IZZ = IZ[M][IEL];
      NLD = IZZ;
      NLD1 = NLD - 10 * (NLD / 10);
      NLD2 = (NLD - NLD1) / 10;
      LDIG1[0] = LDIG[NLD1 + 1 - 1];
      LDIG1[1] = '\0';
      LDIG2[0] = LDIG[NLD2 + 1 - 1];
      LDIG2[1] = '\0';
      strcpy (FILEN, "pdpsi");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p14");
      strcat (straux, FILEN);

      FILE *pdfiles = fopen (straux, "r");
      fscanf (pdfiles, "%*16c%2d%*6c%2d%*[^\n]", &IZZZ, &NSHR);
      getc (pdfiles);
      if (IZZZ != IZZ)
	{
	  ErrorFunction (1314);
	  return;
	}
      if (NSHR > 16)
	{
	  ErrorFunction (1315);
	  return;
	}
      fscanf (pdfiles, "%*[^\n]");
      getc (pdfiles);
      fscanf (pdfiles, "%*[^\n]");
      getc (pdfiles);

      for (int IE = 0; IE < NES; IE++)
	{
	  if (feof (pdfiles))
	    {
	      break;
	    }
	  fscanf (pdfiles, "%lf", &E[IE]);
	  for (int IS = 0; IS < NSHR; IS++)
	    {
	      if (IS < NSHR - 1)
		{
		  fscanf (pdfiles, "%lf", &XPSIR[IE][IS]);
		}
	      else
		{
		  fscanf (pdfiles, "%lf%*[^\n]", &XPSIR[IE][IS]);
		  getc (pdfiles);
		}
	    }

	  NPTAB = IE + 1;
	  if (E[IE] > 0.999E9)
	    {
	      break;
	    }
	}
      fclose (pdfiles);
      fprintf (IWR,
	       " *** Positron ionisation cross sections,  IZ =%3d,  NSHELL =%3d,  NDATA =%4d\n",
	       IZZ, NSHR, NPTAB);
      for (int IE = 0; IE < NPTAB; IE++)
	{
	  fprintf (IWR, "%12.5E", E[IE]);
	  for (int IS = 0; IS < NSHR; IS++)
	    {
	      if (IS < NSHR - 1)
		{
		  fprintf (IWR, "%12.5E", XPSIR[IE][IS]);
		}
	      else
		{
		  fprintf (IWR, "%12.5E\n", XPSIR[IE][IS]);
		}
	    }
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE EBRaW
//  *********************************************************************
void EBRaW (int &M, FILE * IWR)
{
  //  This subroutine generates a table of the scaled energy-loss cross
  //  section for bremsstrahlung emission by electrons in material M. Data
  //  are read from the files 'pdebrZZ.p08'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;
  using namespace CEGRID;
  using namespace CEBR;
  using namespace CEBR01;
  using namespace CEBR02;

  const double TREV = 2.0 * REV;

  char FILEN[12];
  char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LDIG1[2], LDIG2[2];


  double A[NEGP], B[NEGP], C[NEGP], D[NEGP];
  double WB0[NBW] =
    { 1.0E-12, 0.025, 0.05, 0.075, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45,
0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.925, 0.95, 0.97, 0.99, 0.995, 0.999,
0.9995, 0.9999, 0.99995, 0.99999, 1.0 };
  double PDF[NBE];


  //  ****  'Equivalent' atomic number.

  double SUMZ2 = 0.0;
  double SUMS = 0.0;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      SUMZ2 = SUMZ2 + STF[M][IEL] * pow (IZ[M][IEL], 2);
      SUMS = SUMS + STF[M][IEL];
    }
  ZBR2[M] = SUMZ2 / SUMS;

  //  ****  Building the scaled cross section table.

  for (int IE = 0; IE < NBE; IE++)
    {
      TXS[IE] = 0.0;
      for (int IW = 0; IW < NBW; IW++)
	{
	  XS[IE][IW] = 0.0;
	}
    }
  int IZZ, NLD, NLD1, NLD2, IZZZ;
  double WGHT, TXSP;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      char straux[30];
      strcpy (straux, "./pdfiles/");
      IZZ = IZ[M][IEL];
      WGHT = STF[M][IEL] * IZZ * IZZ / ZBR2[M];
      NLD = IZZ;
      NLD1 = NLD - 10 * (NLD / 10);
      NLD2 = (NLD - NLD1) / 10;
      LDIG1[0] = LDIG[NLD1 + 1 - 1];
      LDIG1[1] = '\0';
      LDIG2[0] = LDIG[NLD2 + 1 - 1];
      LDIG2[1] = '\0';
      strcpy (FILEN, "pdebr");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p08");
      strcat (straux, FILEN);
      FILE *pdebr = fopen (straux, "r");
      fscanf (pdebr, "%d%*[^\n]", &IZZZ);
      getc (pdebr);
      if (IZZZ != IZZ)
	{
	  ErrorFunction (1317);
	  return;
	}
      for (int IE = 0; IE < NBE; IE++)
	{
	  fscanf (pdebr, "%lf", &EBT[IE]);
	  for (int IW = 0; IW < NBW; IW++)
	    {
	      if ((IW + 1) % 5 == 0)
		{
		  fscanf (pdebr, "%lf%*[^\n]", &PDF[IW]);
		  getc (pdebr);
		}
	      else
		{
		  fscanf (pdebr, "%lf", &PDF[IW]);
		}
	    }
	  fscanf (pdebr, "%*36c %lf%*[^\n]", &TXSP);
	  getc (pdebr);
	  TXS[IE] = TXS[IE] + WGHT * TXSP;
	  for (int IW = 0; IW < NBW; IW++)
	    {
	      XS[IE][IW] = XS[IE][IW] + WGHT * PDF[IW];
	    }
	}
      fclose (pdebr);
    }

  //  ****  The energy loss spectrum is re-normalised to reproduce the
  //        total scaled cross section of Berger and Seltzer.

  double RSUM, FACT, FNORM, TST;
  for (int IE = 0; IE < NBE; IE++)
    {
      for (int IW = 0; IW < NBW; IW++)
	{
	  X[IW] = WB0[IW];
	  Y[IW] = XS[IE][IW];
	}
      RSUM = RLMOM (X, Y, 1.0, NBW, 0);
      FACT =
	(EBT[IE] +
	 REV) * 1.0E-27 * 137.03604 / (pow (ELRAD, 2) * (EBT[IE] + TREV));
      FNORM = TXS[IE] / (RSUM * FACT);
      TST = 100.0 * fabs (FNORM - 1.0);
      if (TST > 1.0)
	{
	  ErrorFunction (1318);
	  return;
	}
      for (int IW = 0; IW < NBW; IW++)
	{
	  XS[IE][IW] = XS[IE][IW] * FNORM;
	}
    }

  //  ****  Write output scaled x-section table.

  fprintf (IWR,
	   " *** Electron scaled bremss x-section,  ZEQ =%12.5E,  NDATA =%4d\n",
	   sqrt (ZBR2[M]), NBE);
  for (int IE = 0; IE < NBE; IE++)
    {
      fprintf (IWR, "%9.2E", EBT[IE]);
      for (int IW = 0; IW < NBW; IW++)
	{
	  if (IW != 0 && IW % 5 == 0)
	    {
	      fprintf (IWR, "%*c", 9, ' ');
	    }
	  if ((IW + 1) % 5 == 0)
	    {
	      fprintf (IWR, "%12.5E\n", XS[IE][IW]);
	    }
	  else
	    {
	      fprintf (IWR, "%12.5E", XS[IE][IW]);
	    }

	}
      fprintf (IWR, "%*c%10.3E\n", 36, ' ', TXS[IE]);
    }


  //  ************  Initialisation of the calculation routines.

  for (int I = 0; I < NBW; I++)
    {
      WB[I] = WB0[I];
    }

  //  ****  Compute the scaled energy loss distribution and sampling
  //        parameters for the energies in the simulation grid.

  //  ****  Interpolation in E.

  double F1, FP1, ELL;
  int J;
  for (int IE = 0; IE < NBE; IE++)
    {
      X[IE] = log (EBT[IE]);
    }
  for (int IW = 0; IW < NBW; IW++)
    {
      for (int IE = 0; IE < NBE; IE++)
	{
	  Y[IE] = log (XS[IE][IW]);
	}
      SPLINE (X, Y, A, B, C, D, 0.0, 0.0, NBE);
      if (IRETRN != 0)
	{
	  return;
	}
      for (int I = 0; I < NEGP; I++)
	{
	  ELL = DLEMP[I];
	  if (ELL > X[0])
	    {
	      FINDI (X, ELL, NBE, J);
	      P0[M][I][IW] =
		exp (A[J - 1] +
		     ELL * (B[J - 1] + ELL * (C[J - 1] + ELL * D[J - 1])));
	    }
	  else
	    {
	      F1 = A[0] + X[0] * (B[0] + X[0] * (C[0] + X[0] * D[0]));
	      FP1 = B[0] + X[0] * (2.0 * C[0] + X[0] * 3.0 * D[0]);
	      P0[M][I][IW] = exp (F1 + FP1 * (ELL - X[0]));
	    }
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE BRaAW
//  *********************************************************************
void BRaAW (double &ZEQ, FILE * IWR)
{
  //  This subroutine generates the parameters of the angular distribution
  //  of bremsstrahlung photons for the element of atomic number ZEQ. In
  //  the case of compounds (and mixtures) ZEQ is the average atomic number
  //  of the elements in the molecule. The evaluated parameters are written
  //  on the material definition file. Data are read from the database file
  //  'pdbrang.p18'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  const int NZ = 13;
  const int NE = 7;
  const int NK = 10;

  char BUFFER[100];

  double Z[NZ], E[NE], XK[NK], P1[NZ][NE][NK], P2[NZ][NE][NK], Q1[NE][NK],
    Q2[NE][NK];
  double Y1[NZ], Y2[NZ], A[NZ], B[NZ], C[NZ], D[NZ], A2[NZ], B2[NZ];

  Z[0] = 1.0;
  Z[1] = 2.0;
  Z[2] = 5.0;
  Z[3] = 8.0;
  Z[4] = 11.0;
  Z[5] = 13.0;
  Z[6] = 26.0;
  Z[7] = 37.0;
  Z[8] = 47.0;
  Z[9] = 64.0;
  Z[10] = 79.0;
  Z[11] = 86.0;
  Z[12] = 92.0;

  E[0] = 1.0E3;
  E[1] = 5.0E3;
  E[2] = 1.0E4;
  E[3] = 5.0E4;
  E[4] = 1.0E5;
  E[5] = 5.0E5;
  E[6] = 1.0E6;

  XK[0] = 0.0;
  XK[1] = 0.1;
  XK[2] = 0.2;
  XK[3] = 0.3;
  XK[4] = 0.4;
  XK[5] = 0.5;
  XK[6] = 0.6;
  XK[7] = 0.7;
  XK[8] = 0.8;
  XK[9] = 0.95;

  //  ****  Read database file.
  int IZ, IE, IK, I;
  double ZR, ER, RKR, P1R, P2R, ERROR;
  FILE *pdfiles = fopen ("./pdfiles/pdbrang.p18", "r");
  fgets (BUFFER, 100, pdfiles);
  for (int IZ1 = 0; IZ1 < NZ; IZ1++)
    {
      for (int IE1 = 0; IE1 < NE; IE1++)
	{
	  for (int IK1 = 0; IK1 < NK; IK1++)
	    {
	      fscanf (pdfiles, "%d %d %d %lf %lf %lf %lf %lf %lf%*[^\n]", &IZ,
		      &IE, &IK, &ZR, &ER, &RKR, &P1R, &P2R, &ERROR);
	      getc (pdfiles);
	      if ((fabs (ZR - Z[IZ - 1]) < 1.0E-6)
		  && (fabs (ER - E[IE - 1]) < 1.0E-6)
		  && (fabs (RKR - XK[IK - 1]) < 1.0E-6))
		{
		  P1[IZ - 1][IE - 1][IK - 1] = P1R;
		  P2[IZ - 1][IE - 1][IK - 1] = P2R;
		}
	      else
		{
		  printf ("Corrupt data file (pdbrang.p08).\n");
		  ErrorFunction (1326);
		  return;
		}
	    }
	}
    }
  fclose (pdfiles);

  //  ****  Interpolation in Z.

  for (IE = 0; IE < NE; IE++)
    {
      for (IK = 0; IK < NK; IK++)
	{
	  for (IZ = 0; IZ < NZ; IZ++)
	    {
	      Y1[IZ] = log (P1[IZ][IE][IK] * Z[IZ]);
	      Y2[IZ] = P2[IZ][IE][IK];
	    }
	  for (IZ = 0; IZ < NZ - 1; IZ++)
	    {
	      A2[IZ] =
		Y2[IZ] - (Y2[IZ + 1] - Y2[IZ]) * Z[IZ] / (Z[IZ + 1] - Z[IZ]);
	      B2[IZ] = (Y2[IZ + 1] - Y2[IZ]) / (Z[IZ + 1] - Z[IZ]);
	    }
	  A2[NZ - 1] = A2[NZ - 2];
	  B2[NZ - 1] = B2[NZ - 2];
	  SPLINE (Z, Y1, A, B, C, D, 0.0, 0.0, NZ);
	  if (IRETRN != 0)
	    {
	      return;
	    }
	  FINDI (Z, ZEQ, NZ, I);
	  Q1[IE][IK] =
	    exp (A[I - 1] +
		 ZEQ * (B[I - 1] + ZEQ * (C[I - 1] + ZEQ * D[I - 1]))) / ZEQ;
	  if (Q1[IE][IK] > 1.0E0)
	    {
	      Q1[IE][IK] = 1.0E0;
	    }			// Corrects wrong values.
	  Q2[IE][IK] = A2[I - 1] + ZEQ * B2[I - 1];
	}
    }

  //  ****  Write final table of parameters.

  int NDATA = 70;
  fprintf (IWR,
	   " *** Bremss angular distribution,  ZEQ =%12.5E,  NDATA =%4d\n",
	   ZEQ, NDATA);
  for (IE = 0; IE < NE; IE++)
    {
      for (IK = 0; IK < NK; IK++)
	{
	  fprintf (IWR, "%3d%3d %10.3E %10.3E %14.7E %14.7E\n", IE + 1,
		   IK + 1, E[IE], XK[IK], Q1[IE][IK], Q2[IE][IK]);
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE GRAaW
//  *********************************************************************
void GRAaW (int &M, FILE * IWR)
{
  //  This subroutine generates tables of molecular form factors and cross
  //  sections for Rayleigh scattering of photons in material M and writes
  //  them on the material data file. Data are read from the files
  //  'pdgraZZ.p08'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;

  char FILEN[13];
  char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LDIG1[2], LDIG2[2];

  double Q[NQ], FF[NQ], FF2[NQ], ER[NEM], XSR[NEM];
  double EI[NEM], XS[NEM];

  //  ****  Momentum-transfer grid points and atomic form factor.
  for (int I = 0; I < NQ; I++)
    {
      Q[I] = 0.0;
      FF2[I] = 0.0;
    }
  //  ****  Energy grid points and Rayleigh x sections.
  double FACT1 = pow (10.0, (1.0 / 250.0));
  double FACT2 = pow (10.0, (1.0 / 25.0));
  double E = 10.0 / FACT1;
  int NE = 0;
  for (int I = 0; I < 2 * NEM; I++)
    {
      if (E < 1.5848E5)
	{
	  E = E * FACT1;
	}
      else
	{
	  E = E * FACT2;
	}
      if (E > 49.0)
	{
	  NE = NE + 1;
	  ER[NE - 1] = E;
	  XSR[NE - 1] = 0.0;
	  if (E > 1.2E9)
	    {
	      break;
	    }
	}
    }

  int IZZ, NLD, NLD1, NLD2, IZZZ, NQI, NEI;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      char straux[30];
      strcpy (straux, "./pdfiles/");
      IZZ = IZ[M][IEL];
      NLD = IZZ;
      NLD1 = NLD - 10 * (NLD / 10);
      NLD2 = (NLD - NLD1) / 10;

      LDIG1[0] = LDIG[NLD1 + 1 - 1];
      LDIG1[1] = '\0';
      LDIG2[0] = LDIG[NLD2 + 1 - 1];
      LDIG2[1] = '\0';
      strcpy (FILEN, "pdaff");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p08");
      strcat (straux, FILEN);
      FILE *pdaff = fopen (straux, "r");
      fscanf (pdaff, "%d %d%*[^\n]", &IZZZ, &NQI);
      getc (pdaff);

      if (IZZZ != IZZ)
	{
	  ErrorFunction (1330);
	  return;
	}
      if (NQI != NQ)
	{
	  ErrorFunction (1331);
	  return;
	}
      for (int I = 0; I < NQ; I++)
	{
	  fscanf (pdaff, "%lf %lf%*[^\n]", &Q[I], &FF[I]);
	  getc (pdaff);
	}
      fclose (pdaff);

      strcpy (straux, "./pdfiles/");
      strcpy (FILEN, "pdgra");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p08");
      strcat (straux, FILEN);
      FILE *pdgra = fopen (straux, "r");

      fscanf (pdgra, "%d %d%*[^\n]", &IZZZ, &NEI);
      getc (pdgra);
      if (IZZZ != IZZ)
	{
	  ErrorFunction (1332);
	  return;
	}
      for (int I = 0; I < NEI; I++)
	{
	  double FA1, FA2;
	  fscanf (pdgra, "%lf %lf %lf %lf%*[^\n]", &EI[I], &FA1, &FA2,
		  &XS[I]);
	  getc (pdgra);
	  EI[I] = log (EI[I]);
	  XS[I] = log (XS[I]);
	}
      fclose (pdgra);

      for (int I = 0; I < NQ; I++)
	{
	  FF2[I] = FF2[I] + STF[M][IEL] * pow (FF[I], 2);
	}
      for (int I = 0; I < NE; I++)
	{
	  int J;
	  double EE = log (ER[I]);
	  FINDI (EI, EE, NEI, J);
	  double XSE =
	    exp (XS[J - 1] +
		 (XS[J + 1 - 1] - XS[J - 1]) * (EE -
						EI[J - 1]) / (EI[J + 1 - 1] -
							      EI[J - 1]));
	  XSR[I] = XSR[I] + STF[M][IEL] * XSE;
	}
    }

  fprintf (IWR, " *** Rayleigh scattering.  NQ = %3d,  NE = %4d\n", NQ, NE);
  for (int I = 0; I < NQ; I++)
    {
      fprintf (IWR, "%9.2E%12.5E\n", Q[I], sqrt (FF2[I]));
    }
  for (int I = 0; I < NE; I++)
    {
      fprintf (IWR, "%12.5E%12.5E\n", ER[I], XSR[I]);
    }
}

//  *********************************************************************
//                       SUBROUTINE GPHaW
//  *********************************************************************
void GPHaW (int &M, FILE * IWR)
{
  //  This subroutine generates the table of photoelectric cross sections
  //  for photons in material M and writes it on the material data file.
  //  Data are read from the files 'pdgphZZ.p18'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;

  char FILEN[12];
  char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LDIG1[2], LDIG2[2];

  const int NPHM = 2000;
  double XS[17], E0[500], XS0[500][17];
  int ISH[17];

  int IZZ, NLD, NLD1, NLD2, IZZZ, NGP, NSHR;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      IZZ = IZ[M][IEL];
      NLD = IZZ;
      NLD1 = NLD - 10 * (NLD / 10);
      NLD2 = (NLD - NLD1) / 10;
      LDIG1[0] = LDIG[NLD1 + 1 - 1];
      LDIG1[1] = '\0';
      LDIG2[0] = LDIG[NLD2 + 1 - 1];
      LDIG2[1] = '\0';
      char straux[30];
      strcpy (straux, "./pdfiles/");
      strcpy (FILEN, "pdgph");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p18");
      strcat (straux, FILEN);
      FILE *pdgph = fopen (straux, "r");
      fscanf (pdgph, "%*15c%2d %2d %4d%*[^\n]", &IZZZ, &NSHR, &NGP);
      getc (pdgph);

      if (NGP > NPHM)
	{
	  ErrorFunction (1337);
	  return;
	}
      if (IZZZ != IZZ)
	{
	  ErrorFunction (1338);
	  return;
	}
      if (NSHR > 16)
	{
	  ErrorFunction (1339);
	  return;
	}
      ISH[0] = 0;
      if (NSHR > 0)
	{
	  fscanf (pdgph, "%*25c");
	  for (int IS = 1; IS < NSHR + 1 - 1; IS++)
	    {
	      fscanf (pdgph, "%2d%*10c", &ISH[IS]);
	    }
	  fscanf (pdgph, "%2d%*[^\n]", &ISH[NSHR + 1 - 1]);
	  getc (pdgph);
	}
      else
	{
	  fscanf (pdgph, "%*[^\n]");
	  getc (pdgph);
	}
      fscanf (pdgph, "%*[^\n]");
      getc (pdgph);

      int NPTAB = 0;
      for (int IE = 0; IE < NGP; IE++)
	{
	  double ER;
	  if (feof (pdgph))
	    {
	      break;
	    }
	  fscanf (pdgph, "%lf", &ER);
	  for (int IS = 0; IS < NSHR + 1; IS++)
	    {
	      fscanf (pdgph, "%lf", &XS[IS]);
	    }
	  fscanf (pdgph, "%*[^\n]");
	  getc (pdgph);

	  if (ER > 49.9 && ER < 1.01E9)
	    {
	      NPTAB = NPTAB + 1;
	      E0[NPTAB - 1] = ER;
	      for (int IS = 0; IS < NSHR + 1; IS++)
		{
		  XS0[NPTAB - 1][IS] = XS[IS] * 1.0E-24;
		}
	    }
	}
      fclose (pdgph);
      fprintf (IWR,
	       " *** Photoelectric cross sections,  IZ =%3d,  NSHELL =%3d,  NDATA =%5d\n",
	       IZZ, NSHR, NPTAB);

      fprintf (IWR, "%13c%2d", ' ', 0);
      for (int IS = 1; IS < NSHR + 1; IS++)
	{
	  fprintf (IWR, "%10c%2d", ' ', ISH[IS]);
	}
      fprintf (IWR, "\n");
      for (int IE = 0; IE < NPTAB; IE++)
	{
	  fprintf (IWR, "%12.5E", E0[IE]);
	  for (int IS = 0; IS < NSHR + 1; IS++)
	    {
	      fprintf (IWR, "%12.5E", XS0[IE][IS]);
	    }
	  fprintf (IWR, "\n");
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE GPPaW
//  *********************************************************************
void GPPaW (double *EIT, double *XGP0, double *XGT0, int &NPTAB, int &M)
{
  //  This subroutine generates a table of electron-positron pair produc-
  //  tion cross sections for photons in material M. Data are read from the
  //  files 'pdgppZZ.p11'.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;

  char FILEN[12];
  char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LDIG1[2], LDIG2[2];

  const int NEGPP = 10000;
  //double EIT[NEGPP], XGP0[NEGPP], XGT0[NEGPP];

  //  ****  Building the cross section table.

  for (int I = 0; I < NEGPP; I++)
    {
      XGP0[I] = 0.0;
      XGT0[I] = 0.0;
    }

  int IZZ, NLD, NLD1, NLD2, IZZZ;
  double WGHT;
  for (int IEL = 0; IEL < NELEM[M]; IEL++)
    {
      char straux[30];
      strcpy (straux, "./pdfiles/");
      IZZ = IZ[M][IEL];
      WGHT = STF[M][IEL] * 1.0E-24;
      NLD = IZZ;
      NLD1 = NLD - 10 * (NLD / 10);
      NLD2 = (NLD - NLD1) / 10;
      LDIG1[0] = LDIG[NLD1 + 1 - 1];
      LDIG1[1] = '\0';
      LDIG2[0] = LDIG[NLD2 + 1 - 1];
      LDIG2[1] = '\0';

      strcpy (FILEN, "pdgpp");
      strcat (FILEN, LDIG2);
      strcat (FILEN, LDIG1);
      strcat (FILEN, ".p11");
      strcat (straux, FILEN);
      FILE *pdgpp = fopen (straux, "r");

      fscanf (pdgpp, "%d%*[^\n]", &IZZZ);
      getc (pdgpp);

      if (IZZZ != IZZ)
	{
	  ErrorFunction (1340);
	  return;
	}
      for (int I = 0; I < NEGPP; I++)
	{
	  double XG0P, XG0T;
	  fscanf (pdgpp, "%lf %lf %lf%*[^\n]", &EIT[I], &XG0P, &XG0T);
	  getc (pdgpp);
	  XGP0[I] = XGP0[I] + WGHT * XG0P;
	  XGT0[I] = XGT0[I] + WGHT * XG0T;
	  NPTAB = I + 1;
	  if (EIT[I] > 0.999E9)
	    {
	      break;
	    }
	}
      fclose (pdgpp);
    }
}

//  *********************************************************************
//                       SUBROUTINE RELAXW
//  *********************************************************************
void RELAXW (int &IZ, FILE * IWR)
{
  //  This subroutine produces a table of atomic relaxation data for the
  //  element IZ, and prints it on unit IWR. The output table is part of
  //  PENELOPE's material definition file.

  //  Data are read from file 'pdrelax.p11', which contains data pertaining
  //  to singly ionised atoms with the initial vacancy in one of the K, L,
  //  M and N shells. This file was prepared from the Livermore Evaluated
  //  Atomic Data Library (EADL). The energies of x-ray lines were replaced
  //  by more accurate experimental and theoretical values given by
  //  Deslattes et al. (2003) -K and L shells- and by Burr (1967) -M
  //  shells.

  //  NOTE: The transition probabilities and emission energies can be
  //  modified by editing the material data file. For each initial vacancy,
  //  the sum of transition probabilities _must_ be equal to unity.

  using namespace PENERROR_mod;
  using namespace CADATA;

  char CSH5[30][6] =
    { "1s1/2", "2s1/2", "2p1/2", "2p3/2", "3s1/2", "3p1/2", "3p3/2", "3d3/2",
"3d5/2", "4s1/2", "4p1/2", "4p3/2", "4d3/2", "4d5/2", "4f5/2", "4f7/2", "5s1/2", "5p1/2",
"5p3/2", "5d3/2", "5d5/2", "5f5/2", "5f7/2", "6s1/2", "6p1/2", "6p3/2", "6d3/2", "6d5/2",
"7s1/2", " free" };

  const int NM = 2500;
  int IS0[NM], IS1[NM], IS2[NM];
  double P[NM], EI[NM], EE[99];

  int NT = 0;
  double ET;

  if (NSHT[IZ - 1] <= 0)
    {
      ErrorFunction (1345);
      return;
    }
  FILE *pdrelax = fopen ("./pdfiles/pdrelax.p11", "r");
  int IZR, IS0R;
  int Nombre_elements_llegits = fscanf (pdrelax, "%d %d%*[^\n]", &IZR, &IS0R);	// Ignores the data.
  getc (pdrelax);
  if (Nombre_elements_llegits == 2)
    {
      NT = 0;
      int IS1R, IS2R;
      double PR, EIN;
      for (int I = 0; I < 150000; I++)
	{
	  Nombre_elements_llegits =
	    fscanf (pdrelax, "%d %d %d %d %lf %lf%*[^\n]", &IZR, &IS0R, &IS1R,
		    &IS2R, &PR, &EIN);
	  getc (pdrelax);
	  if (Nombre_elements_llegits != 6)
	    {
	      break;
	    }

	  if (IZR == IZ)
	    {
	      NT = NT + 1;
	      if (NT > NM)
		{
		  ErrorFunction (1346);
		  return;
		}
	      IS0[NT - 1] = IS0R;
	      IS1[NT - 1] = IS1R;
	      IS2[NT - 1] = IS2R;
	      P[NT - 1] = PR;
	      EI[NT - 1] = EIN;
	    }
	}
    }
  fclose (pdrelax);

  fprintf (IWR,
	   " *** RELAX:  Z =%3d,  no. of shells =%3d,  no. of transitions =%5d\n",
	   IZ, NSHT[IZ - 1], NT);

  for (int I = 0; I < 99; I++)
    {
      EE[I] = 0.0;
    }
  int KS;
  for (int J = 0; J < 30; J++)
    {
      KS = IKS[IZ - 1][J];
      if (KS > 0)
	{
	  if (IFI[IZ - 1][KS - 1] != 0)
	    {
	      fprintf (IWR, " %3d %5s %1d %12.5E %12.5E %12.5E\n", KS,
		       CSH5[KS - 1], IFI[IZ - 1][KS - 1], EB[IZ - 1][KS - 1],
		       ALW[IZ - 1][KS - 1], CP0[IZ - 1][KS - 1]);
	      EE[KS - 1] = EB[IZ - 1][KS - 1];
	    }
	}
    }

  if (NT > 0)
    {
      for (int I = 0; I < NT; I++)
	{
	  if (IS2[I] == 0)
	    {
	      if (EI[I] < 1.0)
		{
		  ET = EE[IS0[I] - 1] - EE[IS1[I] - 1];
		}
	      else
		{
		  ET = EI[I];
		}
	    }
	  else
	    {
	      if (EI[I] < 1.0)
		{
		  ET = EE[IS0[I] - 1] - EE[IS1[I] - 1] - EE[IS2[I] - 1];
		}
	      else
		{
		  ET = EI[I];
		}
	    }
	  if (ET < 1.0)
	    {
	      ET = 1.0;
	    }
	  fprintf (IWR, " %3d%3d%3d %12.5E %12.5E\n", IS0[I], IS1[I], IS2[I],
		   P[I], ET);
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE EELdW
//  *********************************************************************
void EELdW (int &M, FILE * IWR)
{
  //  This subroutine generates a table of differential cross sections for
  //  elastic scattering of electrons and positrons in material M, and
  //  writes it on the material definition file. Data are read from the
  //  ELSEPA elastic database files.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;
  using namespace CDCSEP;

  const int NE = 96;

  int IZM[30];
  double STFM[30];

  for (int I = 0; I < NELEM[M]; I++)
    {
      IZM[I] = IZ[M][I];
      STFM[I] = STF[M][I];
    }
  ELINIT (IZM, STFM, NELEM[M]);
  if (IRETRN != 0)
    {
      return;
    }

  //  ************  Write final DCS tables.

  //  ****  Electrons.

  int IELEC = -1;
  fprintf (IWR, " *** Electron elastic differential cross sections\n");
  double ECS0, ECS1, ECS2, TCS1, TCS2, TS0, TS1, TS2, TSTE;
  for (int IE = 0; IE < NE; IE++)
    {
      for (int K = 0; K < NA; K++)
	{
	  DCSI[K] = EDCS[IE][K];
	}
      ECS0 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 0);
      if (IRETRN != 0)
	{
	  return;
	}
      ECS1 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 1);
      ECS2 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 2);
      TCS1 = 2.0 * ECS1;
      TCS2 = 6.0 * (ECS1 - ECS2);
      fprintf (IWR, "%3d%10.3E%12.5E%12.5E%12.5E\n", IELEC, ETS[IE], ECS0,
	       TCS1, TCS2);
      for (int K = 0; K < NA; K++)
	{
	  fprintf (IWR, " %11.5E", EDCS[IE][K]);
	  if ((K + 1) % 10 == 0)
	    {
	      fprintf (IWR, "\n");
	    }
	}
      fprintf (IWR, "\n");
      //  ****  Consistency test.
      TS0 = (ECS0 - ECS[IE]) / ECS[IE];
      TS1 = (TCS1 - ETCS1[IE]) / ETCS1[IE];
      TS2 = (TCS2 - ETCS2[IE]) / ETCS2[IE];

      TSTE = fabs (TS0);
      if (TSTE < fabs (TS1))
	{
	  TSTE = fabs (TS1);
	}
      if (TSTE < fabs (TS2))
	{
	  TSTE = fabs (TS2);
	}

      if (TSTE > 1.0E-2)
	{
	  fprintf (IWR, "( E=%12.5E)", ETS[IE]);
	  fprintf (IWR, "(    %11.5E %11.5E %11.5E)", ECS0, TCS1, TCS2);
	  fprintf (IWR, "(    %11.5E %11.5E %11.5E)", ECS[IE], ETCS1[IE],
		   ETCS2[IE]);
	  fprintf (IWR, " Electron cross section data are corrupt.\n");
	  ErrorFunction (1347);
	  return;
	}
    }

  //  ****  Positrons.

  IELEC = +1;
  fprintf (IWR, " *** Positron elastic differential cross sections\n");

  for (int IE = 0; IE < NE; IE++)
    {
      for (int K = 0; K < NA; K++)
	{
	  DCSI[K] = PDCS[IE][K];
	}
      ECS0 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 0);
      if (IRETRN != 0)
	{
	  return;
	}
      ECS1 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 1);
      ECS2 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 2);
      TCS1 = 2.0 * ECS1;
      TCS2 = 6.0 * (ECS1 - ECS2);
      fprintf (IWR, "%3d%10.3E%12.5E%12.5E%12.5E\n", IELEC, ETS[IE], ECS0,
	       TCS1, TCS2);
      for (int K = 0; K < NA; K++)
	{
	  fprintf (IWR, " %11.5E", PDCS[IE][K]);
	  if ((K + 1) % 10 == 0)
	    {
	      fprintf (IWR, "\n");
	    }
	}
      fprintf (IWR, "\n");
      //  ****  Consistency test.
      TS0 = (ECS0 - PCS[IE]) / PCS[IE];
      TS1 = (TCS1 - PTCS1[IE]) / PTCS1[IE];
      TS2 = (TCS2 - PTCS2[IE]) / PTCS2[IE];

      TSTE = fabs (TS0);
      if (TSTE < fabs (TS1))
	{
	  TSTE = fabs (TS1);
	}
      if (TSTE < fabs (TS2))
	{
	  TSTE = fabs (TS2);
	}

      if (TSTE > 1.0E-2)
	{
	  fprintf (IWR, "( E= %11.5E)\n", ETS[IE]);
	  fprintf (IWR, "    %11.5E %11.5E %11.5E\n", ECS0, TCS1, TCS2);
	  fprintf (IWR, "    %11.5E %11.5E %11.5E\n", PCS[IE], PTCS1[IE],
		   PTCS2[IE]);
	  fprintf (IWR, " Positron cross section data are corrupt.\n");
	  ErrorFunction (1348);
	  return;
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE PEMATW
//  *********************************************************************
void PEMATW (int IFILE, char MFNAME[20])
{

  //  This subroutine generates the material definition file, a part of the
  //  input data file of PENELOPE.
  //
  //  When IFILE=1 the output file is given the name MFNAME, otherwise the
  //  user is asked to provide the filename. 

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace COMPOS;
  using namespace CADATA;
  using namespace CEGRID;
  using namespace CEIN;
  using namespace CGCO;
  using namespace CEBR;

  char PFILE[81], NAME[63];
  const double TREV = 2.0 * REV;
  const double FOURPI = 4.0 * PI;

  double FBW[30];
  double FF[NOM], UUI[NOM], FFJ0[NOM], WWRI[NOM];
  int KKZ[NOM], KKS[NOM];
  double FFT[NOM], UIT[NOM], WRIT[NOM];
  int KZT[NOM], KST[NOM];
  double FC[NOM], UIC[NOM], FJ0C[NOM];
  int KZC[NOM], KSC[NOM];

  double EGRT[17] =
    { 1.0, 1.25, 1.50, 1.75, 2.00, 2.50, 3.00, 3.50, 4.00, 4.50, 5.00, 5.50,
6.00, 7.00, 8.00, 9.00, 1.00E1 };

  //  ****  'Standard' energy grid.
  double EIT[NEGP1], ES[NEGP1], ESS[NEGP1];
  double XGP0[NEGP1], XGT0[NEGP1], PPE[NEGP1], PPT[NEGP1];


  //  ****  Lowest negative valences of the elements.

  double VAL[99] = { 0, 0, -1, -2, -3, -2, 0, 0, 0,
    /*1 */ 0, -1, -2, -3, -2, -3, -4, 0, 0, -1,
    /*2 */ -2, -3, -2, -2, -2, -2, -2, -2, -2, -1,
    /*3 */ -2, -3, -2, -3, -4, 0, 0, -1, -2, -3,
    /*4 */ -4, -3, -6, -4, -3, -3, -2, -1, -2, -3,
    /*5 */ -2, -3, -4, 0, 0, -1, -2, -3, -3, -3,
    /*6 */ -3, -3, -2, -2, -3, -3, -3, -3, -3, -3,
    /*7 */ -2, -3, -4, -5, -6, -4, -3, -3, -2, -1,
    /*8 */ -1, -1, -2, -3, -2, 0, 0, -1, -2, -3,
    /*9 */ -4, -4, -3, -3, -3, -3, -3, -3, -3, -3
  };
  //           0   1   2   3   4   5   6   7   8   9


  int M = 0;
  int IREAD;
  int IREAD2;
  int IZZ;
  int IORD;
  int NS;
  int IIF;
  bool Eixir;
  double RGROUP;
  int IDNUM;

  printf
    ("      \n Select one option (1 or 2):\n   1: Enter composition data from the keyboard\n   2: Read them from the file pdcompos.pen\n");
  scanf ("%d", &IREAD);
  if (IREAD == 1)
    {
      //  ************  Data entered from keyboard.

      printf
	("Enter material name, for your information (no more than 60 characters) ...\n");
      scanf ("%62s", NAME);
      printf (" Material: %s\n", NAME);

      ZT[M] = 0.0;
      AT[M] = 0.0;
      EXPOT[M] = 0.0;
      //  ****  Chemical formula or fractions by weight.
      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  printf (" Chemical formula:\n");
	  printf (" Number of elements in the molecule...\n");
	  scanf ("%d", &NELEM[M]);
	  if (NELEM[M] < 1 || NELEM[M] > 30)
	    {
	      printf (" NELEM must be positive and less than 31.\n");
	      printf (" Please, enter an allowed value.\n");
	      Eixir = false;
	    }
	}
      printf (" Number of elements = %2d\n", NELEM[M]);

      if (NELEM[0] == 1)
	{
	  Eixir = false;
	  while (!Eixir)
	    {
	      Eixir = true;
	      printf ("\n Enter atomic number of the element...\n");
	      scanf ("%d", &IZZ);
	      if (IZZ < 1 || IZZ > 99)
		{
		  printf (" The atomic number must be in the range 1-99.\n");
		  printf (" Please, enter an allowed value.\n");
		  Eixir = false;
		}
	    }
	  IZ[M][0] = IZZ;
	  STF[M][0] = 1.0;
	  printf ("  Element: %2s (Z=%2d), atoms/molecule = %12.5E\n",
		  LASYMB[IZZ - 1], IZZ, STF[M][0]);
	  ZT[M] = IZZ;
	  AT[M] = ATW[IZZ - 1];
	  EXPOT[M] = IZZ * log (EPX[IZZ - 1]);
	}
      else
	{
	  printf (" Select one option (1 or 2):\n");
	  printf ("   1: Enter chemical (stoichiometric) formula\n");
	  printf ("   2: Enter fraction by weight of each element\n");
	  scanf ("%d", &IREAD2);

	  if (IREAD2 == 2)
	    {
	      printf ("\n Weight fractions...\n");
	      for (int I = 0; I < NELEM[M]; I++)
		{
		  Eixir = false;
		  while (!Eixir)
		    {
		      Eixir = true;
		      if (I == 0)
			{
			  printf
			    ("  Enter atomic number and fraction by weight of the first element ...\n");
			}
		      else if (I == 1)
			{
			  printf
			    ("  Enter atomic number and fraction by weight of the second element ...\n");
			}
		      else if (I == 2)
			{
			  printf
			    ("  Enter atomic number and fraction by weight of the third element ...\n");
			}
		      else
			{
			  printf
			    ("  Enter atomic number and fraction by weight of the %d-th element ...\n",
			     I + 1);
			}
		      scanf ("%d %lf", &IZZ, &FBW[I]);
		      if (IZZ < 1 || IZZ > 99)
			{
			  printf
			    (" The atomic number must be in the range 1-99.\n");
			  printf (" Please, enter an allowed value.\n");
			  Eixir = false;
			}
		      if (FBW[I] <= 0.0)
			{
			  printf
			    (" The fraction by weight must be positive.\n");
			  printf (" Please, enter a positive value.\n");
			  Eixir = false;
			}
		    }
		  printf ("\n");
		  IZ[M][I] = IZZ;
		  printf
		    ("  Element: %2s (Z=%2d), fraction by weight = %12.5E\n",
		     LASYMB[IZZ - 1], IZZ, FBW[I]);
		  if (I > 0)
		    {
		      for (int K = 0; K <= I - 1; K++)
			{
			  if (IZZ == IZ[M][K])
			    {
			      ErrorFunction (1101);
			      return;
			    }
			}
		    }
		  STF[M][I] = FBW[I] / ATW[IZZ - 1];
		}		//END FOR I

	      double STFM = 0.0;
	      for (int I = 0; I < NELEM[M]; I++)
		{
		  if (STF[M][I] > STFM)
		    {
		      STFM = STF[M][I];
		    }
		}
	      if (STFM < 1.0E-16)
		{
		  ErrorFunction (1102);
		  return;
		};
	      for (int I = 0; I < NELEM[M]; I++)
		{
		  STF[M][I] = STF[M][I] / STFM;
		}

	      printf ("\n");
	      for (int I = 0; I < NELEM[M]; I++)
		{
		  IZZ = IZ[M][I];
		  printf ("  Element: %2s (Z=%2d) atoms/molecule = %12.5E\n",
			  LASYMB[IZZ - 1], IZZ, STF[M][I]);
		  ZT[M] = ZT[M] + IZZ * STF[M][I];
		  AT[M] = AT[M] + ATW[IZZ - 1] * STF[M][I];
		  EXPOT[M] = EXPOT[M] + IZZ * log (EPX[IZZ - 1]) * STF[M][I];
		}
	    }
	  else			//IREAD2=1
	    {

	      printf (" Stoichiometric indexes...\n");
	      for (int I = 0; I < NELEM[M]; I++)
		{
		  Eixir = false;
		  while (!Eixir)
		    {
		      Eixir = true;
		      if (I == 0)
			{
			  printf
			    ("  Enter atomic number and number of atoms/molecule of the first element ...\n");
			}
		      else if (I == 1)
			{
			  printf
			    ("  Enter atomic number and number of atoms/molecule of the second element ...\n");
			}
		      else if (I == 2)
			{
			  printf
			    ("  Enter atomic number and number of atoms/molecule of the third element ...\n");
			}
		      else
			{
			  printf
			    ("  Enter atomic number and number of atoms/molecule of the %d-th element ...",
			     I + 1);
			}
		      scanf ("%d %lf", &IZZ, &STF[M][I]);
		      if (IZZ < 1 || IZZ > 99)
			{
			  printf
			    (" The atomic number must be in the range 1-99.\n");
			  printf (" Please, enter an allowed value.\n");
			  Eixir = false;
			}
		      if (STF[M][I] <= 0.0)
			{
			  printf
			    (" The stoichiometric fraction must be positive.\n");
			  printf (" Please, enter a positive value.\n");
			  Eixir = false;
			}
		    }
		  IZ[M][I] = IZZ;
		  printf ("  Element %s (Z=%2d), atoms/molecule = %12.5E\n",
			  LASYMB[IZZ - 1], IZZ, STF[M][I]);
		  if (I > 0)
		    {
		      for (int K = 0; K <= I - 1; K++)
			{
			  if (IZZ == IZ[M][K])
			    {
			      ErrorFunction (1103);
			      return;
			    }
			}
		    }
		  ZT[M] = ZT[M] + IZZ * STF[M][I];
		  AT[M] = AT[M] + ATW[IZZ - 1] * STF[M][I];
		  EXPOT[M] = EXPOT[M] + IZZ * log (EPX[IZZ - 1]) * STF[M][I];
		}
	    }
	}

      EXPOT[M] = exp (EXPOT[M] / ZT[M]);
      printf ("\n  The calculated mean excitation energy I is %12.5E eV\n",
	      EXPOT[M]);
      printf (" Do you want to change it?   (1=yes,2=no)\n");
      int IYESNO;
      scanf ("%d", &IYESNO);
      if (IYESNO == 1)
	{
	  Eixir = false;
	  while (!Eixir)
	    {
	      Eixir = true;
	      printf ("\n Enter mean excitation energy (eV) ...\n");
	      scanf ("%lf", &EXPOT[M]);
	      printf ("  Mean excitation energy =%12.5E eV\n", EXPOT[M]);
	      if (EXPOT[M] < 1.0)
		{
		  printf
		    (" The mean exc. energy must be larger than 1 eV.\n");
		  printf (" Please, enter a valid value.\n");
		  Eixir = false;
		}
	    }
	}

      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  printf ("\n Enter mass density (g/cm^3) ...\n");
	  scanf ("%lf", &RHO[M]);
	  printf ("  Density = %12.5E g/cm**3\n", RHO[M]);
	  if (RHO[M] <= 0.0)
	    {
	      printf (" The mass density must be positive.\n");
	      printf (" Please, enter a positive value.\n");
	      Eixir = false;
	    }
	}
      VMOL[M] = AVOG * RHO[M] / AT[M];
    }
  else
    {
      //
      //  ************  Material data read from file 'pdcompos.pen'.
      //
      printf (" Enter material identification number ...\n");
      scanf ("%d", &IDNUM);
      if (IDNUM < 1 || IDNUM > 300)
	{
	  ErrorFunction (1104);
	  return;
	}

      FILE *pdcompos = fopen ("./pdfiles/pdcompos.pen", "r");
      if (pdcompos == NULL)
	{
	  ErrorFunction (1107);
	  return;
	}
      for (int I = 0; I < 15; I++)	//Pasem 15 linies
	{
	  char BUFFER[256];
	  fgets (BUFFER, 256, pdcompos);
	}
      for (int K1 = 0; K1 < 300; K1++)
	{
	  fscanf (pdcompos, "%3d %62c%*[^\n]", &IORD, NAME);
	  getc (pdcompos);
	  //Append end of string chars
	  NAME[62] = '\0';
	  double HOLLOW;
	  fscanf (pdcompos, "%d %lf %lf %lf%*[^\n]", &NELEM[M], &HOLLOW,
		  &EXPOT[M], &RHO[M]);
	  getc (pdcompos);
	  if (NELEM[M] > 30)
	    {
	      ErrorFunction (1105);
	      return;
	    }
	  if (NELEM[M] < 1)
	    {
	      ErrorFunction (1106);
	      return;
	    }
	  for (int I = 0; I < NELEM[M]; I++)
	    {
	      fscanf (pdcompos, "%d %lf %lf%*[^\n]", &IZ[M][I], &HOLLOW,
		      &STF[M][I]);
	      getc (pdcompos);
	    }
	  if (IORD == IDNUM)
	    {
	      break;
	    }
	}
      fclose (pdcompos);
      printf ("  %3d %62s\n", IORD, NAME);

      ZT[M] = 0.0;
      AT[M] = 0.0;
      for (int I = 0; I < NELEM[M]; I++)
	{
	  IZZ = IZ[M][I];
	  if (IZZ < 1 || IZZ > 99)
	    {
	      printf ("  Element:    (Z=%2d), atoms/molecule = %12.5E\n", IZZ,
		      STF[M][I]);
	      ErrorFunction (1108);
	      return;
	    }
	  printf ("  Element: %s (Z=%2d), atoms/molecule =%12.5E\n",
		  LASYMB[IZZ - 1], IZZ, STF[M][I]);
	  if (STF[M][I] <= 0.0)
	    {
	      ErrorFunction (1109);
	      return;
	    }
	  if (I > 0)
	    {
	      for (int K = 0; K <= I - 1; K++)
		{
		  if (IZZ == IZ[M][K])
		    {
		      ErrorFunction (1110);
		      return;
		    }
		}
	    }
	  ZT[M] = ZT[M] + IZZ * STF[M][I];
	  AT[M] = AT[M] + ATW[IZZ - 1] * STF[M][I];
	}
      printf ("  Density = %12.5E g/cm**3\n", RHO[M]);
      printf ("  Number of electrons per molecule = %12.5E\n", ZT[M]);
      if (RHO[M] <= 0.0)
	{
	  ErrorFunction (1111);
	  return;
	}
      printf ("  Mean excitation energy = %12.5E eV\n", EXPOT[M]);
      VMOL[M] = AVOG * RHO[M] / AT[M];
    }

  //  ************  Atomic configuration.

  for (int I = 0; I < 99; I++)
    {
      NSHT[I] = 0;
      for (int J = 0; J < 30; J++)
	{
	  EB[I][J] = 0.0;
	  CP0[I][J] = 0.0;
	  IFI[I][J] = 0;
	  IKS[I][J] = 0;
	}
    }
  for (int I = 0; I < NELEM[M]; I++)
    {
      IZZ = IZ[M][I];
      //  ****  Loads element data only once. NSHT(IZZ) is used as a status
      //        indicator.
      if (NSHT[IZZ - 1] == 0)
	{
	  FILE *pdatconf = fopen ("./pdfiles/pdatconf.p14", "r");
	  for (int J = 0; J < 22; J++)
	    {
	      char BUFFER[256];
	      fgets (BUFFER, 256, pdatconf);
	    }
	  NS = 0;
	  int IZZT = 0;
	  for (int J = 0; J < 150000; J++)
	    {
	      int IS, IIZ;
	      char CH2[3];
	      char CH5[6];
	      double EIE, CCP, GA1, GA2;
	      if (EOF ==
		  fscanf (pdatconf,
			  "%3d %4d %2s %5s %3d %lf %lf %lf %lf%*[^\n]", &IIZ,
			  &IS, CH2, CH5, &IIF, &EIE, &CCP, &GA1, &GA2))
		{
		  break;
		}
	      getc (pdatconf);
	      if (IIZ == IZZ)
		{
		  NS = NS + 1;
		  if (NS > 30)
		    {
		      printf (" NS =%4d\n", NS);
		      ErrorFunction (1112);
		      return;
		    }
		  if (IS < 1 || IS > 30)
		    {
		      printf (" IS =%4d\n", IS);
		      ErrorFunction (1113);
		      return;
		    }
		  IZZT = IZZT + IIF;
		  EB[IZZ - 1][IS - 1] = EIE;
		  if (GA2 > 0.0)
		    {
		      ALW[IZZ - 1][IS - 1] = GA2;
		    }
		  else if (GA1 > 0.0)
		    {
		      ALW[IZZ - 1][IS - 1] = GA1;
		    }
		  else
		    {
		      ALW[IZZ - 1][IS - 1] = 0.0;
		    }
		  CP0[IZZ - 1][IS - 1] = CCP;
		  IFI[IZZ - 1][IS - 1] = IIF;
		  IKS[IZZ - 1][NS - 1] = IS;
		}
	    }
	  NSHT[IZZ - 1] = NS;
	  if (IZZ != IZZT)
	    {
	      ErrorFunction (1114);
	      return;
	    }
	  fclose (pdatconf);
	}
    }

  //  ************  E/P inelastic scattering model parameters.

  //  ****  Set the oscillator table (analogous to ICRU37).

  for (int I = 0; I < NO; I++)
    {
      F[M][I] = 0.0;
      UI[M][I] = 0.0;
      WRI[M][I] = 0.0;
      KZ[M][I] = 0;
      KS[M][I] = 0;
    }

  for (int I = 0; I < NOM; I++)
    {
      FF[I] = 0.0;
      UUI[I] = 0.0;
      WWRI[I] = 0.0;
      FFJ0[I] = 0.0;
      KKZ[I] = 0;
      KKS[I] = 0;
    }
  double FT = 0.0;
  //  ****  The 1st oscillator corresponds to the conduction band, which is
  //  tentatively assumed to consist of valence electrons (each atom con-
  //  tributes a number of electrons equal to its lowest chemical valence).
  int NOS = 1;
  FF[0] = 0.0;
  UUI[0] = 0.0;
  FFJ0[0] = 0.0;
  KKZ[0] = 0;
  KKS[0] = 30;
  for (int I = 0; I < NELEM[M]; I++)
    {
      IZZ = IZ[M][I];
      FF[0] = FF[0] + fabs (VAL[IZZ - 1]) * STF[M][I];
      for (int K = 0; K < 30; K++)
	{
	  int JS = IKS[IZZ - 1][K];
	  if (JS > 0)
	    {
	      NOS = NOS + 1;
	      if (NOS > NOM)
		{
		  ErrorFunction (1115);
		  return;
		}
	      FF[NOS - 1] = IFI[IZZ - 1][JS - 1] * STF[M][I];
	      UUI[NOS - 1] = EB[IZZ - 1][JS - 1];
	      FFJ0[NOS - 1] = CP0[IZZ - 1][JS - 1];
	      KKZ[NOS - 1] = IZZ;
	      if (IZZ > 2 && JS < 17)
		{
		  KKS[NOS - 1] = JS;
		}
	      else
		{
		  KKS[NOS - 1] = 30;
		}
	      FT = FT + FF[NOS - 1];
	    }
	}
    }

  if (fabs (FT - ZT[M]) > 1.0E-10 * ZT[M])
    {
      ErrorFunction (1116);
      return;
    }
  //  ****  Oscillators are sorted by increasing ionisation energies.
  for (int I = 0; I < NOS - 1; I++)
    {
      for (int J = I + 1; J < NOS; J++)
	{
	  if (UUI[I] >= UUI[J])
	    {
	      double SAVE = UUI[I];
	      UUI[I] = UUI[J];
	      UUI[J] = SAVE;
	      SAVE = FF[I];
	      FF[I] = FF[J];
	      FF[J] = SAVE;
	      SAVE = FFJ0[I];
	      FFJ0[I] = FFJ0[J];
	      FFJ0[J] = SAVE;
	      int ISAVE = KKZ[I];
	      KKZ[I] = KKZ[J];
	      KKZ[J] = ISAVE;
	      ISAVE = KKS[I];
	      KKS[I] = KKS[J];
	      KKS[J] = ISAVE;
	    }
	}
    }

  //  ************  Plasma energy and conduction band excitations.

  OP2[M] = FOURPI * ZT[M] * VMOL[M] * pow (A0B, 3) * pow (HREV, 2);
  double OMEGA = sqrt (OP2[M]);
  double EPP = OMEGA * sqrt (FF[0] / ZT[M]);
  printf
    ("\n  Estimated oscillator strength and energy of the plasmon:\n  Fcb = %12.5E,  Wcb = %12.5E, eV,\n  (for insulators, these quantities should be set equal to zero)\n",
     FF[0], EPP);

  printf
    ("\n  Do you wish to change the Fcb and Wcb values?   (1=yes,2=no)\n  (type 2 if you are not sure...)\n");
  int IPLOSP;
  int IFCB = 0;
  scanf ("%d", &IPLOSP);

  double FP, EP;
  if (IPLOSP == 1)
    {
      printf ("\n");
      printf
	(" Enter the oscillator strength Fcb and energy Wcb (in eV) of the plasmon ...\n");
      scanf ("%lf %lf", &FP, &EP);
      if (FP < 0.5)
	{
	  FP = 0.0;
	  EP = 0.0;
	}
      else if (EP < 0.1)
	{
	  EP = OMEGA * sqrt (FP / ZT[M]);
	}
    }
  else
    {
      EP = EPP;
      FP = FF[0];
    }
  printf ("\n  Fcb =%12.5E, Wcb =%12.5E, eV\n", FP, EP);
  if (FP > ZT[M] + 1.0E-13)
    {
      ErrorFunction (1117);
      return;
    }
  if (EP < 1.0 || FP < 0.5)
    {
      //  ****  Insulator. There is no conduction band.
      for (int J = 0; J < NOS - 1; J++)
	{
	  FF[J] = FF[J + 1];
	  UUI[J] = UUI[J + 1];
	  FFJ0[J] = FFJ0[J + 1];
	  KKZ[J] = KKZ[J + 1];
	  KKS[J] = KKS[J + 1];
	}
      NOS = NOS - 1;
    }
  else
    {
      //  ****  Conductor. Outer shells are 'moved' to the c.b.
      IFCB = 1;
      int IDEAD = 0;
      double FPP = FP;
      int I = 0;
      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  I = I + 1;
	  if (FF[I] < FPP)
	    {
	      FPP = FPP - FF[I];
	      FF[I] = 0.0;
	      IDEAD = IDEAD + 1;
	      Eixir = false;
	    }
	  else
	    {
	      FF[I] = FF[I] - FPP;
	      if (fabs (FF[I]) < 1.0E-12)
		{
		  FP = FP + FF[I];
		  FF[I] = 0.0;
		  IDEAD = IDEAD + 1;
		}
	    }
	}
      FF[0] = FP;
      UUI[0] = 0.0;
      WWRI[0] = EP;
      FFJ0[0] = 0.75 / sqrt (3.0 * PI * PI * VMOL[M] * pow (A0B, 3) * FP);
      KKZ[0] = 0;
      KKS[0] = 30;
      if (IDEAD > 0)
	{
	  for (int J = 1; J < NOS - IDEAD; J++)
	    {
	      FF[J] = FF[J + IDEAD];
	      UUI[J] = UUI[J + IDEAD];
	      FFJ0[J] = FFJ0[J + IDEAD];
	      KKZ[J] = KKZ[J + IDEAD];
	      KKS[J] = KKS[J + IDEAD];
	    }
	  NOS = NOS - IDEAD;
	}
    }
  //  ****  Check f-sum rule.
  double SUM = 0.0;
  double FACT;
  for (int J = 0; J < NOS; J++)
    {
      SUM = SUM + FF[J];
    }
  if (fabs (SUM - ZT[M]) > 1.0E-6 * ZT[M])
    {
      ErrorFunction (1118);
      return;
    }
  if (fabs (SUM - ZT[M]) > 1.0E-12 * ZT[M])
    {
      FACT = ZT[M] / SUM;
      for (int J = 0; J < NOS; J++)
	{
	  FF[J] = FACT * FF[J];
	}
    }

  //  ****  Initial parameters for Compton scattering (before grouping).

  int NOSTC = NOS;
  double CSUMT = 0.0;
  for (int I = 0; I < NOSTC; I++)
    {
      FC[I] = FF[I];
      UIC[I] = UUI[I];
      FJ0C[I] = FFJ0[I];
      KZC[I] = KKZ[I];
      KSC[I] = KKS[I];
      CSUMT = CSUMT + FC[I] * FJ0C[I];
    }

  //  ************  Sternheimer's adjustment factor.

  double TST, AAL, AAU, AA = 0.0;
  if (NOS > 1)
    {
      TST = ZT[M] * log (EXPOT[M]);
      AAL = 0.5;
      AAU = 10.0;
      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  AA = 0.5 * (AAL + AAU);
	  SUM = 0.0;
	  for (int I = 0; I < NOS; I++)
	    {
	      if (I == 0 && IFCB == 1)
		{
		  SUM = SUM + FF[0] * log (WWRI[0]);
		}
	      else
		{
		  double WI2 =
		    pow (AA * UUI[I],
			 2) +
		    0.666666666666666 * (FF[I] / ZT[M]) * pow (OMEGA, 2);
		  WWRI[I] = sqrt (WI2);
		  SUM = SUM + FF[I] * log (WWRI[I]);
		}
	    }
	  if (SUM < TST)
	    {
	      AAL = AA;
	    }
	  else
	    {
	      AAU = AA;
	    }
	  if (AAU - AAL > 1.0E-14 * AA)
	    {
	      Eixir = false;
	    }
	}
    }
  else
    {
      UUI[0] = fabs (UUI[0]);
      WWRI[0] = EXPOT[M];
    }

  printf ("\n  Sternheimer adjustment factor = %12.5E\n", AA);
  //  ****  Verification.
  double EXPT;
  EXPT = FF[0] * log (WWRI[0]);
  TST = FF[0];
  if (NOS > 1)
    {
      for (int I = 1; I < NOS; I++)
	{
	  EXPT = EXPT + FF[I] * log (WWRI[I]);
	  TST = TST + FF[I];
	}
    }

  if (fabs (TST - ZT[M]) > 1.0E-8 * ZT[M])
    {
      printf (" TST-ZT[M] = %12.5E\n", TST - ZT[M]);
      ErrorFunction (1119);
      return;
    }
  EXPT = exp (EXPT / ZT[M]);
  if (fabs (EXPT - EXPOT[M]) > 1.0E-8 * EXPOT[M])
    {
      printf ("EXPT-EXPOT(M) =%12.5E\n", EXPT - EXPOT[M]);
      printf ("Error in the calculation of the Sternheimer factor.\n");
      printf ("\n  Number of oscillators  = %3d\n", NOS);
      for (int I = 0; I < NOS; I++)
	{
	  printf ("%4d %13.5E %13.5E %13.5E %13.5E %4d %4d", I, FF[I], UUI[I],
		  WWRI[I], FFJ0[I], KKZ[I], KKS[I]);
	}
      ErrorFunction (1120);
      return;
    }

  //  ****  Selection of the lowest ionisation energy for inner shells.
  //  Only the K, L, M and N shells with ionisation energies greater than
  //  that of the N7 shell of the heaviest element in the material are
  //  considered as inner shells. As a result, the inner/outer character
  //  of an atomic shell depends on the composition of the material.

  int IZMAX = 0;
  for (int I = 0; I < NELEM[M]; I++)
    {
      if (IZMAX < IZ[M][I])
	{
	  IZMAX = IZ[M][I];
	}
    }
  int JBM = 0;
  for (int J = 0; J < 16; J++)
    {
      if (EB[IZMAX - 1][J] > 40.0)
	{
	  JBM = J;
	}
    }
  double WISCUT;
  if (50.0 > EB[IZMAX - 1][JBM] - 0.1)
    {
      WISCUT = 50.0;
    }
  else
    {
      WISCUT = EB[IZMAX - 1][JBM] - 0.1;
    }
  printf ("\n  Inner-shell lowest energy = %12.5E eV\n", WISCUT);

  int NOST;
  Eixir = false;
  while (!Eixir)
    {
      Eixir = true;
      NOST = NOS;
      for (int I = 0; I < NOST; I++)
	{
	  FFT[I] = FF[I];
	  UIT[I] = UUI[I];
	  WRIT[I] = WWRI[I];
	  KZT[I] = KKZ[I];
	  KST[I] = KKS[I];
	}
      //  ****  Oscillators are sorted by increasing resonance energies.
      if (NOST > IFCB + 1)
	{
	  for (int I = IFCB; I < NOST - 1; I++)
	    {
	      for (int J = I + 1; J < NOST; J++)
		{
		  if (WRIT[I] > WRIT[J])
		    {
		      double SAVE;
		      SAVE = FFT[I];
		      FFT[I] = FFT[J];
		      FFT[J] = SAVE;
		      SAVE = UIT[I];
		      UIT[I] = UIT[J];
		      UIT[J] = SAVE;
		      SAVE = WRIT[I];
		      WRIT[I] = WRIT[J];
		      WRIT[J] = SAVE;
		      int ISAVE = KZT[I];
		      KZT[I] = KZT[J];
		      KZT[J] = ISAVE;
		      ISAVE = KST[I];
		      KST[I] = KST[J];
		      KST[J] = ISAVE;
		    }
		}
	    }
	}

      //  ****  Oscillators of outer shells with resonance energies differing
      //  by a factor less than RGROUP are grouped as a single oscillator.

      RGROUP = 1.05;
      bool Eixir2 = false;
      while (!Eixir2)
	{
	  Eixir2 = true;
	  int NINSH = 0;
	  for (int J = 0; J < NOST; J++)
	    {
	      if (KST[J] < 17 && UIT[J] > WISCUT)
		{
		  NINSH = NINSH + 1;
		}
	    }
	  int IELIM = 0;
	  if (NOST > IFCB + 1)
	    {
	      for (int I = IFCB; I < NOST - 1; I++)
		{
		  // Keep K shells of low-Z atoms as inner shells.
		  if (KST[I] < 2 && KZT[I] > 3)
		    {
		      continue;
		    }
		  if (KST[I + 1] < 2 && KZT[I + 1] > 3)
		    {
		      continue;
		    }

		  if (KST[I] < 17 && UIT[I] > WISCUT)
		    {
		      continue;
		    }
		  if (KST[I + 1] < 17 && UIT[I + 1] > WISCUT)
		    {
		      continue;
		    }
		  if (WRIT[I] < 1.0 || WRIT[I + 1] < 1.0)
		    {
		      continue;
		    }
		  if (WRIT[I + 1] > RGROUP * WRIT[I])
		    {
		      continue;
		    }
		  WRIT[I] =
		    exp ((FFT[I] * log (WRIT[I]) +
			  FFT[I + 1] * log (WRIT[I + 1])) / (FFT[I] + FFT[I +
									  1]));
		  UIT[I] =
		    (FFT[I] * UIT[I] + FFT[I + 1] * UIT[I + 1]) / (FFT[I] +
								   FFT[I +
								       1]);
		  FFT[I] = FFT[I] + FFT[I + 1];
		  if (KZT[I] != KZT[I + 1])
		    {
		      KZT[I] = 0;
		    }
		  KST[I] = 30;
		  if (I + 1 < NOST - 1)
		    {
		      for (int J = I + 1; J < NOST - 1; J++)
			{
			  FFT[J] = FFT[J + 1];
			  UIT[J] = UIT[J + 1];
			  WRIT[J] = WRIT[J + 1];
			  KZT[J] = KZT[J + 1];
			  KST[J] = KST[J + 1];
			}
		    }
		  IELIM = IELIM + 1;
		  FFT[NOST - 1] = 0.0;
		  UIT[NOST - 1] = 0.0;
		  WRIT[NOST - 1] = 0.0;
		  KZT[NOST - 1] = 0;
		  KST[NOST - 1] = 0;
		}
	    }
	  if (IELIM > 0)
	    {
	      NOST = NOST - IELIM;
	      if (NOST > IFCB + NINSH + 1)
		{
		  Eixir2 = false;
		  continue;
		}
	    }
	  //  ****  E/P inelastic model parameters transferred to the final
	  //        arrays.
	  if (NOST < NO)
	    {
	      if (RGROUP < 1.25)
		{
		  RGROUP = pow (RGROUP, 2);
		  if (NOST > IFCB + NINSH + 5)
		    {
		      Eixir2 = false;
		      continue;
		    }
		}
	      NOSC[M] = NOST;
	      for (int I = 0; I < NOSC[M]; I++)
		{
		  F[M][I] = FFT[I];
		  UI[M][I] = UIT[I];
		  WRI[M][I] = WRIT[I];
		  if (UI[M][I] < 1.0E-3)
		    {
		      UI[M][I] = 0.0;
		    }
		  KZ[M][I] = KZT[I];
		  if (KST[I] < 2 && KZT[I] > 3)
		    {
		      KS[M][I] = KST[I];
		    }
		  else
		    {
		      if (UI[M][I] > WISCUT)
			{
			  KS[M][I] = KST[I];
			}
		      else
			{
			  KS[M][I] = 30;
			}
		    }
		}
	    }
	  else
	    {
	      RGROUP = pow (RGROUP, 2);
	      if (RGROUP > 2.0)
		{
		  WISCUT = 1.25 * WISCUT;
		  printf ("  Inner-shell lowest energy = %12.5E eV\n",
			  WISCUT);
		  Eixir = false;
		  break;
		}
	      Eixir2 = false;
	      continue;
	    }
	}
    }

  printf ("\n  E/P inel. grouping factor = %12.5E\n", RGROUP);

  //  ************  Compton (impulse approximation) parameters.

  //  ****  Shells are sorted by increasing ionisation energies.
  if (NOSTC > 1)
    {
      for (int I = 0; I < NOSTC - 1; I++)
	{
	  for (int J = I + 1; J < NOSTC; J++)
	    {
	      if (UIC[I] > UIC[J])
		{
		  double SAVE = FC[I];
		  FC[I] = FC[J];
		  FC[J] = SAVE;
		  SAVE = UIC[I];
		  UIC[I] = UIC[J];
		  UIC[J] = SAVE;
		  SAVE = FJ0C[I];
		  FJ0C[I] = FJ0C[J];
		  FJ0C[J] = SAVE;
		  int ISAVE = KZC[I];
		  KZC[I] = KZC[J];
		  KZC[J] = ISAVE;
		  ISAVE = KSC[I];
		  KSC[I] = KSC[J];
		  KSC[J] = ISAVE;
		}
	    }
	}
    }

  //  ****  Outer shells with ionisation energies differing by a factor
  //  less than RGROUP are grouped as a single shell.

  RGROUP = 1.05;
  Eixir = false;
  while (!Eixir)
    {
      Eixir = true;
      int NINSH = 0;
      for (int J = 0; J < NOST; J++)
	{
	  if (KSC[J] < 17 && UIC[J] > WISCUT)
	    {
	      NINSH = NINSH + 1;
	    }
	}
      int IELIM = 0;
      if (NOSTC > IFCB + 1)
	{
	  for (int I = IFCB; I < NOSTC - 1; I++)
	    {
	      // Keep K shells of low-Z atoms as inner shells.
	      if (KSC[I] < 2 && KZC[I] > 3)
		{
		  continue;
		}
	      if (KSC[I + 1] < 2 && KZC[I + 1] > 3)
		{
		  continue;
		}

	      if (KSC[I] < 17 && UIC[I] > WISCUT)
		{
		  continue;
		}
	      if (KSC[I + 1] < 17 && UIC[I + 1] > WISCUT)
		{
		  continue;
		}
	      if (UIC[I] < 1.0 || UIC[I + 1] < 1.0)
		{
		  continue;
		}
	      if (UIC[I + 1] > RGROUP * UIC[I])
		{
		  continue;
		}
	      UIC[I] =
		(FC[I] * UIC[I] + FC[I + 1] * UIC[I + 1]) / (FC[I] +
							     FC[I + 1]);
	      FJ0C[I] =
		(FC[I] * FJ0C[I] + FC[I + 1] * FJ0C[I + 1]) / (FC[I] +
							       FC[I + 1]);
	      FC[I] = FC[I] + FC[I + 1];
	      if (KZC[I] != KZC[I + 1])
		{
		  KZC[I] = 0;
		}
	      KSC[I] = 30;
	      if (I + 1 < NOSTC - 1)
		{
		  for (int J = I + 1; J < NOSTC - 1; J++)
		    {
		      FC[J] = FC[J + 1];
		      UIC[J] = UIC[J + 1];
		      FJ0C[J] = FJ0C[J + 1];
		      KZC[J] = KZC[J + 1];
		      KSC[J] = KSC[J + 1];
		    }
		}
	      IELIM = IELIM + 1;
	      FC[NOSTC - 1] = 0.0;
	      UIC[NOSTC - 1] = 0.0;
	      FJ0C[NOSTC - 1] = 0.0;
	      KZC[NOSTC - 1] = 0;
	      KSC[NOSTC - 1] = 0;
	    }
	}
      if (IELIM > 0)
	{
	  NOSTC = NOSTC - IELIM;
	  if (NOSTC > IFCB + NINSH + 1)
	    {
	      Eixir = false;
	      continue;
	    }
	}
      //  ****  Compton scattering model parameters transferred to the final
      //        arrays.
      if (NOSTC < NOCO)
	{
	  if (RGROUP < 1.25)
	    {
	      RGROUP = pow (RGROUP, 2);
	      if (NOSTC > IFCB + NINSH + 5)
		{
		  Eixir = false;
		  continue;
		}
	    }
	  NOSCCO[M] = NOSTC;
	  for (int I = 0; I < NOSCCO[M]; I++)
	    {
	      FCO[M][I] = FC[I];
	      UICO[M][I] = UIC[I];
	      FJ0[M][I] = FJ0C[I];
	      KZCO[M][I] = KZC[I];
	      if (KSC[I] < 2 && KZC[I] > 3)
		{
		  KSCO[M][I] = KSC[I];
		}
	      else if (UICO[M][I] > WISCUT)
		{
		  KSCO[M][I] = KSC[I];
		}
	      else
		{
		  KSCO[M][I] = 30;
		}
	      CSUMT = CSUMT - FCO[M][I] * FJ0[M][I];
	    }
	  if (fabs (CSUMT) > 1.0E-9)
	    {
	      printf ("  Residual sum = %12.5e\n", fabs (CSUMT));
	      ErrorFunction (1121);
	      return;
	    }
	}
      else
	{
	  RGROUP = pow (RGROUP, 2);
	  Eixir = false;
	  continue;
	}
    }
  printf ("    Compton grouping factor = %12.5E\n", RGROUP);

  //  ************  PENELOPE's input file.

  printf ("\n PENELOPE''s material data file is being created.\n");
  FILE *AuxFile;
  if (IFILE == 1)
    {
      AuxFile = fopen (MFNAME, "w");
    }
  else
    {
      printf (" Enter path+name for this file (up to 80 characters) ...\n");
      scanf ("%80s", PFILE);
      AuxFile = fopen (PFILE, "w");
    }
  fprintf (AuxFile,
	   " PENELOPE (v. 2018)  Material data file ...............\n");
  fprintf (AuxFile, " Material: %-62s\n", NAME);
  fprintf (AuxFile, " Mass density =%15.8E g/cm**3\n", RHO[M]);
  fprintf (AuxFile, " Number of elements in the molecule = %2d\n", NELEM[M]);
  for (int I = 0; I < NELEM[M]; I++)
    {
      fprintf (AuxFile, "   atomic number =%3d,  atoms/molecule =%15.8E\n",
	       IZ[M][I], STF[M][I]);
    }
  fprintf (AuxFile, " Mean excitation energy =%15.8E eV\n", EXPOT[M]);
  fprintf (AuxFile, " Number of oscillators =%3d (E/P inelastic model)\n",
	   NOSC[M]);
  for (int I = 0; I < NOSC[M]; I++)
    {
      fprintf (AuxFile, "%4d%16.8E%16.8E%16.8E%4d%4d\n", I + 1, F[M][I],
	       UI[M][I], WRI[M][I], KZ[M][I], KS[M][I]);
    }

  fprintf (AuxFile, " Number of shells =%3d (Compton IA model)\n", NOSCCO[M]);
  for (int I = 0; I < NOSCCO[M]; I++)
    {
      fprintf (AuxFile, "%4d%16.8E%16.8E%16.8E%4d%4d\n", I + 1, FCO[M][I],
	       UICO[M][I], FJ0[M][I], KZCO[M][I], KSCO[M][I]);
      FJ0[M][I] = FJ0[M][I] * SL;
    }

  //  ****  Atomic relaxation data.

  for (int I = 0; I < NELEM[M]; I++)
    {
      IZZ = IZ[M][I];
      RELAXW (IZZ, AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}
    }
  //  ****  Energy grid (standard).

  int NES = 0;
  int IGRID = 0;
  double FGRID = 1.0;
  Eixir = false;
  while (!Eixir)
    {
      Eixir = true;
      IGRID = IGRID + 1;
      double EV = EGRT[IGRID - 1] * FGRID;
      if (IGRID == 17)
	{
	  IGRID = 1;
	  FGRID = 10.0 * FGRID;
	}
      if (EV < 49.0)
	{
	  Eixir = false;
	  continue;
	}
      NES = NES + 1;
      ES[NES - 1] = EV;
      if (EV < 1.0E9)
	{
	  Eixir = false;
	  continue;
	}
    }
  EMIN = 50.0;
  double EMAX = 1.0E9;
  EGRID (EMIN, EMAX);

  double WCRM = 10.0;
  double WCCM = 0.0;

  //  **** Electron and positron inner-shell ionisation x-sections.

  ESIaW (M, AuxFile);
  if (IRETRN != 0)
    {
      return;
    }
  PSIaW (M, AuxFile);
  if (IRETRN != 0)
    {
      return;
    }

  //  ****  Bremsstrahlung emission,

  EBRaW (M, AuxFile);
  if (IRETRN != 0)
    {
      return;
    }
  double ZEQ = sqrt (ZBR2[M]);
  BRaAW (ZEQ, AuxFile);
  if (IRETRN != 0)
    {
      return;
    }

  fprintf (AuxFile,
	   " *** Stopping powers for electrons and positrons,  NDATA =%4d\n",
	   NES);
  fflush (AuxFile);
  double EE, ESTP, ERSTP, PSTP, PRSTP;
  double XH0, XH1, XH2, XS0, XS1, XS2, XT1, XT2, DELTA;
  for (int IE = 0; IE < NES; IE++)
    {
      EE = ES[IE];
      EINaT (EE, WCCM, XH0, XH1, XH2, XS0, XS1, XS2, XT1, XT2, DELTA, M + 1);
      ESTP = (XS1 + XH1) * VMOL[M] * 1.0E-6 / RHO[M];
      EBRaT (EE, WCRM, XH0, XH1, XH2, XS1, XS2, M + 1);
      if (IRETRN != 0)
	{
	  return;
	}
      ERSTP = (XS1 + XH1) * VMOL[M] * 1.0E-6 / RHO[M];
      PINaT (EE, WCCM, XH0, XH1, XH2, XS0, XS1, XS2, XT1, XT2, DELTA, M + 1);
      PSTP = (XS1 + XH1) * VMOL[M] * 1.0E-6 / RHO[M];
      PBRaT (EE, WCRM, XH0, XH1, XH2, XS1, XS2, M + 1);
      if (IRETRN != 0)
	{
	  return;
	}
      PRSTP = (XS1 + XH1) * VMOL[M] * 1.0E-6 / RHO[M];
      fprintf (AuxFile, "%10.3E%12.5E%12.5E%12.5E%12.5E\n", EE, ESTP, ERSTP,
	       PSTP, PRSTP);
    }

  //  **** Electron and positron elastic x-sections.
  EELaW (M, AuxFile);
  if (IRETRN != 0)
    {
      return;
    }
  EELdW (M, AuxFile);		// Uses the ELSEPA database.
  if (IRETRN != 0)
    {
      return;
    }

  //  ****  Photon x-sections.

  GRAaW (M, AuxFile);
  if (IRETRN != 0)
    {
      return;
    }

  int NPTAB;
  GPPaW (EIT, XGP0, XGT0, NPTAB, M);
  if (IRETRN != 0)
    {
      return;
    }
  for (int I = 0; I < NES; I++)
    {
      PPE[I] = 0.0;
    }
  int NESS;
  MERGE2 (ES, PPE, EIT, XGP0, ESS, PPT, NES, NPTAB, NESS);
  if (IRETRN != 0)
    {
      return;
    }
  for (int I = 0; I < NESS; I++)
    {
      XGP0[I] = PPT[I];
    }
  for (int I = 0; I < NES; I++)
    {
      PPE[I] = 0.0;
    }
  MERGE2 (ES, PPE, EIT, XGT0, ESS, PPT, NES, NPTAB, NESS);
  if (IRETRN != 0)
    {
      return;
    }
  for (int I = 0; I < NESS; I++)
    {
      XGT0[I] = PPT[I];
    }

  fprintf (AuxFile,
	   " *** Compton and pair-production cross sections,  NDATA =%4d\n",
	   NESS);
  for (int IE = 0; IE < NESS; IE++)
    {
      EE = ESS[IE];
      double CSC;
      GCOaT (EE, CSC, M);
      if (CSC < 1.0E-35)
	{
	  CSC = 0.0;
	}
      if (EE < TREV + 5.0)
	{
	  XGP0[IE] = 0.0;
	}
      if (EE < 2.0 * TREV + 10.0)
	{
	  XGT0[IE] = 0.0;
	}
      fprintf (AuxFile, "%10.3E%12.5E%12.5E%12.5E\n", EE, CSC, XGP0[IE],
	       XGT0[IE]);
    }

  GPHaW (M, AuxFile);
  if (IRETRN != 0)
    {
      return;
    }

  fprintf (AuxFile,
	   " PENELOPE (v. 2018)  End of material data file ........\n");
  fclose (AuxFile);
}


//  *********************************************************************
//                       SUBROUTINE EGRID
//  *********************************************************************
void EGRID (double EMINu, double EMAXu)
{

  //This subroutine sets the energy grid where transport functions are
  //tabulated. The grid is logarithmically spaced and we assume that it
  //is dense enough to permit accurate linear log-log interpolation of
  //he tabulated functions.

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace CEGRID;

  //  ****  Consistency of the interval end-points.

  if (EMINu < (double) MINEGRID)
    {
      EMINu = (double) MINEGRID;
    }
  if (EMINu > EMAXu - 1.0)	//Mirem si la distancia entre EMINu i EMAXu, es d'1 eV com a minim
    {
      printf ("   EMIN =%11.4E eV, EMAX =%11.4E eV\n", EMINu, EMAXu);
      ErrorFunction (1007);
      return;
    }

  //  ****  Energy grid points.

  EMIN = EMINu;
  EL = 0.99999 * EMINu;
  EU = 1.00001 * EMAXu;
  DLFC = log (EU / EL) / double (NEGP - 1);
  DLEMP1 = log (EL);
  DLEMP[0] = DLEMP1;
  ET[0] = EL;
  for (int I = 1; I < NEGP; I++)
    {
      DLEMP[I] = DLEMP[I - 1] + DLFC;
      ET[I] = exp (DLEMP[I]);
    }
  DLFC = (double) 1.0 / DLFC;

  //  NOTE: To determine the interval KE where the energy E is located, we
  //  do the following,
  //     XEL=LOG(E)
  //     XE=1.0D0+(XEL-DLEMP1)*DLFC
  //     KE=XE
  //     XEK=XE-KE  ! 'fractional' part of XE (used for interpolation).
  //
}

//  *********************************************************************
//                       FUNCTION RLMOM
//  *********************************************************************
double RLMOM (double *X, double *FCT, double XC, int NPpar, int MOM)
{
  //  Calculation of the integral of (X**MOM)*FCT(X) over the interval from
  //  X(1) to XC, obtained by linear interpolation on a table of FCT.
  //  The independent variable X is assumed to take only positive values.

  //    X ....... array of values of the variable (in increasing order).
  //    FCT ..... corresponding FCT values.
  //    NPpar ...... number of points in the table.
  //    XC ...... upper limit of the integral, X(1).LE.XC.LE.X(NP).
  //    MOM ..... moment order (GE.-1).
  //    RLMOM ... integral of (X**MOM)*FCT(X) over the interval from X(1)
  //              to XC.

  using namespace PENERROR_mod;

  const double EPS = 1.0E-35;

  double RLMOM_RETURN = 0.0;
  if (MOM < -1)
    {
      ErrorFunction (1319);
      return RLMOM_RETURN;
    }
  if (NPpar < 2)
    {
      ErrorFunction (1320);
      return RLMOM_RETURN;
    }
  if (X[0] < 0.0)
    {
      ErrorFunction (1321);
      return RLMOM_RETURN;
    }
  for (int I = 1; I < NPpar; I++)
    {
      if (X[I] < 0.0)
	{
	  ErrorFunction (1322);
	  return RLMOM_RETURN;
	}
      if (X[I] < X[I - 1])
	{
	  ErrorFunction (1323);
	  return RLMOM_RETURN;
	}
    }

  RLMOM_RETURN = 0.0;
  if (XC < X[0])
    {
      return RLMOM_RETURN;
    }
  int IEND = 0;

  double XT;
  if (XC < X[NPpar - 1])
    {
      XT = XC;
    }
  else
    {
      XT = X[NPpar - 1];
    }

  double X1, Y1, X2, Y2, XTC, DX, DY, A, B, DS;
  for (int I = 0; I < NPpar - 1; I++)
    {
      if (X[I] < EPS)
	{
	  X1 = EPS;
	}
      else
	{
	  X1 = X[I];
	}

      Y1 = FCT[I];

      if (X[I + 1] < EPS)
	{
	  X2 = EPS;
	}
      else
	{
	  X2 = X[I + 1];
	}

      Y2 = FCT[I + 1];
      if (XT < X2)
	{
	  XTC = XT;
	  IEND = 1;
	}
      else
	{
	  XTC = X2;
	}
      DX = X2 - X1;
      DY = Y2 - Y1;
      if (fabs (DX) > 1.0E-14 * fabs (DY))
	{
	  B = DY / DX;
	  A = Y1 - B * X1;
	  if (MOM == -1)
	    {
	      DS = A * log (XTC / X1) + B * (XTC - X1);
	    }
	  else
	    {
	      DS =
		A * (pow (XTC, (MOM + 1)) -
		     pow (X1, (MOM + 1))) / double (MOM + 1) + B * (pow (XTC,
									 (MOM
									  +
									  2))
								    - pow (X1,
									   (MOM
									    +
									    2)))
		/ double (MOM + 2);
	    }
	}
      else
	{
	  DS = 0.5 * (Y1 + Y2) * (XTC - X1) * pow (XTC, MOM);
	}
      RLMOM_RETURN = RLMOM_RETURN + DS;
      if (IEND != 0)
	{
	  return RLMOM_RETURN;
	}
    }
  return RLMOM_RETURN;
}

//  *********************************************************************
//                       SUBROUTINE SPLINE
//  *********************************************************************
void SPLINE (double *X, double *Y, double *A, double *B,
	     double *C, double *D, double S1, double SN, int N)
{
  //     Cubic spline interpolation of tabulated data.
  //
  //  Input:
  //     X(I) (I=1:N) ... grid points (the X values must be in increasing
  //                      order).
  //     Y(I) (I=1:N) ... corresponding function values.
  //     S1,SN .......... second derivatives at X(1) and X(N). The natural
  //                      spline corresponds to taking S1=SN=0.
  //     N .............. number of grid points.
  //  Output:
  //     A(I),B(I),C(I),D(I) (I=1:N) ... spline coefficients.
  //
  //  The interpolating cubic polynomial in the I-th interval, from X(I) to
  //  X(I+1), is
  //               P(x) = A(I)+x*(B(I)+x*(C(I)+x*D(I)))

  //  Reference: M.J. Maron, 'Numerical Analysis: a Practical Approach',
  //             MacMillan Publ. Co., New York, 1982.

  using namespace PENERROR_mod;

  if (N < 4)
    {
      printf
	(" *** Error in SPLINE: interpolation cannot be performed with %4d points.\n",
	 N);
      ErrorFunction (1904);
      return;
    }
  int N1 = N - 1;
  int N2 = N - 2;
  int K;
  //  ****  Auxiliary arrays H(=A) and DELTA(=D).
  for (int I = 0; I < N1; I++)
    {
      A[I] = X[I + 1] - X[I];
      if (A[I] <
	  1.0E-12 *
	  ((fabs (X[I]) > fabs (X[I + 1])) ? fabs (X[I]) : fabs (X[I + 1])))
	{
	  printf
	    (" *** Error in SPLINE: X values not in increasing order.\n");
	  ErrorFunction (1905);
	  return;
	}
      D[I] = (Y[I + 1] - Y[I]) / A[I];
    }
  //  ****  Symmetric coefficient matrix (augmented).
  for (int I = 0; I < N2; I++)
    {
      B[I] = 2.0 * (A[I] + A[I + 1]);
      K = N1 - (I + 1) + 1;
      D[K - 1] = 6.0 * (D[K - 1] - D[K - 2]);
    }
  D[1] = D[1] - A[0] * S1;
  D[N1 - 1] = D[N1 - 1] - A[N1 - 1] * SN;
  //  ****  Gauss solution of the tridiagonal system.
  for (int I = 1; I < N2; I++)
    {
      double R = A[I] / B[I - 1];
      B[I] = B[I] - R * A[I];
      D[I + 1] = D[I + 1] - R * D[I];
    }
  //  ****  The SIGMA coefficients are stored in array D.
  D[N1 - 1] = D[N1 - 1] / B[N2 - 1];
  for (int I = 1; I < N2; I++)
    {
      K = N1 - (I + 1) + 1;
      D[K - 1] = (D[K - 1] - A[K - 1] * D[K + 1 - 1]) / B[K - 2];
    }
  D[N - 1] = SN;
  //  ****  Spline coefficients.
  double SI1 = S1;
  for (int I = 0; I < N1; I++)
    {
      double SI = SI1;
      SI1 = D[I + 1];
      double H = A[I];
      double HI = 1.0 / H;
      A[I] =
	(HI / 6.0) * (SI * pow (X[I + 1], 3) - SI1 * pow (X[I], 3)) +
	HI * (Y[I] * X[I + 1] - Y[I + 1] * X[I]) + (H / 6.0) * (SI1 * X[I] -
								SI * X[I +
								       1]);
      B[I] =
	(HI / 2.0) * (SI1 * pow (X[I], 2) - SI * pow (X[I + 1], 2)) +
	HI * (Y[I + 1] - Y[I]) + (H / 6.0) * (SI - SI1);
      C[I] = (HI / 2.0) * (SI * X[I + 1] - SI1 * X[I]);
      D[I] = (HI / 6.0) * (SI1 - SI);
    }
  //  ****  Natural cubic spline for X.GT.X(N).
  double FNP =
    B[N1 - 1] + X[N - 1] * (2.0 * C[N1 - 1] + X[N - 1] * 3.0 * D[N1 - 1]);
  A[N - 1] = Y[N - 1] - X[N - 1] * FNP;
  B[N - 1] = FNP;
  C[N - 1] = 0.0;
  D[N - 1] = 0.0;

}

//  *********************************************************************
//                       SUBROUTINE FINDI
//  *********************************************************************
void FINDI (double *X, double XC, int N, int &I)
{
  //     This subroutine finds the interval (X(I),X(I+1)) that contains the
  //  value XC using binary search.

  //  Input:
  //     X(I) (I=1:N) ... grid points (the X values must be in increasing
  //                      order).
  //     XC ............. point to be located.
  //     N  ............. number of grid points.
  //  Output:
  //     I .............. interval index.

  if (XC > X[N - 1])
    {
      I = N;
      return;
    }
  if (XC < X[0])
    {
      I = 1;
      return;
    }
  I = 1;
  int I1 = N;
  bool Eixir = false;
  while (!Eixir)
    {
      Eixir = true;
      int IT = (I + I1) / 2;
      if (XC > X[IT - 1])
	{
	  I = IT;
	}
      else
	{
	  I1 = IT;
	}
      if (I1 - I > 1)
	{
	  Eixir = false;
	  continue;
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE ELINIT
//  *********************************************************************
void ELINIT (int *IZ, double *STF, int &NELEM)
{
  //  This subroutine reads atomic elastic cross sections for electrons and
  //  positrons from the database files and determines the molecular cross
  //  section as the incoherent sum of atomic cross sections.

  //  Input arguments:
  //    IZ (1:NELEM) .... atomic numbers of the elements in the compound.
  //    STF (1:NELEM) ... stoichiometric indexes.
  //    NELEM ........... number of different elements.
  //

  using namespace PENERROR_mod;
  using namespace CDCSEP;

  const int NE = 96;

  double EGRD[16] =
    { 1.0, 1.25, 1.50, 1.75, 2.00, 2.50, 3.00, 3.50, 4.00, 4.50, 5.00, 6.00,
7.00, 8.00, 9.00, 1.00E1 };

  char LIT10[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
  char LIT1[2], LIT2[2], LIT3[2];

  char FILE1[13];

  //  ****  Energy mesh points (in eV).

  int IE = 0;
  int IGRID = 10;
  double FGRID = 10.0;
  double EV;
  bool Eixir = false;
  while (!Eixir)
    {
      Eixir = true;
      IGRID = IGRID + 1;
      EV = EGRD[IGRID - 1] * FGRID;
      if (IGRID == 16)
	{
	  IGRID = 1;
	  FGRID = 10.0 * FGRID;
	}
      IE = IE + 1;
      ETS[IE - 1] = EV;
      ETL[IE - 1] = log (ETS[IE - 1]);
      if (IE < NE)
	{
	  Eixir = false;
	  continue;
	}
    }

  //  ****  Angular grid (TH in deg, XMU=(1.0D0-COS(TH))/2).

  int I = 1;
  TH[I - 1] = 0.0;
  THR[I - 1] = TH[I - 1] * PI / 180.0;
  XMU[I - 1] = (1.0 - cos (THR[I - 1])) / 2.0;
  XMUL[I - 1] = log (1.0E-35);
  I = 2;
  TH[I - 1] = 1.0E-4;
  THR[I - 1] = TH[I - 1] * PI / 180.0;
  XMU[I - 1] = (1.0 - cos (THR[I - 1])) / 2.0;

  if (XMU[I - 1] < 1.0E-35)
    {
      XMUL[I - 1] = log (1.0E-35);
    }
  else
    {
      XMUL[I - 1] = log (XMU[I - 1]);
    }

  Eixir = false;
  while (!Eixir)
    {
      Eixir = true;
      I = I + 1;
      if (TH[I - 1 - 1] < 0.9999E-3)
	{
	  TH[I - 1] = TH[I - 1 - 1] + 2.5E-5;
	}
      else if (TH[I - 1 - 1] < 0.9999E-2)
	{
	  TH[I - 1] = TH[I - 1 - 1] + 2.5E-4;
	}
      else if (TH[I - 1 - 1] < 0.9999E-1)
	{
	  TH[I - 1] = TH[I - 1 - 1] + 2.5E-3;
	}
      else if (TH[I - 1 - 1] < 0.9999)
	{
	  TH[I - 1] = TH[I - 1 - 1] + 2.5E-2;
	}
      else if (TH[I - 1 - 1] < 0.9999E+1)
	{
	  TH[I - 1] = TH[I - 1 - 1] + 1.0E-1;
	}
      else if (TH[I - 1 - 1] < 2.4999E+1)
	{
	  TH[I - 1] = TH[I - 1 - 1] + 2.5E-1;
	}
      else
	{
	  TH[I - 1] = TH[I - 1 - 1] + 5.0E-1;
	}
      THR[I - 1] = TH[I - 1] * PI / 180.0;

      XMU[I - 1] = (1.0 - cos (THR[I - 1])) / 2.0;
      if (XMU[I - 1] < 1.0E-35)
	{
	  XMU[I - 1] = 1.0E-35;
	}

      if (XMU[I - 1] < 1.0E-35)
	{
	  XMUL[I - 1] = log (1.0E-35);
	}
      else
	{
	  XMUL[I - 1] = log (XMU[I - 1]);
	}

      if (I < NA)
	{
	  Eixir = false;
	  continue;
	}
    }

  for (IE = 0; IE < NE; IE++)
    {
      ECS[IE] = 0.0;
      ETCS1[IE] = 0.0;
      ETCS2[IE] = 0.0;
      PCS[IE] = 0.0;
      PTCS1[IE] = 0.0;
      PTCS2[IE] = 0.0;
      for (int IA = 0; IA < NA; IA++)
	{
	  EDCS[IE][IA] = 0.0;
	  PDCS[IE][IA] = 0.0;
	}
    }

  //  ****  Read atomic DCS tables and compute the molecular DCS as the
  //        incoherent sum of atomic DCSs.

  for (int IEL = 0; IEL < NELEM; IEL++)
    {
      int IZZ = IZ[IEL];
      double STFF = STF[IEL];
      int NS = IZ[IEL];
      if (NS > 999)
	{
	  NS = 999;
	}
      int NS1 = NS - 10 * (NS / 10);
      NS = (NS - NS1) / 10;
      int NS2 = NS - 10 * (NS / 10);
      NS = (NS - NS2) / 10;
      int NS3 = NS - 10 * (NS / 10);
      LIT1[0] = LIT10[NS1 + 1 - 1];
      LIT1[1] = '\0';
      LIT2[0] = LIT10[NS2 + 1 - 1];
      LIT2[1] = '\0';
      LIT3[0] = LIT10[NS3 + 1 - 1];
      LIT3[1] = '\0';

      char straux[30];
      strcpy (straux, "./pdfiles/");
      strcpy (FILE1, "eeldx");
      strcat (FILE1, LIT3);
      strcat (FILE1, LIT2);
      strcat (FILE1, LIT1);
      strcat (FILE1, ".p08");
      strcat (straux, FILE1);
      FILE *eeldx = fopen (straux, "r");

      int IELEC, IZR;
      double ENR, CSE, TCS1E, TCS2E, CSP, TCS1P, TCS2P;
      for (IE = 0; IE < NE; IE++)
	{
	  fscanf (eeldx, "%d %d %lf %lf %lf %lf%*[^\n]", &IELEC, &IZR, &ENR,
		  &CSE, &TCS1E, &TCS2E);
	  getc (eeldx);
	  if (IELEC != -1 || IZR != IZZ || fabs (ENR - ETS[IE]) > 1.0E-3)
	    {
	      ErrorFunction (1355);
	      return;
	    }
	  for (int IA = 0; IA < NA; IA++)
	    {
	      fscanf (eeldx, "%lf", &DCSI[IA]);
	    }
	  fscanf (eeldx, "%*[^\n]");
	  getc (eeldx);
	  ECS[IE] = ECS[IE] + STFF * CSE;
	  ETCS1[IE] = ETCS1[IE] + STFF * TCS1E;
	  ETCS2[IE] = ETCS2[IE] + STFF * TCS2E;
	  for (int IA = 0; IA < NA; IA++)
	    {
	      EDCS[IE][IA] = EDCS[IE][IA] + STFF * DCSI[IA];
	    }
	}
      fclose (eeldx);

      strcpy (straux, "./pdfiles/");
      strcpy (FILE1, "peldx");
      strcat (FILE1, LIT3);
      strcat (FILE1, LIT2);
      strcat (FILE1, LIT1);
      strcat (FILE1, ".p08");
      strcat (straux, FILE1);
      FILE *peldx = fopen (straux, "r");
      for (IE = 0; IE < NE; IE++)
	{
	  fscanf (peldx, "%d %d %lf %lf %lf %lf%*[^\n]", &IELEC, &IZR, &ENR,
		  &CSP, &TCS1P, &TCS2P);
	  getc (peldx);
	  if (IELEC != +1 || IZR != IZZ || fabs (ENR - ETS[IE]) > 1.0E-3)
	    {
	      ErrorFunction (1356);
	      return;
	    }
	  for (int IA = 0; IA < NA; IA++)
	    {
	      fscanf (peldx, "%lf", &DCSI[IA]);
	    }
	  fscanf (peldx, "%*[^\n]");
	  getc (peldx);
	  PCS[IE] = PCS[IE] + STFF * CSP;
	  PTCS1[IE] = PTCS1[IE] + STFF * TCS1P;
	  PTCS2[IE] = PTCS2[IE] + STFF * TCS2P;
	  for (int IA = 0; IA < NA; IA++)
	    {
	      PDCS[IE][IA] = PDCS[IE][IA] + STFF * DCSI[IA];
	    }
	}
      fclose (peldx);
    }
}

//  *********************************************************************
//                       FUNCTION RMOMX
//  *********************************************************************
double RMOMX (double *X, double *PDF, double XD, double XU, int NPpar, int MOM)
{
  //  Calculation of momenta of a pdf, PDF(X), obtained from linear log-log
  //  interpolation of the input table. The independent variable X is
  //  assumed to take only positive values.

  //     X ........ array of variable values (in increasing order).
  //     PDF ...... corresponding PDF values (must be non-negative).
  //     NP ....... number of points in the table.
  //     XD, XU ... limits of the integration interval.
  //     MOM ...... moment order.
  //     RMOM = INTEGRAL (X**N)*PDF(X) dX over the interval (XD,XU).

  using namespace PENERROR_mod;

  const double EPS = 1.0E-12;
  const double ZERO = 1.0E-35;

  double RMOMX_RETURN = 0.0;	//Valor que torna la funcio

  if (NPpar < 2)
    {
      ErrorFunction (1908);
      return RMOMX_RETURN;
    }
  if (X[0] < 0.0 || PDF[0] < 0.0)
    {
      printf ("X(1),PDF(1) = %E %E\n", X[0], PDF[0]);
      ErrorFunction (1909);
      return RMOMX_RETURN;
    }
  for (int I = 1; I < NPpar; I++)
    {
      if (X[I] < 0.0 || PDF[I] < 0.0)
	{
	  printf ("I,X(I),PDF(I) = %d %E %E\n", I + 1, X[I], PDF[I]);
	  ErrorFunction (1910);
	  return RMOMX_RETURN;
	}
      if (X[I] < X[I - 1])
	{
	  ErrorFunction (1911);
	  return RMOMX_RETURN;
	}
    }

  double XLOW = (X[0] > XD ? X[0] : XD);
  if (XLOW < ZERO)
    {
      XLOW = ZERO;
    }
  double XUP = (X[NPpar - 1] < XU ? X[NPpar - 1] : XU);

  if (XLOW > XUP)
    {
      printf ("\n WARNING: XLOW is greater than XUP in RMOMX.");
      printf ("\n XLOW =%E,   XUP =%E", XLOW, XUP);
      RMOMX_RETURN = 0.0;
      return RMOMX_RETURN;
    }

  int IL = 1;
  int IU = NPpar - 1;
  for (int I = 0; I < NPpar - 1; I++)
    {
      if (X[I] < XLOW)
	{
	  IL = I + 1;
	}
      if (X[I] < XUP)
	{
	  IU = I + 1;
	}
    }

  //  ****  A single interval.

  double XIL, XFL, YIL, YFL, X1, X2, DENOM, Y1, Y2, DXL, DYL, DSUM, AP1;
  if (IU == IL)
    {
      XIL = log ((X[IL - 1] > ZERO ? X[IL - 1] : ZERO));
      XFL = log (X[IL + 1 - 1]);
      YIL = log ((PDF[IL - 1] > ZERO ? PDF[IL - 1] : ZERO));
      YFL = log ((PDF[IL + 1 - 1] > ZERO ? PDF[IL + 1 - 1] : ZERO));
      X1 = XLOW;
      X2 = XUP;
      DENOM = XFL - XIL;
      if (fabs (DENOM) > ZERO)
	{
	  Y1 =
	    exp (YIL + (YFL - YIL) * (log (X1) - XIL) / DENOM) * pow (X1,
								      MOM);
	  Y2 =
	    exp (YIL + (YFL - YIL) * (log (X2) - XIL) / DENOM) * pow (X2,
								      MOM);
	}
      else
	{
	  Y1 = exp (YIL) * pow (X1, MOM);
	  Y2 = exp (YIL) * pow (X2, MOM);
	}
      DXL = log (X2) - log (X1);
      DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
      if (fabs (DXL) > EPS * fabs (DYL))
	{
	  AP1 = 1.0 + (DYL / DXL);
	  if (fabs (AP1) > EPS)
	    {
	      DSUM = (Y2 * X2 - Y1 * X1) / AP1;
	    }
	  else
	    {
	      DSUM = Y1 * X1 * DXL;
	    }
	}
      else
	{
	  DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
	}
      RMOMX_RETURN = DSUM;
      return RMOMX_RETURN;
    }

  //  ****  Multiple intervals.

  XIL = log ((X[IL - 1] > ZERO ? X[IL - 1] : ZERO));
  XFL = log (X[IL + 1 - 1]);
  YIL = log ((PDF[IL - 1] > ZERO ? PDF[IL - 1] : ZERO));
  YFL = log ((PDF[IL + 1 - 1] > ZERO ? PDF[IL + 1 - 1] : ZERO));
  X1 = XLOW;
  DENOM = XFL - XIL;
  if (fabs (DENOM) > ZERO)
    {
      Y1 = exp (YIL + (YFL - YIL) * (log (X1) - XIL) / DENOM) * pow (X1, MOM);
    }
  else
    {
      Y1 = exp (YIL) * pow (X1, MOM);
    }
  X2 = X[IL + 1 - 1];
  Y2 = (PDF[IL + 1 - 1] > ZERO ? PDF[IL + 1 - 1] : ZERO) * pow (X2, MOM);
  DXL = log (X2) - log (X1);
  DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
  if (fabs (DXL) > EPS * fabs (DYL))
    {
      AP1 = 1.0 + (DYL / DXL);
      if (fabs (AP1) > EPS)
	{
	  DSUM = (Y2 * X2 - Y1 * X1) / AP1;
	}
      else
	{
	  DSUM = Y1 * X1 * DXL;
	}
    }
  else
    {
      DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
    }
  RMOMX_RETURN = DSUM;

  if (IU > IL + 1)
    {
      for (int I = IL; I < IU - 1; I++)
	{
	  X1 = X[I];
	  Y1 = (PDF[I] > ZERO ? PDF[I] : ZERO) * pow (X1, MOM);
	  X2 = X[I + 1];
	  Y2 = (PDF[I + 1] > ZERO ? PDF[I + 1] : ZERO) * pow (X2, MOM);
	  DXL = log (X2) - log (X1);
	  DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
	  if (fabs (DXL) > EPS * fabs (DYL))
	    {
	      AP1 = 1.0 + (DYL / DXL);
	      if (fabs (AP1) > EPS)
		{
		  DSUM = (Y2 * X2 - Y1 * X1) / AP1;
		}
	      else
		{
		  DSUM = Y1 * X1 * DXL;
		}
	    }
	  else
	    {
	      DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
	    }
	  RMOMX_RETURN = RMOMX_RETURN + DSUM;
	}
    }

  X1 = X[IU - 1];
  Y1 = (PDF[IU - 1] > ZERO ? PDF[IU - 1] : ZERO) * pow (X1, MOM);
  XIL = log (X[IU - 1]);
  XFL = log (X[IU + 1 - 1]);
  YIL = log ((PDF[IU - 1] > ZERO ? PDF[IU - 1] : ZERO));
  YFL = log ((PDF[IU + 1 - 1] > ZERO ? PDF[IU + 1 - 1] : ZERO));
  X2 = XUP;
  DENOM = XFL - XIL;
  if (fabs (DENOM) > ZERO)
    {
      Y2 = exp (YIL + (YFL - YIL) * (log (X2) - XIL) / DENOM) * pow (X2, MOM);
    }
  else
    {
      Y2 = exp (YIL) * pow (X2, MOM);
    }
  DXL = log (X2) - log (X1);
  DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
  if (fabs (DXL) > EPS * fabs (DYL))
    {
      AP1 = 1.0 + (DYL / DXL);
      if (fabs (AP1) > EPS)
	{
	  DSUM = (Y2 * X2 - Y1 * X1) / AP1;
	}
      else
	{
	  DSUM = Y1 * X1 * DXL;
	}
    }
  else
    {
      DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
    }
  RMOMX_RETURN = RMOMX_RETURN + DSUM;

  return RMOMX_RETURN;
}

//  *********************************************************************
//                       SUBROUTINE EINaT
//  *********************************************************************
void EINaT (double &E, double &WCCM, double &XH0, double &XH1, double &XH2,
	    double &XS0, double &XS1, double &XS2, double &XT1, double &XT2,
	    double &DELTA, int M)
{
  //  Integrated cross sections for inelastic collisions of electrons of
  //  energy E in material M, restricted to energy losses larger than and
  //  less than the cutoff energy WCCM.
  //
  //  Sternheimer-Liljequist GOS model.
  //
  //  Output arguments:
  //    XH0 ... total cross section for hard colls. (cm**2).
  //    XH1 ... stopping cross section for hard colls. (eV*cm**2).
  //    XH2 ... straggling cross section for hard colls. (eV**2*cm**2).
  //    XS0 ... total cross section for soft colls. (cm**2).
  //    XS1 ... stopping cross section for soft colls. (eV*cm**2)
  //    XS2 ... straggling cross section for soft colls. (eV**2*cm**2).
  //    XT1 ... 1st transport cross section for soft colls. (cm**2).
  //    XT2 ... 2nd transport cross section for soft colls. (cm**2).
  //    DELTA ... Fermi's density effect correction.

  using namespace PENELOPE_mod;

  using namespace COMPOS;
  using namespace CEIN;
  using namespace CEIN00;

  //  ****  Constants.

  const double GAM = 1.0 + E / REV;
  const double GAM2 = GAM * GAM;

  //  ************  Density effect.

  //  ****  Sternheimer's resonance energy (WL2=L**2).
  double TST = ZT[M - 1] / (GAM2 * OP2[M - 1]);
  double WL2 = 0.0;
  double WL2U, WL2L;
  double FDEL = 0.0;
  bool Eixir = false;
  for (int I = 0; I < NOSC[M - 1]; I++)
    {
      FDEL = FDEL + F[M - 1][I] / (pow (WRI[M - 1][I], 2) + WL2);
    }
  if (FDEL < TST)
    {
      DELTA = 0.0;
    }
  else
    {
      WL2 = pow (WRI[M - 1][NOSC[M - 1] - 1], 2);
      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  WL2 = WL2 + WL2;
	  FDEL = 0.0;
	  for (int I = 0; I < NOSC[M - 1]; I++)
	    {
	      FDEL = FDEL + F[M - 1][I] / (pow (WRI[M - 1][I], 2) + WL2);
	    }
	  if (FDEL > TST)
	    {
	      Eixir = false;
	      continue;
	    }
	}
      WL2L = 0.0;
      WL2U = WL2;
      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  WL2 = 0.5 * (WL2L + WL2U);
	  FDEL = 0.0;
	  for (int I = 0; I < NOSC[M - 1]; I++)
	    {
	      FDEL = FDEL + F[M - 1][I] / (pow (WRI[M - 1][I], 2) + WL2);
	    }
	  if (FDEL > TST)
	    {
	      WL2L = WL2;
	    }
	  else
	    {
	      WL2U = WL2;
	    }
	  if (WL2U - WL2L > 1.0E-12 * WL2)
	    {
	      Eixir = false;
	      continue;
	    }
	}
      //  ****  Density effect correction (delta).
      DELTA = 0.0;
      for (int I = 0; I < NOSC[M - 1]; I++)
	{
	  DELTA =
	    DELTA + F[M - 1][I] * log (1.0 + WL2 / pow (WRI[M - 1][I], 2));
	}
      DELTA = (DELTA / ZT[M - 1]) - WL2 / (GAM2 * OP2[M - 1]);
    }

  //  ****  Shell-oscillator cross sections.

  for (int I = 0; I < NOSC[M - 1]; I++)
    {
      SEH0[I] = 0.0;
      SEH1[I] = 0.0;
      SEH2[I] = 0.0;
      SES0[I] = 0.0;
      SES1[I] = 0.0;
      SES2[I] = 0.0;
      SET0[I] = 0.0;
      SET1[I] = 0.0;
      SET2[I] = 0.0;
    }
  XH0 = 0.0;
  XH1 = 0.0;
  XH2 = 0.0;
  XS0 = 0.0;
  XS1 = 0.0;
  XS2 = 0.0;
  double XT0 = 0.0;
  XT1 = 0.0;
  XT2 = 0.0;

  double UK, WK;
  double H0, H1, H2, S0, S1, S2, R0, R1, R2;
  for (int K = 0; K < NOSC[M - 1]; K++)
    {
      UK = UI[M - 1][K];
      WK = WRI[M - 1][K];
      EINaT1 (E, UK, WK, DELTA, WCCM, H0, H1, H2, S0, S1, S2, R0, R1, R2);
      SEH0[K] = F[M - 1][K] * H0;
      SEH1[K] = F[M - 1][K] * H1;
      SEH2[K] = F[M - 1][K] * H2;
      SES0[K] = F[M - 1][K] * S0;
      SES1[K] = F[M - 1][K] * S1;
      SES2[K] = F[M - 1][K] * S2;
      SET0[K] = F[M - 1][K] * R0;
      SET1[K] = F[M - 1][K] * 2.0 * R1;
      SET2[K] = F[M - 1][K] * 6.0 * (R1 - R2);
      XH0 = XH0 + SEH0[K];
      XH1 = XH1 + SEH1[K];
      XH2 = XH2 + SEH2[K];
      XS0 = XS0 + SES0[K];
      XS1 = XS1 + SES1[K];
      XS2 = XS2 + SES2[K];
      XT0 = XT0 + SET0[K];
      XT1 = XT1 + SET1[K];
      XT2 = XT2 + SET2[K];
    }

}

//  *********************************************************************
//                       SUBROUTINE EBRaT
//  *********************************************************************
void EBRaT (double &E, double &WCRM, double &XH0, double &XH1, double &XH2,
	    double &XS1, double &XS2, int M)
{
  //  Integrated cross sections for bremss emission by electrons of energy
  //  E in material M, restricted to energy losses larger than and less
  //  than the cutoff energy WCRM.

  //  Output arguments:
  //    XH0 ... total cross section for hard emission (cm**2).
  //    XH1 ... stopping cross section for hard emission (eV*cm**2).
  //    XH2 ... straggling cross section for hard emission (eV**2*cm**2).
  //    XS1 ... stopping cross section for soft emission (eV*cm**2).
  //    XS2 ... straggling cross section for soft emission (eV**2*cm**2).

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace CEGRID;
  using namespace CEBR;
  using namespace CEBR01;
  using namespace CEBR02;

  const double TREV = 2.0 * REV;

  XEL = log (E);
  if (XEL < DLEMP1)
    {
      XEL = DLEMP1;
    }

  XE = 1.0 + (XEL - DLEMP1) * DLFC;
  KE = (int) XE;
  XEK = XE - (double) KE;
  //  ****  Global x-section factor.
  double FACT = ZBR2[M - 1] * (pow (E + REV, 2) / (E * (E + TREV))) * 1.0E-27;

  //  ****  Moments of the scaled bremss x-section.

  double WCRE = WCRM / E;
  for (int IW = 0; IW < NBW; IW++)
    {
      X[IW] = WB[IW];
      Y[IW] = P0[M - 1][KE - 1][IW];
    }
  double XH0A =
    RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
  if (IRETRN != 0)
    {
      return;
    }
  double XS1A = RLMOM (X, Y, WCRE, NBW, 0);
  if (IRETRN != 0)
    {
      return;
    }
  double XS2A = RLMOM (X, Y, WCRE, NBW, 1);
  if (IRETRN != 0)
    {
      return;
    }
  double XH1A = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1A;
  if (IRETRN != 0)
    {
      return;
    }
  double XH2A = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2A;
  if (IRETRN != 0)
    {
      return;
    }
  for (int IW = 0; IW < NBW; IW++)
    {
      if (KE + 1 < NEGP)
	{
	  Y[IW] = P0[M - 1][KE + 1 - 1][IW];
	}
      else
	{
	  Y[IW] = P0[M - 1][NEGP - 1][IW];
	}
    }
  double XH0B =
    RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
  if (IRETRN != 0)
    {
      return;
    }
  double XS1B = RLMOM (X, Y, WCRE, NBW, 0);
  if (IRETRN != 0)
    {
      return;
    }
  double XS2B = RLMOM (X, Y, WCRE, NBW, 1);
  if (IRETRN != 0)
    {
      return;
    }
  double XH1B = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1B;
  if (IRETRN != 0)
    {
      return;
    }
  double XH2B = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2B;
  if (IRETRN != 0)
    {
      return;
    }

  XH0 = ((1.0 - XEK) * XH0A + XEK * XH0B) * FACT;
  XS1 = ((1.0 - XEK) * XS1A + XEK * XS1B) * FACT * E;
  XH1 = ((1.0 - XEK) * XH1A + XEK * XH1B) * FACT * E;
  XS2 = ((1.0 - XEK) * XS2A + XEK * XS2B) * FACT * E * E;
  XH2 = ((1.0 - XEK) * XH2A + XEK * XH2B) * FACT * E * E;
}

//  *********************************************************************
//                       SUBROUTINE PINaT
//  *********************************************************************
void PINaT (double &E, double &WCCM, double &XH0, double &XH1, double &XH2,
	    double &XS0, double &XS1, double &XS2, double &XT1, double &XT2,
	    double &DELTA, int M)
{
  //  Integrated cross sections for inelastic collisions of positrons of
  //  energy E in material M, restricted to energy losses larger than and
  //  less than the cutoff energy WCCM.
  //
  //  Sternheimer-Liljequist GOS model.
  //
  //  Output arguments:
  //    XH0 ... total cross section for hard colls. (cm**2).
  //    XH1 ... stopping cross section for hard colls. (eV*cm**2).
  //    XH2 ... straggling cross section for hard colls. (eV**2*cm**2).
  //    XS0 ... total cross section for soft colls. (cm**2).
  //    XS1 ... stopping cross section for soft colls. (eV*cm**2)
  //    XS2 ... straggling cross section for soft colls. (eV**2*cm**2).
  //    XT1 ... 1st transport cross section for soft colls. (cm**2).
  //    XT2 ... 2nd transport cross section for soft colls. (cm**2).
  //    DELTA ... Fermi's density effect correction.

  using namespace PENELOPE_mod;

  using namespace COMPOS;
  using namespace CEIN;
  using namespace CPIN00;

  //  ****  Constants.

  const double GAM = 1.0 + E / REV;
  const double GAM2 = GAM * GAM;

  //  ************  Density effect.

  //  ****  Sternheimer's resonance energy (WL2=L**2).
  bool Eixir = false;
  double TST, WL2, FDEL, WL2L, WL2U;
  TST = ZT[M - 1] / (GAM2 * OP2[M - 1]);
  WL2 = 0.0;
  FDEL = 0.0;
  for (int I = 0; I < NOSC[M - 1]; I++)
    {
      FDEL = FDEL + F[M - 1][I] / (pow (WRI[M - 1][I], 2) + WL2);
    }
  if (FDEL < TST)
    {
      DELTA = 0.0;
    }
  else
    {
      WL2 = pow (WRI[M - 1][NOSC[M - 1] - 1], 2);
      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  WL2 = WL2 + WL2;
	  FDEL = 0.0;
	  for (int I = 0; I < NOSC[M - 1]; I++)
	    {
	      FDEL = FDEL + F[M - 1][I] / (pow (WRI[M - 1][I], 2) + WL2);
	    }
	  if (FDEL > TST)
	    {
	      Eixir = false;
	      continue;
	    }
	}
      WL2L = 0.0;
      WL2U = WL2;
      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  WL2 = 0.5 * (WL2L + WL2U);
	  FDEL = 0.0;
	  for (int I = 0; I < NOSC[M - 1]; I++)
	    {
	      FDEL = FDEL + F[M - 1][I] / (pow (WRI[M - 1][I], 2) + WL2);
	    }
	  if (FDEL > TST)
	    {
	      WL2L = WL2;
	    }
	  else
	    {
	      WL2U = WL2;
	    }
	  if (WL2U - WL2L > 1.0E-12 * WL2)
	    {
	      Eixir = false;
	      continue;
	    }
	}
      //  ****  Density effect correction (delta).
      DELTA = 0.0;
      for (int I = 0; I < NOSC[M - 1]; I++)
	{
	  DELTA =
	    DELTA + F[M - 1][I] * log (1.0 + WL2 / pow (WRI[M - 1][I], 2));
	}
      DELTA = (DELTA / ZT[M - 1]) - WL2 / (GAM2 * OP2[M - 1]);
    }

  //  ****  Shell-oscillator cross sections.

  for (int I = 0; I < NOSC[M - 1]; I++)
    {
      SPH0[I] = 0.0;
      SPH1[I] = 0.0;
      SPH2[I] = 0.0;
      SPS0[I] = 0.0;
      SPS1[I] = 0.0;
      SPS2[I] = 0.0;
      SPT0[I] = 0.0;
      SPT1[I] = 0.0;
      SPT2[I] = 0.0;
    }
  XH0 = 0.0;
  XH1 = 0.0;
  XH2 = 0.0;
  XS0 = 0.0;
  XS1 = 0.0;
  XS2 = 0.0;
  double XT0 = 0.0;
  XT1 = 0.0;
  XT2 = 0.0;

  double UK, WK, H0, H1, H2, S0, S1, S2, R0, R1, R2;
  for (int K = 0; K < NOSC[M - 1]; K++)
    {
      UK = UI[M - 1][K];
      WK = WRI[M - 1][K];
      PINaT1 (E, UK, WK, DELTA, WCCM, H0, H1, H2, S0, S1, S2, R0, R1, R2);
      SPH0[K] = F[M - 1][K] * H0;
      SPH1[K] = F[M - 1][K] * H1;
      SPH2[K] = F[M - 1][K] * H2;
      SPS0[K] = F[M - 1][K] * S0;
      SPS1[K] = F[M - 1][K] * S1;
      SPS2[K] = F[M - 1][K] * S2;
      SPT0[K] = F[M - 1][K] * R0;
      SPT1[K] = F[M - 1][K] * 2.0 * R1;
      SPT2[K] = F[M - 1][K] * 6.0 * (R1 - R2);
      XH0 = XH0 + SPH0[K];
      XH1 = XH1 + SPH1[K];
      XH2 = XH2 + SPH2[K];
      XS0 = XS0 + SPS0[K];
      XS1 = XS1 + SPS1[K];
      XS2 = XS2 + SPS2[K];
      XT0 = XT0 + SPT0[K];
      XT1 = XT1 + SPT1[K];
      XT2 = XT2 + SPT2[K];
    }

}

//  *********************************************************************
//                       SUBROUTINE PBRaT
//  *********************************************************************
void PBRaT (double &E, double &WCRM, double &XH0, double &XH1, double &XH2,
	    double &XS1, double &XS2, int M)
{
  //  Integrated cross sections for bremss emission by positrons of energy
  //  E in material M, restricted to energy losses larger than and less
  //  than the cutoff energy WCRM.

  //  Output arguments:
  //    XH0 ... total cross section for hard emission (cm**2).
  //    XH1 ... stopping cross section for hard emission (eV*cm**2).
  //    XH2 ... straggling cross section for hard emission (eV**2*cm**2).
  //    XS1 ... stopping cross section for soft emission (eV*cm**2).
  //    XS2 ... straggling cross section for soft emission (eV**2*cm**2).

  using namespace PENELOPE_mod;
  using namespace PENERROR_mod;

  using namespace CEGRID;
  using namespace CEBR;
  using namespace CEBR01;
  using namespace CEBR02;

  const double TREV = 2.0 * REV;

  XEL = log (E);
  if (XEL < DLEMP1)
    {
      XEL = DLEMP1;
    }

  XE = 1.0 + (XEL - DLEMP1) * DLFC;
  KE = (int) XE;
  XEK = XE - (double) KE;
  //  ****  Global x-section factor.
  double FACT = ZBR2[M - 1] * (pow (E + REV, 2) / (E * (E + TREV))) * 1.0E-27;
  //  ****  Positron correction factor.
  double T = log (1.0 + 1.0E6 * E / (REV * ZBR2[M - 1]));
  double FPOS =
    1.0 -
    exp (-T *
	 (1.2359E-1 -
	  T * (6.1274E-2 -
	       T * (3.1516E-2 -
		    T * (7.7446E-3 -
			 T * (1.0595E-3 -
			      T * (7.0568E-5 - T * 1.8080E-6)))))));
  FACT = FACT * FPOS;

  //  ****  Moments of the scaled bremss x-section.

  double WCRE = WCRM / E;
  for (int IW = 0; IW < NBW; IW++)
    {
      X[IW] = WB[IW];
      Y[IW] = P0[M - 1][KE - 1][IW];
    }
  double XH0A =
    RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
  if (IRETRN != 0)
    {
      return;
    }
  double XS1A = RLMOM (X, Y, WCRE, NBW, 0);
  if (IRETRN != 0)
    {
      return;
    }
  double XS2A = RLMOM (X, Y, WCRE, NBW, 1);
  if (IRETRN != 0)
    {
      return;
    }
  double XH1A = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1A;
  if (IRETRN != 0)
    {
      return;
    }
  double XH2A = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2A;
  if (IRETRN != 0)
    {
      return;
    }
  for (int IW = 0; IW < NBW; IW++)
    {
      if (KE + 1 < NEGP)
	{
	  Y[IW] = P0[M - 1][KE + 1 - 1][IW];
	}
      else
	{
	  Y[IW] = P0[M - 1][NEGP - 1][IW];
	}
    }
  double XH0B =
    RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
  if (IRETRN != 0)
    {
      return;
    }
  double XS1B = RLMOM (X, Y, WCRE, NBW, 0);
  if (IRETRN != 0)
    {
      return;
    }
  double XS2B = RLMOM (X, Y, WCRE, NBW, 1);
  if (IRETRN != 0)
    {
      return;
    }
  double XH1B = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1B;
  if (IRETRN != 0)
    {
      return;
    }
  double XH2B = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2B;
  if (IRETRN != 0)
    {
      return;
    }

  XH0 = ((1.0 - XEK) * XH0A + XEK * XH0B) * FACT;
  XS1 = ((1.0 - XEK) * XS1A + XEK * XS1B) * FACT * E;
  XH1 = ((1.0 - XEK) * XH1A + XEK * XH1B) * FACT * E;
  XS2 = ((1.0 - XEK) * XS2A + XEK * XS2B) * FACT * E * E;
  XH2 = ((1.0 - XEK) * XH2A + XEK * XH2B) * FACT * E * E;
}
//  *********************************************************************
//                       SUBROUTINE MERGE2
//  *********************************************************************
void MERGE2 (double *X1, double *Y1, double *X2, double *Y2, double *XM,
	     double *YM, int &N1, int &N2, int &N)
{
  //  This subroutine merges two tables (X1,Y1), (X2,Y2) of two functions
  //  to produce a table (XM,YM) of the sum of these functions, with abs-
  //  cissas in increasing order. The abscissas and function values are
  //  assumed to be positive. N1, N2 and N are the numbers of grid points
  //  in the input and merged tables. A discontinuity in the function is
  //  described by giving twice the abscissa. Log-log linear interpolation
  //  is used to interpolate the input tables.

  using namespace PENERROR_mod;

  const double EPS = 1.0E-10;
  const int NP_S = 12000;
  const int NP2_S = NP_S + NP_S;
  double X[NP2_S], Y12[NP2_S];

  if (N1 > NP_S || N2 > NP_S)
    {
      printf ("NP =%7d\n", N1 > N2 ? N1 : N2);
      ErrorFunction (1901);
      return;
    }

  SORT2 (X1, Y1, N1);
  if (IRETRN != 0)
    {
      return;
    }
  SORT2 (X2, Y2, N2);
  if (IRETRN != 0)
    {
      return;
    }

  for (int I1 = 0; I1 < N1; I1++)
    {
      X[I1] = X1[I1];
    }
  double XC, TST1, TST2, TST3, TST4, TST12, TST34, TST;
  N = N1;
  for (int I2 = 0; I2 < N2; I2++)
    {
      int I1;
      XC = X2[I2];
      FINDI (X1, XC, N1, I1);
      if (I1 == N1)
	{
	  I1 = N1 - 1;
	}
      TST1 = fabs (XC - X1[I1 - 1]);
      TST2 = fabs (XC - X1[I1 + 1 - 1]);
      TST12 = (TST1 < TST2 ? TST1 : TST2);
      if (I2 + 1 > 1)
	{
	  TST3 = fabs (XC - X2[I2 - 1]);
	}
      else
	{
	  TST3 = 1.0;
	}
      if (I2 + 1 < N2)
	{
	  TST4 = fabs (XC - X2[I2 + 1]);
	}
      else
	{
	  TST4 = 1.0;
	}
      TST34 = (TST3 < TST4 ? TST3 : TST4);
      TST = EPS * XC;
      if (TST34 > TST)
	{
	  if (TST12 > TST)
	    {
	      N = N + 1;
	      X[N - 1] = XC;
	    }
	}
      else
	{
	  N = N + 1;
	  X[N - 1] = XC;
	}
    }

  //  ****  Sort and clean the merged grid.

  bool Eixir = false;
  while (!Eixir)
    {
      Eixir = true;
      for (int I = 0; I < N - 1; I++)
	{
	  int IMIN = I + 1;
	  double XMIN = X[I];
	  for (int J = I + 1; J < N; J++)
	    {
	      if (X[J] < XMIN)
		{
		  IMIN = J + 1;
		  XMIN = X[J];
		}
	    }
	  double SAVE = X[I];
	  X[I] = X[IMIN - 1];
	  X[IMIN - 1] = SAVE;
	}

      for (int I = 0; I < N - 2; I++)
	{
	  if (X[I] > X[I + 2] * (1.0E0 - EPS))
	    {
	      X[I + 1] = X[N - 1];
	      N = N - 1;
	      Eixir = false;
	      break;
	    }
	}
    }

  for (int I = 0; I < N; I++)
    {
      XC = X[I];
      if (I + 1 < N)
	{
	  if (X[I] > X[I + 1] * (1.0 - EPS))
	    {
	      XC = X[I] * (1.0 - EPS);
	    }
	}
      if (I + 1 > 1)
	{
	  if (X[I] < X[I - 1] * (1.0 + EPS))
	    {
	      XC = X[I] * (1.0 + EPS);
	    }
	}
      int J;
      double YI1, YI2;
      FINDI (X1, XC, N1, J);
      if (J == N1)
	{
	  J = N1 - 1;
	}
      if (X1[J + 1 - 1] > X1[J - 1] + EPS)
	{
	  YI1 =
	    exp (log (Y1[J - 1]) +
		 log (XC / X1[J - 1]) * log (Y1[J + 1 - 1] / Y1[J - 1]) /
		 log (X1[J + 1 - 1] / X1[J - 1]));
	}
      else
	{
	  YI1 = Y1[J - 1];
	}
      FINDI (X2, XC, N2, J);
      if (J == N2)
	{
	  J = N2 - 1;
	}
      if (X2[J + 1 - 1] > X2[J - 1] + EPS)
	{
	  YI2 =
	    exp (log (Y2[J - 1]) +
		 log (XC / X2[J - 1]) * log (Y2[J + 1 - 1] / Y2[J - 1]) /
		 log (X2[J + 1 - 1] / X2[J - 1]));
	}
      else
	{
	  YI2 = Y2[J - 1];
	}
      Y12[I] = YI1 + YI2;
      if (Y12[I] < 1.0E-75)
	{
	  Y12[I] = 1.0E-75;
	}
    }

  if (N > NP_S)
    {
      printf ("NP = %7d\n", N);
      ErrorFunction (1902);
      return;
    }
  for (int I = 0; I < N; I++)
    {
      XM[I] = X[I];
      YM[I] = Y12[I];
    }
}

//  *********************************************************************
//                       SUBROUTINE GCOaT
//  *********************************************************************
void GCOaT (double &E, double &CS, int &M)
{
  //  Total cross section for incoherent (Compton) scattering. Relativistic
  //  Impulse approximation with analytical Compton profiles.

  //  Input arguments:
  //    E ........ photon energy (eV).
  //    M ........ material where photons propagate.
  //  Output argument:
  //    CS ....... incoherent total cross section (cm**2/molecule).

  using namespace PENELOPE_mod;

  using namespace CGCO;
  using namespace CGCO00;

  double GCOaD (double);

  const double RREV = 1.0 / REV;
  const double PIELR2 = PI * ELRAD * ELRAD;

  double SXCO[NOCO];

  EE = E;
  MM = M;

  double EK, EKS, EK2, EK1, T0, CSL, TAU, CSKN, CSU;
  CS = 0.0;
  if (E < 5.0E6)
    {
      for (int IO = 0; IO < NOSCCO[M]; IO++)
	{
	  IOSC = IO + 1;
	  SXCO[IO] = FCO[M][IO] * PIELR2 * SUMGA (GCOaD, -1.0, 1.0, 1.0E-6);
	  CS = CS + SXCO[IO];
	}
    }
  else
    {
      //  ****  Klein-Nishina total cross section.
      EK = E * RREV;
      EKS = EK * EK;
      EK2 = 1.0 + EK + EK;
      EK1 = EKS - EK2 - 1.0;
      T0 = 1.0 / (1.0 + EK + EK);
      CSL = 0.5 * EKS * T0 * T0 + EK2 * T0 + EK1 * log (T0) - 1.0 / T0;
      for (int IO = 0; IO < NOSCCO[M]; IO++)
	{
	  TAU = (E - UICO[M][IO]) / E;
	  if (TAU < T0)
	    {
	      CSKN = 0.0;
	    }
	  else
	    {
	      CSU =
		0.5 * EKS * TAU * TAU + EK2 * TAU + EK1 * log (TAU) -
		1.0 / TAU;
	      CSKN = PIELR2 * (CSU - CSL) / (EK * EKS);
	    }
	  SXCO[IO] = FCO[M][IO] * CSKN;
	  CS = CS + SXCO[IO];
	}
    }
}

//  *********************************************************************
//                       SUBROUTINE EINaT1
//  *********************************************************************
void EINaT1 (double &E, double &UK, double &WK, double DELTA, double &WCCM,
	    double &H0, double &H1, double &H2, double &S0, double &S1,
	    double &S2, double &R0, double &R1, double &R2)
{
  //  Integrated cross sections for inelastic collisions of electrons with
  //  a single-shell oscillator, restricted to energy losses larger than,
  //  and smaller than, the cutoff energy loss WCCM.
  //
  //  Sternheimer-Liljequist oscillator model.
  //
  //  Input arguments:
  //    E ..... kinetic energy (eV).
  //    UK .... ionisation energy (eV).
  //    WK .... resonance energy (eV).
  //    DELTA ... Fermi's density effect correction.
  //    WCCM ... cutoff energy loss (eV).
  //
  //  Output arguments:
  //    H0 .... total cross section for hard colls. (cm**2).
  //    H1 .... stopping cross section for hard colls. (eV*cm**2).
  //    H2 .... straggling cross section for hard colls. (eV**2*cm**2).
  //    S0 .... total cross section for soft colls. (cm**2).
  //    S1 .... stopping cross section for soft colls. (eV*cm**2).
  //    S2 .... straggling cross section for soft colls. (eV**2*cm**2).
  //    R0 .... total cross section for soft colls. (cm**2).
  //    R1 .... 1st transport cross section for soft colls. (cm**2).
  //    R2 .... 2nd transport cross section for soft colls. (cm**2).

  using namespace CEIN01;

  const double TREV = 2.0 * REV;
  const double RTREV = 1.0 / TREV;
  const double PIELR2 = PI * ELRAD * ELRAD;

  H0 = 0.0;
  H1 = 0.0;
  H2 = 0.0;
  S0 = 0.0;
  S1 = 0.0;
  S2 = 0.0;
  R0 = 0.0;
  R1 = 0.0;
  R2 = 0.0;

  double WTHR;
  if (UK > 1.0E-3)
    {
      WTHR = UK;
    }
  else
    {
      WTHR = WK;
    }
  if (E < WTHR + 1.0E-6)
    {
      return;
    }

  //  ****  Constants.

  EI = E;
  const double GAM = 1.0 + E / REV;
  const double GAM2 = GAM * GAM;
  const double BETA2 = (GAM2 - 1.0) / GAM2;
  const double CONST = PIELR2 * TREV / BETA2;

  CPS = E * (E + TREV);
  double CP = sqrt (CPS);
  AMOL = pow (E / (E + REV), 2);

  //  ****  Trick: The resonance energy and the cutoff recoil energy of
  //        inner shells are varied to yield a smooth threshold.

  double WM, WKP, QKP, WCMAX, WDMAX;
  if (UK > 1.0E-3)
    {
      WM = 3.0 * WK - 2.0 * UK;
      if (E > WM)
	{
	  WKP = WK;
	  QKP = UK;
	}
      else
	{
	  WKP = (E + 2.0 * UK) / 3.0;
	  QKP = UK * (E / WM);
	  WM = E;
	}
      EE = E + UK;
      WCMAX = 0.5 * EE;
      if (WCMAX < WM)
	{
	  WDMAX = WCMAX;
	}
      else
	{
	  WDMAX = WM;
	}
    }

  else
    {
      WM = E;
      WKP = WK;
      QKP = WK;
      EE = E;
      WCMAX = 0.5 * EE;
      WDMAX = WKP + 1.0;
    }

  //  ****  Distant interactions.

  double SDL1 = 0.0;
  double SDT1 = 0.0;
  double CPPS, CPP;
  double A, B, BA;
  double QM;
  double RMU1;
  if (WDMAX > WTHR + 1.0E-6)
    {
      CPPS = (E - WKP) * (E - WKP + TREV);
      CPP = sqrt (CPPS);
      A = 4.0 * CP * CPP;
      B = pow (CP - CPP, 2);

      if (WKP > 1.0E-6 * E)
	{
	  QM = sqrt (pow (CP - CPP, 2) + pow (REV, 2)) - REV;
	}
      else
	{
	  QM = WKP * WKP / (BETA2 * TREV);
	  QM = QM * (1.0 - QM * RTREV);
	}
      if (QM < QKP)
	{
	  SDL1 = log (QKP * (QM + TREV) / (QM * (QKP + TREV)));
	  SDT1 = log (GAM2) - BETA2 - DELTA;
	  if (SDT1 < 0.0)
	    {
	      SDT1 = 0.0;
	    }

	  //  ****  Soft distant transport moments of orders 0-2.
	  if (WCCM > WTHR)
	    {
	      BA = B / A;
	      RMU1 = (QKP * (QKP + TREV) - B) / A;
	      R0 = log ((RMU1 + BA) / BA);
	      R1 = RMU1 - BA * R0;
	      R2 = pow (BA, 2) * R0 + 0.5 * RMU1 * (RMU1 - 2.0 * BA);
	      R0 = R0 / WKP;
	      R1 = R1 / WKP;
	      R2 = R2 / WKP;
	      R0 = R0 + SDT1 / WKP;
	    }
	}
    }

  double F0, F1, WL, WU;
  double SD1 = SDL1 + SDT1;
  if (SD1 > 0.0)
    {
      if (UK > 1.0E-3)
	{
	  //  ****  Inner-shell excitations (triangle distribution).
	  F0 = 1.0 / pow (WM - UK, 2);
	  F1 = 2.0 * F0 * SD1 / WKP;
	  if (WCCM < UK)
	    {
	      WL = UK;
	      WU = WDMAX;
	      H0 = F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
	      H1 =
		F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
		      (pow (WU, 3) - pow (WL, 3)) / 3.0);
	      H2 =
		F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
		      (pow (WU, 4) - pow (WL, 4)) / 4.0);
	    }
	  else
	    {
	      if (WCCM > WDMAX)
		{
		  WL = UK;
		  WU = WDMAX;
		  S0 =
		    F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  S1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  S2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		}
	      else
		{
		  WL = WCCM;
		  WU = WDMAX;
		  H0 =
		    F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  H1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  H2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		  WL = UK;
		  WU = WCCM;
		  S0 =
		    F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  S1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  S2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		}
	      double F2 =
		F0 * (2.0 * WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)));
	      R0 = F2 * R0;
	      R1 = F2 * R1;
	      R2 = F2 * R2;
	    }
	}
      else
	{
	  //  ****  Outer-shell excitations (delta oscillator).
	  if (WCCM < WKP)
	    {
	      H1 = SD1;
	      H0 = SD1 / WKP;
	      H2 = SD1 * WKP;
	    }
	  else
	    {
	      S1 = SD1;
	      S0 = SD1 / WKP;
	      S2 = SD1 * WKP;
	    }
	}
    }

  //  ****  Close collisions (Moller's cross section).

  if (WCMAX < WTHR + 1.0E-6)
    {
    }
  else
    {
      if (WCCM < WTHR)		// No soft interactions.
	{
	  WL = WTHR;
	  WU = WCMAX;
	  H0 =
	    H0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
	    (1.0 / WL) + (1.0 -
			  AMOL) * log (((EE - WU) * WL) / ((EE - WL) * WU)) /
	    EE + AMOL * (WU - WL) / pow (EE, 2);

	  H1 =
	    H1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) + (2.0 -
									AMOL)
	    * log ((EE - WU) / (EE - WL)) + AMOL * (pow (WU, 2) -
						    pow (WL,
							 2)) / (2.0 * pow (EE,
									   2));

	  H2 =
	    H2 + (2.0 - AMOL) * (WU - WL) +
	    (WU * (2.0 * EE - WU) / (EE - WU)) -
	    (WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
						  AMOL) * EE * log ((EE -
								     WU) /
								    (EE -
								     WL)) +
	    AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
	}
      else
	{
	  if (WCCM > WCMAX)
	    {
	      WL = WTHR;
	      WU = WCMAX;
	      S0 =
		S0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
		(1.0 / WL) + (1.0 -
			      AMOL) * log (((EE - WU) * WL) / ((EE - WL) *
							       WU)) / EE +
		AMOL * (WU - WL) / pow (EE, 2);

	      S1 =
		S1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) +
		(2.0 - AMOL) * log ((EE - WU) / (EE - WL)) +
		AMOL * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (EE, 2));

	      S2 =
		S2 + (2.0 - AMOL) * (WU - WL) +
		(WU * (2.0 * EE - WU) / (EE - WU)) -
		(WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
						      AMOL) * EE * log ((EE -
									 WU) /
									(EE -
									 WL))
		+ AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
	    }
	  else
	    {
	      WL = WCCM;
	      WU = WCMAX;
	      H0 =
		H0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
		(1.0 / WL) + (1.0 -
			      AMOL) * log (((EE - WU) * WL) / ((EE - WL) *
							       WU)) / EE +
		AMOL * (WU - WL) / pow (EE, 2);

	      H1 =
		H1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) +
		(2.0 - AMOL) * log ((EE - WU) / (EE - WL)) +
		AMOL * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (EE, 2));

	      H2 =
		H2 + (2.0 - AMOL) * (WU - WL) +
		(WU * (2.0 * EE - WU) / (EE - WU)) -
		(WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
						      AMOL) * EE * log ((EE -
									 WU) /
									(EE -
									 WL))
		+ AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
	      WL = WTHR;
	      WU = WCCM;
	      S0 =
		S0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
		(1.0 / WL) + (1.0 -
			      AMOL) * log (((EE - WU) * WL) / ((EE - WL) *
							       WU)) / EE +
		AMOL * (WU - WL) / pow (EE, 2);

	      S1 =
		S1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) +
		(2.0 - AMOL) * log ((EE - WU) / (EE - WL)) +
		AMOL * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (EE, 2));

	      S2 =
		S2 + (2.0 - AMOL) * (WU - WL) +
		(WU * (2.0 * EE - WU) / (EE - WU)) -
		(WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
						      AMOL) * EE * log ((EE -
									 WU) /
									(EE -
									 WL))
		+ AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
	    }
	  //  ****  Soft close transport moments of orders 0-2.
	  double CP2S = (E - WL) * (E - WL + TREV);
	  double CP2 = sqrt (CP2S);
	  double RMU2 =
	    (WL * (WL + TREV) - pow (CP - CP2, 2)) / (4.0 * CP * CP2);
	  double CP3S = (E - WU) * (E - WU + TREV);
	  double CP3 = sqrt (CP3S);
	  double RMU3 =
	    (WU * (WU + TREV) - pow (CP - CP3, 2)) / (4.0 * CP * CP3);
	  MOM = 0;
	  R0 = R0 + SUMGA (EINaDS, RMU2, RMU3, 1.0E-7);
	  MOM = 1;
	  R1 = R1 + SUMGA (EINaDS, RMU2, RMU3, 1.0E-7);
	  MOM = 2;
	  R2 = R2 + SUMGA (EINaDS, RMU2, RMU3, 1.0E-7);
	}
    }

  H0 = CONST * H0;
  H1 = CONST * H1;
  H2 = CONST * H2;
  S0 = CONST * S0;
  S1 = CONST * S1;
  S2 = CONST * S2;
  R0 = CONST * R0;
  R1 = CONST * R1;
  R2 = CONST * R2;
}

//  *********************************************************************
//                       SUBROUTINE PINaT1
//  *********************************************************************
void PINaT1 (double &E, double &UK, double &WK, double DELTA, double &WCCM,
	     double &H0, double &H1, double &H2, double &S0, double &S1,
	     double &S2, double &R0, double &R1, double &R2)
{
//  Integrated cross sections for inelastic collisions of positrons with
//  a single-shell oscillator, restricted to energy losses larger than,
//  and smaller than, the cutoff energy loss WCCM.
//
//  Sternheimer-Liljequist oscillator model.
//
//  Input arguments:
//    E ..... kinetic energy (eV).
//    UK .... ionisation energy (eV).
//    WK .... resonance energy (eV).
//    DELTA ... Fermi's density effect correction.
//    WCCM ... cutoff energy loss (eV).
//
//  Output arguments:
//    H0 .... total cross section for hard colls. (cm**2).
//    H1 .... stopping cross section for hard colls. (eV*cm**2).
//    H2 .... straggling cross section for hard colls. (eV**2*cm**2).
//    S0 .... total cross section for soft colls. (cm**2).
//    S1 .... stopping cross section for soft colls. (eV*cm**2).
//    S2 .... straggling cross section for soft colls. (eV**2*cm**2).
//    R0 .... total cross section for soft colls. (cm**2).
//    R1 .... 1st transport cross section for soft colls. (cm**2).
//    R2 .... 2nd transport cross section for soft colls. (cm**2).
//

  using namespace CPIN01;

  const double TREV = 2.0 * REV;
  const double RTREV = 1.0 / TREV;
  const double PIELR2 = PI * ELRAD * ELRAD;


  H0 = 0.0;
  H1 = 0.0;
  H2 = 0.0;
  S0 = 0.0;
  S1 = 0.0;
  S2 = 0.0;
  R0 = 0.0;
  R1 = 0.0;
  R2 = 0.0;

  double WTHR;
  if (UK > 1.0E-3)
    {
      WTHR = UK;
    }
  else
    {
      WTHR = WK;
    }
  if (E < WTHR + 1.0E-6)
    {
      return;
    }

  //  ****  Constants.

  EI = E;
  const double GAM = 1.0 + E / REV;
  const double GAM2 = GAM * GAM;
  const double BETA2 = (GAM2 - 1.0) / GAM2;
  const double CONST = PIELR2 * TREV / BETA2;

  CPS = E * (E + TREV);
  double CP = sqrt (CPS);
  double AMOL = pow (E / (E + REV), 2);
  double G12 = pow (GAM + 1.0, 2);
  BHA1 = AMOL * (2.0 * G12 - 1.0) / (GAM2 - 1.0);
  BHA2 = AMOL * (3.0 + 1.0 / G12);
  BHA3 = AMOL * 2.0 * GAM * (GAM - 1.0) / G12;
  BHA4 = AMOL * pow (GAM - 1.0, 2) / G12;

  //  ****  Trick: The resonance energy and the cutoff recoil energy of
  //        inner shells are varied to yield a smooth threshold. 

  double WM, WKP, QKP, WCMAX, WDMAX;
  if (UK > 1.0E-3)
    {
      WM = 3.0 * WK - 2.0 * UK;
      if (E > WM)
	{
	  WKP = WK;
	  QKP = UK;
	}
      else
	{
	  WKP = (E + 2.0 * UK) / 3.0;
	  QKP = UK * (E / WM);
	  WM = E;
	}
      WCMAX = E;
      if (WM < WCMAX)
	{
	  WDMAX = WM;
	}
      else
	{
	  WDMAX = WCMAX;
	}
    }
  else
    {
      WM = E;
      WKP = WK;
      QKP = WK;
      WCMAX = E;
      WDMAX = WKP + 1.0;
    }

  //  ****  Distant interactions.


  double SDL1 = 0.0;
  double SDT1 = 0.0;
  double CPPS, CPP, A, B, QM, BA, RMU1;
  if (WDMAX > WTHR + 1.0E-6)
    {
      CPPS = (E - WKP) * (E - WKP + TREV);
      CPP = sqrt (CPPS);
      A = 4.0 * CP * CPP;
      B = pow (CP - CPP, 2);

      if (WKP > 1.0E-6 * E)
	{
	  QM = sqrt (pow (CP - CPP, 2) + pow (REV, 2)) - REV;
	}
      else
	{
	  QM = WKP * WKP / (BETA2 * TREV);
	  QM = QM * (1.0 - QM * RTREV);
	}
      if (QM < QKP)
	{
	  SDL1 = log (QKP * (QM + TREV) / (QM * (QKP + TREV)));

	  SDT1 = log (GAM2) - BETA2 - DELTA;
	  if (SDT1 < 0.0)
	    {
	      SDT1 = 0.0;
	    }

	  //  ****  Soft distant transport moments of orders 0-2.
	  if (WCCM > WTHR)
	    {
	      BA = B / A;
	      RMU1 = (QKP * (QKP + TREV) - B) / A;
	      R0 = log ((RMU1 + BA) / BA);
	      R1 = RMU1 - BA * R0;
	      R2 = pow (BA, 2) * R0 + 0.5 * RMU1 * (RMU1 - 2.0 * BA);
	      R0 = R0 / WKP;
	      R1 = R1 / WKP;
	      R2 = R2 / WKP;
	      R0 = R0 + SDT1 / WKP;
	    }
	}
    }

  double SD1 = SDL1 + SDT1;
  double F0, F1, WL, WU;
  if (SD1 > 0.0)
    {
      if (UK > 1.0E-3)
	{
	  //  ****  Inner-shell excitations (triangle distribution).
	  F0 = 1.0 / pow (WM - UK, 2);
	  F1 = 2.0 * F0 * SD1 / WKP;
	  if (WCCM < UK)
	    {
	      WL = UK;
	      WU = WDMAX;
	      H0 = F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
	      H1 =
		F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
		      (pow (WU, 3) - pow (WL, 3)) / 3.0);
	      H2 =
		F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
		      (pow (WU, 4) - pow (WL, 4)) / 4.0);
	    }
	  else
	    {
	      if (WCCM > WDMAX)
		{
		  WL = UK;
		  WU = WDMAX;
		  S0 =
		    F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  S1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  S2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		}
	      else
		{
		  WL = WCCM;
		  WU = WDMAX;
		  H0 =
		    F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  H1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  H2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		  WL = UK;
		  WU = WCCM;
		  S0 =
		    F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  S1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  S2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		}
	      double F2 =
		F0 * (2.0 * WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)));
	      R0 = F2 * R0;
	      R1 = F2 * R1;
	      R2 = F2 * R2;
	    }
	}
      else
	{
	  //  ****  Outer-shell excitations (delta oscillator).
	  if (WCCM < WKP)
	    {
	      H1 = SD1;
	      H0 = SD1 / WKP;
	      H2 = SD1 * WKP;
	    }
	  else
	    {
	      S1 = SD1;
	      S0 = SD1 / WKP;
	      S2 = SD1 * WKP;
	    }
	}
    }

  //  ****  Close collisions (Bhabha's cross section).

  if (WCMAX < WTHR + 1.0E-6)
    {
    }
  else
    {
      if (WCCM < WTHR)		// No soft interactions.
	{
	  WL = WTHR;
	  WU = WCMAX;
	  H0 =
	    H0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
	    BHA2 * (WU - WL) / pow (E,
				    2) - BHA3 * (pow (WU, 2) - pow (WL,
								    2)) /
	    (2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
					 pow (WL, 3)) / (3.0 * pow (E, 4));

	  H1 =
	    H1 + log (WU / WL) - BHA1 * (WU - WL) / E + BHA2 * (pow (WU, 2) -
								pow (WL,
								     2)) /
	    (2.0 * pow (E, 2)) - BHA3 * (pow (WU, 3) -
					 pow (WL, 3)) / (3.0 * pow (E,
								    3)) +
	    BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

	  H2 =
	    H2 + WU - WL - BHA1 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * E) +
	    BHA2 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 2)) -
	    BHA3 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 3)) +
	    BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
	}
      else
	{
	  if (WCCM > WCMAX)
	    {
	      WL = WTHR;
	      WU = WCMAX;
	      S0 =
		S0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
		BHA2 * (WU - WL) / pow (E,
					2) - BHA3 * (pow (WU, 2) - pow (WL,
									2)) /
		(2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
					     pow (WL, 3)) / (3.0 * pow (E,
									4));

	      S1 =
		S1 + log (WU / WL) - BHA1 * (WU - WL) / E +
		BHA2 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (E, 2)) -
		BHA3 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 3)) +
		BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

	      S2 =
		S2 + WU - WL - BHA1 * (pow (WU, 2) -
				       pow (WL,
					    2)) / (2.0 * E) + BHA2 * (pow (WU,
									   3)
								      -
								      pow (WL,
									   3))
		/ (3.0 * pow (E, 2)) - BHA3 * (pow (WU, 4) -
					       pow (WL, 4)) / (4.0 * pow (E,
									  3))
		+ BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
	    }
	  else
	    {
	      WL = WCCM;
	      WU = WCMAX;
	      H0 =
		H0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
		BHA2 * (WU - WL) / pow (E,
					2) - BHA3 * (pow (WU, 2) - pow (WL,
									2)) /
		(2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
					     pow (WL, 3)) / (3.0 * pow (E,
									4));

	      H1 =
		H1 + log (WU / WL) - BHA1 * (WU - WL) / E +
		BHA2 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (E, 2)) -
		BHA3 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 3)) +
		BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

	      H2 =
		H2 + WU - WL - BHA1 * (pow (WU, 2) -
				       pow (WL,
					    2)) / (2.0 * E) + BHA2 * (pow (WU,
									   3)
								      -
								      pow (WL,
									   3))
		/ (3.0 * pow (E, 2)) - BHA3 * (pow (WU, 4) -
					       pow (WL, 4)) / (4.0 * pow (E,
									  3))
		+ BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
	      WL = WTHR;
	      WU = WCCM;
	      S0 =
		S0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
		BHA2 * (WU - WL) / pow (E,
					2) - BHA3 * (pow (WU, 2) - pow (WL,
									2)) /
		(2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
					     pow (WL, 3)) / (3.0 * pow (E,
									4));

	      S1 =
		S1 + log (WU / WL) - BHA1 * (WU - WL) / E +
		BHA2 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (E, 2)) -
		BHA3 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 3)) +
		BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

	      S2 =
		S2 + WU - WL - BHA1 * (pow (WU, 2) -
				       pow (WL,
					    2)) / (2.0 * E) + BHA2 * (pow (WU,
									   3)
								      -
								      pow (WL,
									   3))
		/ (3.0 * pow (E, 2)) - BHA3 * (pow (WU, 4) -
					       pow (WL, 4)) / (4.0 * pow (E,
									  3))
		+ BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
	    }
	  //  ****  Soft close transport moments of orders 0-2.
	  double CP2S = (E - WL) * (E - WL + TREV);
	  double CP2 = sqrt (CP2S);
	  double RMU2 =
	    (WL * (WL + TREV) - pow (CP - CP2, 2)) / (4.0 * CP * CP2);
	  double CP3S, CP3, RMU3;
	  if (WU < E - 1.0)
	    {
	      CP3S = (E - WU) * (E - WU + TREV);
	      CP3 = sqrt (CP3S);
	      RMU3 =
		(WU * (WU + TREV) - pow (CP - CP3, 2)) / (4.0 * CP * CP3);
	    }
	  else
	    {
	      RMU3 = 0.5;
	    }
	  MOM = 0;
	  R0 = R0 + SUMGA (PINaDS, RMU2, RMU3, 1.0E-7);
	  MOM = 1;
	  R1 = R1 + SUMGA (PINaDS, RMU2, RMU3, 1.0E-7);
	  MOM = 2;
	  R2 = R2 + SUMGA (PINaDS, RMU2, RMU3, 1.0E-7);
	}
    }

  H0 = CONST * H0;
  H1 = CONST * H1;
  H2 = CONST * H2;
  S0 = CONST * S0;
  S1 = CONST * S1;
  S2 = CONST * S2;
  R0 = CONST * R0;
  R1 = CONST * R1;
  R2 = CONST * R2;

}

//  *********************************************************************
//                       SUBROUTINE SORT2
//  *********************************************************************
void SORT2 (double *X, double *Y, int &N)
{
  //  This subroutine sorts a table (X,Y) of a function with n data points.
  //  A discontinuity of the function is described by giving twice the abs-
  //  cissa. It is assumed that the function is strictly positive (negative
  //  values of Y are set to zero).

  using namespace PENERROR_mod;

  const int NP_S = 12000;
  int IORDER[NP_S];

  if (N > NP_S)
    {
      printf ("NP =%7d\n", N);
      ErrorFunction (1903);
      return;
    }

  if (N == 1)
    {
      return;
    }
  for (int I = 0; I < N; I++)
    {
      IORDER[I] = I + 1;
      if (Y[I] < 1.0E-75)
	{
	  Y[I] = 1.0E-75;
	}
    }

  int IMIN;
  double XMIN;
  for (int I = 0; I < N - 1; I++)
    {
      IMIN = I + 1;
      XMIN = X[I];
      for (int J = I + 1; J < N; J++)
	{
	  if (X[J] < XMIN)
	    {
	      IMIN = J + 1;
	      XMIN = X[J];
	    }
	}
      double SAVE = X[I];
      X[I] = X[IMIN - 1];
      X[IMIN - 1] = SAVE;
      SAVE = Y[I];
      Y[I] = Y[IMIN - 1];
      Y[IMIN - 1] = SAVE;
      int ISAVE = IORDER[I];
      IORDER[I] = IORDER[IMIN - 1];
      IORDER[IMIN - 1] = ISAVE;
      if (I + 1 == 1)
	{
	  continue;
	}
      if (IORDER[I] < IORDER[I - 1] && fabs (X[I] - X[I - 1]) < 1.0E-15)
	{
	  SAVE = X[I - 1];
	  X[I - 1] = X[I];
	  X[I] = SAVE;
	  SAVE = Y[I - 1];
	  Y[I - 1] = Y[I];
	  Y[I] = SAVE;
	  ISAVE = IORDER[I - 1];
	  IORDER[I - 1] = IORDER[I];
	  IORDER[I] = ISAVE;
	}
    }
  int I = N;
  if (IORDER[I - 1] < IORDER[I - 1 - 1]
      && fabs (X[I - 1] - X[I - 1 - 1]) < 1.0E-15)
    {
      double SAVE = X[I - 1 - 1];
      X[I - 1 - 1] = X[I - 1];
      X[I - 1] = SAVE;
      SAVE = Y[I - 1 - 1];
      Y[I - 1 - 1] = Y[I - 1];
      Y[I - 1] = SAVE;
    }
}

//  *********************************************************************
//                       FUNCTION SUMGA
//  *********************************************************************
double SUMGA (FCT_SUMGA FCT, double XL, double XU, double TOL)
{
  //  This function calculates the value SUMGA of the integral of the
  //  (external) function FCT over the interval (XL,XU) using the 20-point
  //  Gauss quadrature method with an adaptive-bisection scheme.

  //  TOL is the tolerance, i.e. maximum allowed relative error; it should
  //  not be less than 1.0D-13. A warning message is written in unit 6 when
  //  the required accuracy is not attained. The common block CSUMGA can be
  //  used to transfer the error flag IERGA and the number of calculated
  //  function values to the calling program.

  //                                        Francesc Salvat. 2 April, 2012.

  using namespace CSUMGA;
  using namespace CSGAWR;

  const int NP_S = 10;
  const int NP2_S = 2 * NP_S;
  const int NP4 = 4 * NP_S;
  const int NOIT = 130;
  const int NOIT5 = NOIT / 5;
  const int NCALLT = 100000;

  double XM[NP_S], XP[NP_S];
  double S[NOIT], SN[NOIT], XR[NOIT], XRN[NOIT];
  //  Output error codes:
  //     IERGA = 0, no problem, the calculation has converged.
  //           = 1, too many open subintervals.
  //           = 2, too many function calls.
  //           = 3, subintervals are too narrow.

  //  ****  Gauss 20-point integration formula.
  //  Abscissas.
  double X[NP_S] =
    { 7.6526521133497334E-02, 2.2778585114164508E-01, 3.7370608871541956E-01,
5.1086700195082710E-01, 6.3605368072651503E-01, 7.4633190646015079E-01,
8.3911697182221882E-01, 9.1223442825132591E-01, 9.6397192727791379E-01,
9.9312859918509492E-01 };
  //  Weights.
  double W[NP_S] =
    { 1.5275338713072585E-01, 1.4917298647260375E-01, 1.4209610931838205E-01,
1.3168863844917663E-01, 1.1819453196151842E-01, 1.0193011981724044E-01,
8.3276741576704749E-02, 6.2672048334109064E-02, 4.0601429800386941E-02,
1.7614007139152118E-02 };

  for (int I = 0; I < NP_S; I++)
    {
      XM[I] = 1.0 - X[I];
      XP[I] = 1.0 + X[I];
    }
  //  ****  Global and partial tolerances.

  double TOL1;			// Global tolerance.

  if (TOL < 1.0E-13)
    {
      TOL1 = 1.0E-13;
    }
  else
    {
      TOL1 = TOL;
    }

  if (TOL1 > 1.0E-5)
    {
      TOL1 = 1.0E-5;
    }

  double TOL2 = TOL1;		// Effective tolerance.
  double TOL3 = 1.0E-13;	// Round-off protection.
  double SUMGA_RETURN = 0.0;	//Valor que torna la funcio
  IERGA = 0;
  //  ****  Straight integration from XL to XU.
  double H = XU - XL;
  double HH = 0.5 * H;
  double X1 = XL;
  double SP = W[0] * (FCT (X1 + XM[0] * HH) + FCT (X1 + XP[0] * HH));
  for (int J = 1; J < NP_S; J++)
    {
      SP = SP + W[J] * (FCT (X1 + XM[J] * HH) + FCT (X1 + XP[J] * HH));
    }
  S[0] = SP * HH;
  XR[0] = X1;
  NCALL = NP2_S;
  int NOI = 1;
  int IDONE = 1;		// To prevent a compilation warning.

  //  ****  Adaptive-bisection scheme.

  bool Eixir = false;
  int NOIP;
  double SUMR;
  while (!Eixir)
    {
      Eixir = true;
      H = HH;			// Subinterval length.
      HH = 0.5 * H;
      double AHH = fabs (HH);
      if (TOL2 > 0.01 * TOL1)
	{
	  TOL2 = TOL2 * 0.5;
	}
      SUMR = 0.0;
      NOIP = NOI;
      NOI = 0;
      bool Eixir2 = false;
      for (int I = 0; I < NOIP; I++)
	{
	  double SI = S[I];	// Bisect the I-th open interval.

	  X1 = XR[I];
	  if (AHH < fabs (X1) * TOL3)
	    {
	      IERGA = 3;
	    }			// The interval is too narrow.
	  SP = W[0] * (FCT (X1 + XM[0] * HH) + FCT (X1 + XP[0] * HH));
	  for (int J = 1; J < NP_S; J++)
	    {
	      SP =
		SP + W[J] * (FCT (X1 + XM[J] * HH) + FCT (X1 + XP[J] * HH));
	    }
	  double S1 = SP * HH;

	  double X2 = X1 + H;
	  if (AHH < fabs (X2) * TOL3)
	    {
	      IERGA = 3;
	    }			// The interval is too narrow.
	  SP = W[0] * (FCT (X2 + XM[0] * HH) + FCT (X2 + XP[0] * HH));
	  for (int J = 1; J < NP_S; J++)
	    {
	      SP =
		SP + W[J] * (FCT (X2 + XM[J] * HH) + FCT (X2 + XP[J] * HH));
	    }
	  double S2 = SP * HH;

	  IDONE = I + 1;
	  NCALL = NCALL + NP4;
	  double S12 = S1 + S2;	// Sum of integrals on the two subintervals.
	  if (fabs (S12 - SI) <
	      ((TOL2 * fabs (S12) > 1.0E-35) ? TOL2 * fabs (S12) : 1.0E-35))
	    {
	      //  ****  The integral over the parent interval has converged.
	      SUMGA_RETURN = SUMGA_RETURN + S12;
	    }
	  else
	    {
	      SUMR = SUMR + S12;
	      NOI = NOI + 2;
	      if (NOI < NOIT)
		{
		  //  ****  Store open intervals.
		  SN[NOI - 2] = S1;
		  XRN[NOI - 2] = X1;
		  SN[NOI - 1] = S2;
		  XRN[NOI - 1] = X2;
		}
	      else
		{
		  //  ****  Too many open intervals.
		  IERGA = 1;
		  Eixir2 = true;
		  break;
		}
	    }
	  if (NCALL > NCALLT)
	    {
	      //  ****  Too many calls to FCT.
	      IERGA = 2;
	      Eixir2 = true;
	      break;
	    }
	}
      if (Eixir2)
	{
	  break;
	}

      //  ****  Analysis of partial results and error control.

      if (IERGA == 3)		// Intervals are too narrow.
	{
	  if (NOI < NOIT5)
	    {
	      IERGA = 0;	// The result is probably correct.
	      SUMGA_RETURN = SUMGA_RETURN + SUMR;
	      return SUMGA_RETURN;
	    }
	  break;
	}

      if (IERGA == 0)
	{
	  double Aux_Double = TOL1 * fabs (SUMGA_RETURN + SUMR);
	  if (Aux_Double < 1.0E-35)
	    {
	      Aux_Double = 1.0E-35;
	    }
	  if (fabs (SUMR) < Aux_Double || NOI == 0)
	    {
	      return SUMGA_RETURN;
	    }
	  else
	    {
	      for (int I = 0; I < NOI; I++)
		{
		  S[I] = SN[I];
		  XR[I] = XRN[I];
		}
	      Eixir = false;
	      continue;
	    }
	}
    }

  //  ****  Warning (low accuracy) message.

  if (IDONE < NOIP)
    {
      for (int I = IDONE; I < NOIP; I++)
	{
	  SUMR = SUMR + S[I];
	}
      NOI = NOI + (NOIP - IDONE);
    }
  SUMGA_RETURN = SUMGA_RETURN + SUMR;
  if (ISGAW == 0)
    {
      return SUMGA_RETURN;
    }
  printf ("  >>> SUMGA. Gauss adaptive-bisection quadrature.\n");
  printf ("  XL =%15.8E, XU =%15.8E, TOL =%8.1E\n", XL, XU, TOL);
  if (fabs (SUMGA_RETURN) > 1.0E-35)
    {
      double RERR = fabs (SUMR) / fabs (SUMGA_RETURN);
      printf ("  SUMGA =%22.15E, relative error =%8.1E\n", SUMGA_RETURN,
	      RERR);
    }
  else
    {
      double AERR = fabs (SUMR);
      printf ("  SUMGA =%22.15E, absolute error =%8.1E\n", SUMGA_RETURN,
	      AERR);
    }
  printf ("  NCALL =%6d, open subintervals =%4d, H =%10.3E\n", NCALL, NOI,
	  HH);
  if (IERGA == 1)
    {
      printf ("  IERGA = 1, too many open subintervals.\n");
    }
  else if (IERGA == 2)
    {
      printf ("  IERGA = 2, too many function calls.\n");
    }
  else if (IERGA == 3)
    {
      printf ("  IERGA = 3, subintervals are too narrow.\n");
    }
  printf ("  WARNING: the required accuracy has not been attained.\n");

  return SUMGA_RETURN;		//MIRAR

}

//  *********************************************************************
//                       FUNCTION PINaDS
//  *********************************************************************
double PINaDS (double RMU)
{
  //  Angular differential cross section for soft close inelastic colli-
  //  sions of positrons.

  using namespace CPIN01;

  double AUX = 2.0 * RMU * (1.0 - RMU);
  double DENOM = EI * AUX + REV;
  double W = CPS * AUX / DENOM;
  double DWDMU = CPS * REV * (2.0 - 4.0 * RMU) / pow (DENOM, 2);
  double WE = W / EI;
  double PINaDS_RETURN =
    (1.0 -
     WE * (BHA1 - WE * (BHA2 - WE * (BHA3 - WE * BHA4)))) * DWDMU * pow (RMU,
									 MOM)
    / pow (W, 2);
  return PINaDS_RETURN;
}

//  *********************************************************************
//                       FUNCTION EINaDS
//  *********************************************************************
double EINaDS (double RMU)
{
  //  Angular differential cross section for soft close inelastic colli-
  //  sions of electrons.
  //

  using namespace CEIN01;

  double EINaDS_RETURN;
  double AUX = 2.0 * RMU * (1.0 - RMU);
  double DENOM = EI * AUX + REV;
  double W = CPS * AUX / DENOM;
  double DWDMU = CPS * REV * (2.0 - 4.0 * RMU) / pow (DENOM, 2);
  EINaDS_RETURN =
    (1.0 + pow (W / (EE - W), 2) - (1.0 - AMOL) * (W / (EE - W)) +
     AMOL * pow (W / EE, 2)) * DWDMU * pow (RMU, MOM) / pow (W, 2);
  return EINaDS_RETURN;
}

//  *********************************************************************
//                        FUNCTION GCOaD
//  *********************************************************************
double GCOaD (double CDT)
{
  //  Single differential cross section for photon Compton scattering by
  //  electrons in the IO-th shell, differential in the direction of the
  //  scattered photon only. Evaluated from the incoherent scattering
  //  function.

  //  The energy E of the primary photon is entered through common CGCO00.
  //  The output value GCOaD is the DCS per electron in units of PIELR2.

  using namespace PENELOPE_mod;

  using namespace CGCO;
  using namespace CGCO00;

  const double RREV = 1.0 / REV;
  const double D2 = 1.4142135623731;
  const double D1 = 1.0 / D2;
  const double D12 = 0.5;

  double GCOaD_RETURN;
  if (EE < UICO[MM][IOSC - 1])
    {
      GCOaD_RETURN = 0.0;
      return GCOaD_RETURN;
    }
  //  ****  Energy of the Compton line.
  double CDT1 = 1.0 - CDT;
  double EOEC = 1.0 + (EE * RREV) * CDT1;
  double ECOE = 1.0 / EOEC;
  //  ****  Klein-Nishina X-factor.
  double XKN = EOEC + ECOE - 1.0 + CDT * CDT;
  //  ****  Incoherent scattering function (analytical profile).
  double AUX = EE * (EE - UICO[MM][IOSC - 1]) * CDT1;
  double PIMAX =
    (AUX -
     REV * UICO[MM][IOSC - 1]) / (REV * sqrt (AUX + AUX +
					      pow (UICO[MM][IOSC - 1], 2)));
  double SIA;
  if (PIMAX > 0.0)
    {
      SIA =
	1.0 - 0.5 * exp (D12 - pow (D1 + D2 * FJ0[MM][IOSC - 1] * PIMAX, 2));
    }
  else
    {
      SIA = 0.5 * exp (D12 - pow (D1 - D2 * FJ0[MM][IOSC - 1] * PIMAX, 2));
    }
  //  ****  1st order correction, integral of Pz times the Compton profile.
  //        Calculated approximately using a free-electron gas profile.
  double PF = 3.0 / (4.0 * FJ0[MM][IOSC - 1]);
  double QCOE2, P2, DSPZ;
  if (fabs (PIMAX) < PF)
    {
      QCOE2 = 1.0 + pow (ECOE, 2) - 2.0 * ECOE * CDT;
      P2 = pow (PIMAX, 2);
      DSPZ =
	sqrt (QCOE2) * (1.0 + ECOE * (ECOE - CDT) / QCOE2) * FJ0[MM][IOSC -
								     1] *
	0.25 * (2 * P2 - pow (P2, 2) / pow (PF, 2) - pow (PF, 2));
      if (DSPZ > -SIA)
	{
	  SIA = SIA + DSPZ;
	}
      else
	{
	  SIA = 0.0;
	}
    }
  //  ****  Differential cross section (per electron, in units of PIELR2).
  GCOaD_RETURN = pow (ECOE, 2) * XKN * SIA;
  return GCOaD_RETURN;
}
