//
//
//    Copyright (C) 2024-2025 Universitat de València - UV
//    Copyright (C) 2024-2025 Universitat Politècnica de València - UPV
//    Copyright (C) 2025 Vicent Giménez Alventosa
//
//    This file is part of PenRed: Parallel Engine for Radiation Energy Deposition.
//
//    PenRed is free software: you can redistribute it and/or modify
//    it under the terms of the GNU Affero General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    PenRed is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU Affero General Public License for more details.
//
//    You should have received a copy of the GNU Affero General Public License
//    along with PenRed.  If not, see <https://www.gnu.org/licenses/>. 
//
//    contact emails:
//
//        vicent.gimenez.alventosa@gmail.com (Vicent Giménez Alventosa)
//        vicente.gimenez@uv.es (Vicente Giménez Gómez)
//    
//

/*
C
C  This program generates material definition files for PENELOPE, which
C  contain tables of physical properties, interaction cross sections and
C  other particle transport characteristics. These data are extracted
C  from the database, which consists of the following 995 ASCII files
C  contained in the directory './pendbase/pdfiles':
C
C* PDATCONF.P14: atomic ground-state configurations, ionisation energies
C     and central values of the one-electron shell Compton profiles for
C     the elements, from hydrogen to einsteinium (Z=1-99).
C
C* PDCOMPOS.PEN: prepared composition data for 280 different materials
C     of radiological interest (adapted from Berger, NISTIR 4999, 1992).
C
C* MATERIAL-LIST.TXT: list of materials included in the PDCOMPOS.P08
c     file, with their identification numbers.
C
C* PDRELAX.P11: data on atomic relaxation, extracted from the LLNL
C     Evaluated Atomic Data Library.
C
C* 99 files named PDEELZZ.P08 with ZZ=atomic number (01-99). These
C     files contain tables of total cross sections and first and second
C     transport cross sections for elastic scattering of electrons and
C     positrons by neutral free atoms, generated by the program ELSEPA.
C     The same grid of energies, that covers the interval from 50 eV
C     up to 1 GeV, is used for all elements.
C
C* 99 files named EELDXZZZ.P08 with ZZZ=atomic number (001-099). These
C     files contain tables of differential cross sections for elastic
C     scattering of electrons by free neutral atoms. They where
C     generated by using the program ELSEPA and cover the energy
C     interval from 50 eV to 100 MeV.
C
C* 99 files named PELDXZZZ.P08 with ZZZ=atomic number (001-099). These
C     files contain tables of differential cross sections for elastic
C     scattering of positrons by free neutral atoms. They where
C     generated by using the program ELSEPA and cover the energy
C     interval from 50 eV to 100 MeV.
C
C* 99 files named PDEBRZZ.P08 that contain electron bremsstrahlung data.
C     These files were produced from the database of Seltzer and Berger.
C     The same grid of energies for all elements.
C
C* PDBRANG.P08: parameters of the intrinsic angular distribution of
C     bremsstrahlung photons. Determined by fitting the set of benchmark
C     partial-wave shape functions of Kissel, Quarles and Pratt.
C
C* 99 files named PDAFFZZ.P08, ZZ=atomic number (01-99), with tables of
C     atomic form factors and incoherent scattering functions of neutral
C     free atoms, extracted from the EPDL97 data library of Cullen et al.
C
C* 99 files named PDGRAZZ.P08 with ZZ=atomic number (01-99). These
C     files contain tables of anomalous scattering factors and total
C     cross sections for Rayleigh scattering of photons by neutral free
C     atoms, extracted from the EPDL97 data library of Cullen et al.
C
C* 99 files named PDGPPZZ.P11 with cross sections for pair and triplet
C     production in the field of neutral atoms, obtained from the XCOM
C     program of Berger and Hubbell. The same energy grid for all
C     elements.
C
C* 99 files named PDGPHZZ.P12, containing total atomic photoelectric
C     cross sections and partial cross sections for inner (K, L, M, and
C     N) shells, generated from the EPDL97 data library of Cullen et al.
C
C* 99 files named PDESIZZ.P14 with cross sections for ionisation of
C     inner (K, L, M, and N) shells by electron impact, generated from
C     the distorted-wave and plane-wave Born approximations.
C
C* 99 files named PDPSIZZ.P14 with cross sections for ionisation of
C     inner (K, L, M, and N) shells by positron impact, generated from
C     the distorted-wave and plane-wave Born approximations.
C
C  A material is completely characterised by its chemical composition,
C  i.e., elements present and number of atoms of each element in a
C  molecule (=stoichiometric index), mass density and mean excitation
C  energy. Alloys and mixtures are treated as compounds, with stoichio-
C  metric indexes equal or proportional to the percent number of atoms
C  of each element. Information about the material is supplied by the
C  user from the keyboard, following the prompts from 'material', or
C  read from the PDCOMPOS.PEN file, which contains information for 280
C  different materials. In the case of compounds, 'molecular' cross
C  sections are obtained by means of the additivity rule, i.e. as the
C  sum of the atomic cross sections.
C
C  To obtain the executable file 'material.exe', compile and link the
C  source files 'material.f', 'penelope.f', and 'rita.f'. The file
C  'material.exe' must be placed in the directory 'pendbase', which
C  contains the subdirectory 'pdfiles' with the database files.
C
C  NOTE: In the output file and in the simulation program, lengths are
C  given in cm and energies in eV. Consequently, total cross sections
C  are in cm**2, stopping powers in eV/cm, etc. However, macroscopic
C  cross sections listed in the input/output files are expressed in
C  mass-thickness units (mtu); 1 mtu = 1 g/cm**2.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER*4 (I-N)
      CHARACTER MFNAME*20
      MFNAME='null'
      CALL PEMATW(0,MFNAME)
      END
*/

#include "materialCreator.hh"

namespace penred{

  namespace penMaterialCreator{

    constexpr const std::array<const char*, 280> PenelopeMats::names;

    constexpr const char materialCreator::LASYMB[99][3];
    constexpr const double materialCreator::ATW[99];
    constexpr const double materialCreator::EPX[99];
    constexpr const double materialCreator::RSCR[99];
    constexpr const double materialCreator::ETA[99];

    //Errors
    void materialCreator::ErrorFunction (const int NERROR)
    {

      IRETRN = NERROR;
      switch(NERROR){
      case 0: break;
      case 900:
	strcpy (REASON,
		"Fatal Error reading input: Bad value.");
	break;
      case 901:
	strcpy (REASON,
		"Fatal Error missing data base file.");
	break;
      case 1001:
	strcpy (REASON,
		"Fatal Error in PEINIT: Electron absorption energy less than 50 eV.");
	break;
      case 1002:
	strcpy (REASON,
		"Fatal Error in PEINIT: Photon absorption energy less than 50 eV.");
	break;
      case 1003:
	strcpy (REASON,
		"Fatal Error in PEINIT: Positron absorption energy less than 50 eV.");
	break;
      case 1004:
	strcpy (REASON,
		"Fatal Error in PEINIT: The energy interval is too narrow");
	break;
      case 1005:
	strcpy (REASON,
		"Fatal Error in PEINIT: Too many materials. Edit 'penelope.cpp' and change MAXMAT parameter");
	break;
      case 1006:
	strcpy (REASON,
		"Fatal Error in PEINIT: The material data file could not be opened");
	break;
      case 1007:
	strcpy (REASON,
		"Fatal Error in EGRID: The energy interval is too narrow");
	break;
      case 1008:
	strcpy (REASON, "Fatal Error in PEMATR. Too many materials");
	break;
      case 1009:
	strcpy (REASON, "Fatal Error in PEMATR. Corrupt material data file");
	break;
      case 1010:
	strcpy (REASON,
		"Fatal Error in PEMATR. Too many elements in the material composition. The maximum number of elements is 30");
	break;
      case 1011:
	strcpy (REASON, "Fatal Error in PEMATR. Too many oscillators.");
	break;
      case 1012:
	strcpy (REASON, "Fatal Error in PEMATR. Inconsistent oscillator data.");
	break;
      case 1013:
	strcpy (REASON, "Fatal Error in PEMATR. Too many shells");
	break;
      case 1014:
	strcpy (REASON, "Fatal Error in PEMATR. Too many data points (1).");
	break;
      case 1015:
	strcpy (REASON, "Fatal Error in PEMATR. PHMART. No outer shells?");
	break;
      case 1016:
	strcpy (REASON, "Fatal Error in PEMATR. PHMART. No outer shells?");
	break;
      case 1017:
	strcpy (REASON, "Fatal Error in PEMATR. Too many data points (2).");
	break;
      case 1018:
	strcpy (REASON, "Fatal Error in PEMATR. Corrupt material data file.");
	break;
      case 1101:
	strcpy (REASON,
		"Fatal Error in PEMATW. This element has been declared twice.");
	break;
      case 1102:
	strcpy (REASON,
		"Fatal Error in PEMATW. Fractions by weight are too small.");
	break;
      case 1103:
	strcpy (REASON,
		"Fatal Error in PEMATW. This element has been declared twice.");
	break;
      case 1104:
	strcpy (REASON,
		"Fatal Error in PEMATW. The allowed material ID numbers are 1-300.");
	break;
      case 1105:
	strcpy (REASON,
		"Fatal Error in PEMATW. NELEM cannot be larger than 30.");
	break;
      case 1106:
	strcpy (REASON, "Fatal Error in PEMATW. NELEM must be positive.");
	break;
      case 1107:
	strcpy (REASON,
		"Fatal Error in PEMATW. Abnormal termination of file ''pdcompos.pen''.");
	break;
      case 1108:
	strcpy (REASON, "Fatal Error in PEMATW. Wrong atomic number.");
	break;
      case 1109:
	strcpy (REASON,
		"Fatal Error in PEMATW. STF (atoms/molecule) must be positive.");
	break;
      case 1110:
	strcpy (REASON,
		"Fatal Error in PEMATW. Element has been declared twice.");
	break;
      case 1111:
	strcpy (REASON, "Fatal Error in PEMATW. The density must be positive.");
	break;
      case 1112:
	strcpy (REASON, "Fatal Error in PEMATW. Too many shells.");
	break;
      case 1113:
	strcpy (REASON, "Fatal Error in PEMATW. Wrong shell number.");
	break;
      case 1114:
	strcpy (REASON, "Fatal Error in PEMATW. Unbalanced charges (element).");
	break;
      case 1115:
	strcpy (REASON,
		"Fatal Error in PEMATW. Too many oscillators. The parameter NOM should be increased.");
	break;
      case 1116:
	strcpy (REASON,
		"Fatal Error in PEMATW. Unbalanced charges (compound).");
	break;
      case 1117:
	strcpy (REASON, "Fatal Error in PEMATW. FP is too large.");
	break;
      case 1118:
	strcpy (REASON,
		"Fatal Error in PEMATW. Inconsistent oscillator strength data.");
	break;
      case 1119:
	strcpy (REASON,
		"Fatal Error in PEMATW. Inconsistent oscillator-strength data.");
	break;
      case 1120:
	strcpy (REASON,
		"Fatal Error in PEMATW. Inconsistent oscillator-strength data (2).");
	break;
      case 1121:
	strcpy (REASON,
		"Fatal Error in PEMATW. Error in grouping the Compton profiles.");
	break;
      case 1201:
	strcpy (REASON, "Fatal Error in START. E out of range.");
	break;
      case 1202:
	strcpy (REASON, "Fatal Error in KNOCK: Incorrect particle type.");
	break;
      case 1203:
	strcpy (REASON,
		"Fatal Error in STORES: Not enough storage for secondary positrons.");
	break;
      case 1204:
	strcpy (REASON, "Fatal Error in KNOCKF: Incorrect particle type.");
	break;
      case 1205:
	strcpy (REASON, "Fatal Error in JUMPW: The particle is not a photon.");
	break;
      case 1206:
	strcpy (REASON, "Fatal Error in KNOCKW: The particle is not a photon.");
	break;
      case 1301:
	strcpy (REASON, "Fatal Error in EELa0. Negative total cross section.");
	break;
      case 1302:
	strcpy (REASON, "Fatal Error in EELa0. Inconsistent arguments.");
	break;
      case 1303:
	strcpy (REASON, "Fatal Error in EELaW. Wrong file.");
	break;
      case 1304:
	strcpy (REASON, "Fatal Error in ESIaR. Corrupt material data file.");
	break;
      case 1305:
	strcpy (REASON, "Fatal Error in ESIaR. Too many data points.");
	break;
      case 1306:
	strcpy (REASON, "Fatal Error in ESIaR. Too many shells.");
	break;
      case 1307:
	strcpy (REASON, "Fatal Error in ESIaR. Insufficient memory storage.");
	break;
      case 1308:
	strcpy (REASON, "Fatal Error in ESIaW. Corrupt data file.");
	break;
      case 1309:
	strcpy (REASON, "Fatal Error in ESIaW. Too many shells.");
	break;
      case 1310:
	strcpy (REASON, "Fatal Error in PSIaR. Corrupt material data file.");
	break;
      case 1311:
	strcpy (REASON, "Fatal Error in PSIaR. Too many data points.");
	break;
      case 1312:
	strcpy (REASON, "Fatal Error in PSIaR. Too many shells.");
	break;
      case 1313:
	strcpy (REASON, "Fatal Error in PSIaR. Insufficient memory storage.");
	break;
      case 1314:
	strcpy (REASON, "Fatal Error in PSIaW. Corrupt data file.");
	break;
      case 1315:
	strcpy (REASON, "Fatal Error in PSIaW. Too many shells.");
	break;
      case 1316:
	strcpy (REASON, "Fatal Error in EBRaR. EBRR. Inconsistent format.");
	break;
      case 1317:
	strcpy (REASON, "Fatal Error in EBRW. Corrupt file.");
	break;
      case 1318:
	strcpy (REASON, "Fatal Error in EBRW. Check the bremss database file.");
	break;
      case 1319:
	strcpy (REASON, "Fatal Error in RLMOM. Error code 0.");
	break;
      case 1320:
	strcpy (REASON, "Fatal Error in RLMOM. Error code 1.");
	break;
      case 1321:
	strcpy (REASON, "Fatal Error in RLMOM. Error code 2.");
	break;
      case 1322:
	strcpy (REASON, "Fatal Error in RLMOM. Error code 3.");
	break;
      case 1323:
	strcpy (REASON, "Fatal Error in RLMOM. Error code 4.");
	break;
      case 1324:
	strcpy (REASON, "Fatal Error in BRAR. Inconsistent data.");
	break;
      case 1325:
	strcpy (REASON,
		"Fatal Error in BRAR. Corrupt data file (pdbrang.p08).");
	break;
      case 1326:
	strcpy (REASON,
		"Fatal Error in BRAW. Corrupt data file (pdbrang.p08).");
	break;
      case 1327:
	strcpy (REASON, "Fatal Error in GRAaR. RITA initialisation error.");
	break;
      case 1328:
	strcpy (REASON, "Fatal Error in GRAaR. RITA initialisation error.");
	break;
      case 1329:
	strcpy (REASON,
		"Fatal Error in GRAaR. RITA interpolation error is too large.");
	break;
      case 1330:
	strcpy (REASON, "Fatal Error in GRAaW. Corrupt file.");
	break;
      case 1331:
	strcpy (REASON, "Fatal Error in GRAaW. Corrupt file.");
	break;
      case 1332:
	strcpy (REASON, "Fatal Error in GRAaW. Corrupt file.");
	break;
      case 1333:
	strcpy (REASON, "Fatal Error in GPHaR. Corrupt material data file.");
	break;
      case 1334:
	strcpy (REASON, "Fatal Error in GPHaR. Too many data points.");
	break;
      case 1335:
	strcpy (REASON, "Fatal Error in GPHaR. Too many shells.");
	break;
      case 1336:
	strcpy (REASON, "Fatal Error in GPHaR. Insufficient memory storage.");
	break;
      case 1337:
	strcpy (REASON, "Fatal Error in GPHaW. Too many energies.");
	break;
      case 1338:
	strcpy (REASON, "Fatal Error in GPHaW. Corrupt file.");
	break;
      case 1339:
	strcpy (REASON, "Fatal Error in GPHaW. Too many shells.");
	break;
      case 1340:
	strcpy (REASON, "Fatal Error in GPPaW. Corrupt file.");
	break;
      case 1341:
	strcpy (REASON, "Fatal Error in RELAXR. NTRAN needs to be increased.");
	break;
      case 1342:
	strcpy (REASON, "Fatal Error in RELAXR. Insufficient memory storage.");
	break;
      case 1343:
	strcpy (REASON,
		"Fatal Error in RELAXR. Negative transition probability?");
	break;
      case 1344:
	strcpy (REASON, "Fatal Error in RELAXR. Rounding error is too large.");
	break;
      case 1345:
	strcpy (REASON, "Fatal Error in RELAXW. The element is not loaded.");
	break;
      case 1346:
	strcpy (REASON, "Fatal Error in RELAXW. NM needs to be increased.");
	break;
      case 1347:
	strcpy (REASON,
		"Fatal Error in EELdW. Electron cross section data are corrupt.");
	break;
      case 1348:
	strcpy (REASON,
		"Fatal Error in EELdW. Positron cross section data are corrupt.");
	break;
      case 1349:
	strcpy (REASON,
		"Fatal Error in EELdR. Error reading electron elastic DCS data.");
	break;
      case 1350:
	strcpy (REASON,
		"Fatal Error in EELdR. Electron cross section data are corrupt.");
	break;
      case 1351:
	strcpy (REASON,
		"Fatal Error in EELdR. Error reading positron elastic DCS data.");
	break;
      case 1352:
	strcpy (REASON,
		"Fatal Error in EELdR. Positron cross section data are corrupt.");
	break;
      case 1353:
	strcpy (REASON, "Fatal Error in EELdR. RITA initialisation error.");
	break;
      case 1354:
	strcpy (REASON, "Fatal Error in EELdR. RITA initialisation error.");
	break;
      case 1355:
	strcpy (REASON, "Fatal Error in ELINIT. Corrupt data file.");
	break;
      case 1356:
	strcpy (REASON, "Fatal Error in ELINIT. Corrupt data file.");
	break;
      case 1357:
	strcpy (REASON, "Fatal Error in DCSEL. Energy out of range.");
	break;
      case 1401:
	strcpy (REASON, "Fatal Error in IRND0. Negative point probability.");
	break;
      case 1402:
	strcpy (REASON, "Fatal Error in RITAI0: N must be larger than 8.");
	break;
      case 1403:
	strcpy (REASON, "Fatal Error in RITAI0: N must be less than NM=512.");
	break;
      case 1404:
	strcpy (REASON,
		"Fatal Error in RITAI0: XLOW must be larger than XHIGH.");
	break;
      case 1405:
	strcpy (REASON, "Fatal Error in RITAI0: XLOW and NU are negative.");
	break;
      case 1901:
	strcpy (REASON,
		"Fatal Error in MERGE2. Increase the value of the parameter NP.");
	break;
      case 1902:
	strcpy (REASON,
		"Fatal Error in MERGE2. Increase the value of the parameter NP.");
	break;
      case 1903:
	strcpy (REASON,
		"Fatal Error in SORT2. Increase the value of the parameter NP.");
	break;
      case 1904:
	strcpy (REASON, "Fatal Error in SPLINE: N is less than 4.");
	break;
      case 1905:
	strcpy (REASON,
		"Fatal Error in SPLINE: X values not in increasing order.");
	break;
      case 1906:
	strcpy (REASON, "Fatal Error in SINTEG. Integral limits out of range.");
	break;
      case 1907:
	strcpy (REASON, "Fatal Error int SLAG6: too few data points.");
	break;
      case 1908:
	strcpy (REASON, "Fatal Error in RMOMX. Error code 1.");
	break;
      case 1909:
	strcpy (REASON, "Fatal Error in RMOMX. Error code 2.");
	break;
      case 1910:
	strcpy (REASON, "Fatal Error in RMOMX. Error code 3.");
	break;
      case 1911:
	strcpy (REASON, "Fatal Error in RMOMX. Error code 4.");
	break;
      case 1912:
	strcpy (REASON, "Fatal Error in RNDG30: initialisation error (1).");
	break;
      case 1913:
	strcpy (REASON, "Fatal Error in RNDG30: initialisation error (2).");
	break;
      case 2001:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The input and output units must be different.");
	break;
      case 2002:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2003:
	strcpy (REASON, "Fatal Error in GEOMIN: Incorrect label format.");
	break;
      case 2004:
	strcpy (REASON, "Fatal Error in GEOMIN: Same label for two surfaces.");
	break;
      case 2005:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NS must be increased.");
	break;
      case 2006:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Incorrect format of surface indices.");
	break;
      case 2007:
	strcpy (REASON, "Fatal Error in GEOMIN: Incorrect surface indices.");
	break;
      case 2008:
	strcpy (REASON,
		"Fatal Error in GEOMIN: NPINP is too small (check PARINP).");
	break;
      case 2009:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Scale factor less than 1.0E-15.)");
	break;
      case 2010:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Scale factor less than 1.0E-15.)");
	break;
      case 2011:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Scale factor less than 1.0E-15.)");
	break;
      case 2012:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2013:
	strcpy (REASON,
		"Fatal Error in GEOMIN: NPINP is too small (check PARINP)");
	break;
      case 2014:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2015:
	strcpy (REASON,
		"Fatal Error in GEOMIN: NPINP is too small (check PARINP)");
	break;
      case 2016:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2017:
	strcpy (REASON, "Fatal Error in GEOMIN: Incorrect label format.");
	break;
      case 2018:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Same label for two bodies (or modules).");
	break;
      case 2019:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NB must be increased.");
	break;
      case 2020:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Incorrect material definition line.");
	break;
      case 2021:
	strcpy (REASON, "Fatal Error in GEOMIN: Undefined surface label.");
	break;
      case 2022:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The last limiting surface has been defined twice.");
	break;
      case 2023:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The number of limiting surfaces is too large.");
	break;
      case 2024:
	strcpy (REASON, "Fatal Error in GEOMIN: Check side pointer value.");
	break;
      case 2025:
	strcpy (REASON, "Fatal Error in GEOMIN: Undefined body label.");
	break;
      case 2026:
	strcpy (REASON, "Fatal Error in GEOMIN: This body is a module.");
	break;
      case 2027:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The number of limiting surfaces is too large.");
	break;
      case 2028:
	strcpy (REASON, "Fatal Error in GEOMIN: Undefined body label.");
	break;
      case 2029:
	strcpy (REASON, "Fatal Error in GEOMIN: This module is a body.");
	break;
      case 2030:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The number of limiting surfaces is too large.");
	break;
      case 2031:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2032:
	strcpy (REASON, "Fatal Error in GEOMIN: Incorrect label format.");
	break;
      case 2033:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Same label for two bodies (or modules).");
	break;
      case 2034:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NB must be increased.");
	break;
      case 2035:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Incorrect material definition line.");
	break;
      case 2036:
	strcpy (REASON, "Fatal Error in GEOMIN: Undefined surface label.");
	break;
      case 2037:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The last limiting surface has been defined twice.");
	break;
      case 2038:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The number of limiting surfaces is too large.");
	break;
      case 2039:
	strcpy (REASON, "Fatal Error in GEOMIN: Check side pointer value.");
	break;
      case 2040:
	strcpy (REASON, "Fatal Error in GEOMIN: Undefined body label.");
	break;
      case 2041:
	strcpy (REASON, "Fatal Error in GEOMIN: This body is a module.");
	break;
      case 2042:
	strcpy (REASON,
		"Fatal Error in GEOMIN: You are trying to assign two mothers to the last body.");
	break;
      case 2043:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The number of limiting surfaces is too large.");
	break;
      case 2044:
	strcpy (REASON, "Fatal Error in GEOMIN: Undefined body label.");
	break;
      case 2045:
	strcpy (REASON, "Fatal Error in GEOMIN: This module is a body.");
	break;
      case 2046:
	strcpy (REASON,
		"Fatal Error in GEOMIN: You are trying to assign two mothers to the last module.");
	break;
      case 2047:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The number of limiting surfaces is too large.");
	break;
      case 2048:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2049:
	strcpy (REASON,
		"Fatal Error in GEOMIN: NPINP is too small (check PARINP)");
	break;
      case 2050:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2051:
	strcpy (REASON, "Fatal Error in GEOMIN: Incorrect label format.");
	break;
      case 2052:
	strcpy (REASON,
		"Fatal Error in GEOMIN: Same label for two bodies or modules.");
	break;
      case 2053:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The cloned object must be a module.");
	break;
      case 2054:
	strcpy (REASON, "Fatal Error in GEOMIN: This module is not defined.");
	break;
      case 2055:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The selected object is a body.");
	break;
      case 2056:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The label does not correspond to a module.");
	break;
      case 2057:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2058:
	strcpy (REASON,
		"Fatal Error in GEOMIN: NPINP is too small (check PARINP)");
	break;
      case 2059:
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2060:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NS must be increased.");
	break;
      case 2061:
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NB must be increased.");
	break;
      case 2062:
	
	strcpy (REASON, "Fatal Error in GEOMIN: Something wrong...");
	break;
      case 2063:
	
	strcpy (REASON,
		"Fatal Error in GEOMIN: The limiting body or module is not yet defined");
	break;
      case 2064:
	
	strcpy (REASON,
		"Fatal Error in GEOMIN: The limiting body or module is not yet defined");
	break;
      case 2065:
	
	strcpy (REASON, "Fatal Error in GEOMIN: Incorrect label format.");
	break;
      case 2066:
	
	strcpy (REASON, "Fatal Error in GEOMIN: What do you mean?");
	break;
      case 2067:
	
	strcpy (REASON, "Fatal Error in GEOMIN: Too many include levels.");
	break;
      case 2068:
	
	strcpy (REASON, "Fatal Error in GEOMIN: Too many include levels.");
	break;
      case 2069:
	
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NB must be increased.");
	break;
      case 2070:
	
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NS must be increased.");
	break;
      case 2071:
	
	strcpy (REASON,
		"Fatal Error in GEOMIN: The parameter NXG is too small.");
	break;
      case 2072:
	
	strcpy (REASON,
		"Fatal Error in GEOMIN: Possibly unresolved body or module.");
	break;
      case 2073:
	
	strcpy (REASON, "Fatal Error in GEOMIN: Inconsistent body label.");
	break;
      case 2074:
	
	strcpy (REASON, "Fatal Error in GEOMIN: Inconsistent side pointers.");
	break;
      case 2075:
	
	strcpy (REASON, "Fatal Error in GEOMIN: Wrong input format.");
	break;
	//ERRORS PENEASY
      case 146:
	
	strcpy (REASON,
		"samplePosition:ERROR: sampling source efficiency is lower than 0.1%%.");
	break;
      case 147:
	
	strcpy (REASON, "iniconfig:ERROR: incorrect section header;");
	break;
      case 148:
	
	strcpy (REASON, "iniconfig:ERROR: too many requested histories");
	break;
      case 149:
	
	strcpy (REASON, "iniconfig:ERROR: refresh interval must be positive.");
	break;
      case 150:
	
	strcpy (REASON, "iniconfig:ERROR: Invalid RNG seeds.");
	break;
      case 151:
	
	strcpy (REASON, "iniconfig:ERROR: unable to open seeds file.");
	break;
      case 152:
	
	strcpy (REASON, "iniconfig:ERROR: unable to open restart file.");
	break;
      case 153:
	
	strcpy (REASON,
		"iniconfig:ERROR: interval between dumps must be positive.");
	break;
      case 154:
	
	strcpy (REASON, "iniconfig:ERROR: End-Of-Section mark not found");
	break;
      case 155:
	
	strcpy (REASON, "inigeo:ERROR: incorrect section header");
	break;
      case 156:
	
	strcpy (REASON, "inigeo:ERROR: unable to open quadrics file");
	break;
      case 157:
	
	strcpy (REASON,
		"inigeo:ERROR: too many materials; enlarge MAXMAT parameter and recompile.");
	break;
      case 158:
	
	strcpy (REASON, "inigeo:ERROR: no geometry defined.");
	break;
      case 159:
	
	strcpy (REASON, "inigeo:ERROR: End-Of-Section mark not found");
	break;
      case 160:
	
	strcpy (REASON, "inipen:ERROR: incorrect section header;");
	break;
      case 161:
	
	strcpy (REASON, "inipen:ERROR: Max number of materials exceeded");
	break;
      case 162:
	
	strcpy (REASON, "inipen:ERROR: Invalid MAT index");
	break;
      case 163:
	
	strcpy (REASON, "inipen:ERROR: incomplete list of parameters for MAT");
	break;
      case 164:
	
	strcpy (REASON,
		"inipen:ERROR: DSMAX must be larger than zero even if electrons are not transported.");
	break;
      case 165:
	
	strcpy (REASON,
		"inipen:ERROR: There are more materials declared in the geometry file than defined in the config file.");
	break;
      case 166:
	
	strcpy (REASON, "inipen:ERROR: End-Of-Section mark not found");
	break;
      case 167:
	
	strcpy (REASON, "getline:ERROR: unable to read line.");
	break;
      case 168:
	
	strcpy (REASON, "seeki:ERROR: value outside range, xc>x(n):");
	break;
      case 169:
	
	strcpy (REASON, "seeki:ERROR: value outside range, xc<x(1):");
	break;
      case 170:
	
	strcpy (REASON, "BIGSinisrc:ERROR: incorrect section header;");
	break;
      case 171:
	
	strcpy (REASON, "BIGSinisrc:ERROR: Unable to find End-Of-Section");
	break;
      case 172:
	
	strcpy (REASON, "BIGSinisrc:ERROR: expecting to find ON or OFF");
	break;
      case 173:
	
	strcpy (REASON, "BIGSinisrc:ERROR: invalid particle type");
	break;
      case 174:
	
	strcpy (REASON,
		"BIGSinisrc:ERROR: invalid polarization switch, should be 0 or 1");
	break;
      case 175:
	
	strcpy (REASON,
		"BIGSinisrc:ERROR: vector P={P1,P2,P3} must be P^2 <= 1");
	break;
      case 176:
	
	strcpy (REASON, "BIGSinisrc:ERROR: null direction.");
	break;
      case 177:
	
	strcpy (REASON, "BIGSinisrc:ERROR: theta1 is less than theta0.");
	break;
      case 178:
	
	strcpy (REASON, "BIGSinisrc:ERROR: invalid interval.");
	break;
      case 179:
	
	strcpy (REASON, "BIGSinisrc:ERROR: Invalid entry. Must be 0 or 1.");
	break;
      case 180:
	
	strcpy (REASON, "BIGSinisrc:ERROR: unable to open spectrum file.");
	break;
      case 181:
	
	strcpy (REASON, "BIGSinisrc:ERROR: invalid entry");
	break;
      case 182:
	
	strcpy (REASON, "BIGSinisrc:ERROR: negative energy");
	break;
      case 183:
	
	strcpy (REASON, "BIGSinisrc:ERROR: decreasing energy");
	break;
      case 184:
	
	strcpy (REASON, "BIGSinisrc:ERROR: too many bins in spectrum;");
	strcpy (REASON, "              enlarge NEMAX");
	break;
      case 185:
	
	strcpy (REASON, "BIGSinisrc:ERROR: at least 1 bin must be defined");
	break;
      case 186:
	
	strcpy (REASON, "BIGSinisrc:ERROR: all probabilities are zero.");
	break;
      case 187:
	
	strcpy (REASON, "BIGSinisrc:ERROR: End-Of-Section mark not found");
	break;
      case 188:
	
	strcpy (REASON,
		"inisource:ERROR: PSF source ON is incompatible with other sources ON.");
	break;
      case 189:
	
	strcpy (REASON, "EDPinitally:ERROR: incorrect section header;");
	break;
      case 190:
	
	strcpy (REASON,
		"EDPinitally:ERROR: Unable to find End-Of-Section mark");
	break;
      case 191:
	
	strcpy (REASON, "EDPinitally:ERROR: expecting to find ON or OFF");
	break;
      case 192:
	
	strcpy (REASON, "iniforce:ERROR: incorrect section header");
	break;
      case 193:
	
	strcpy (REASON, "iniforce:ERROR: Unable to find End-Of-Section mark");
	break;
      case 194:
	
	strcpy (REASON, "iniforce:ERROR: expecting to find ON or OFF");
	break;
      case 195:
	
	strcpy (REASON,
		"iniforce:ERROR: unable to read line containing: MAT,KPAR,ICOL,forcing");
	break;
      case 196:
	
	strcpy (REASON, "iniforce:ERROR: invalid MAT");
	break;
      case 197:
	
	strcpy (REASON, "iniforce:ERROR: proton forcing not implemented yet");
	break;
      case 198:
	
	strcpy (REASON, "iniforce:ERROR: KPAR must be in [1,3]");
	break;
      case 199:
	
	strcpy (REASON, "iniforce:ERROR: ICOL must be in [0,8]");
	break;
      case 200:
	
	strcpy (REASON, "iniforce:ERROR: FORCING must not be < 1");
	break;
      case 201:
	
	strcpy (REASON, "iniforce:ERROR: End-Of-Section mark not found");
	break;
      case 202:
	
	strcpy (REASON, "inisplit:ERROR: incorrect section header");
	break;
      case 203:
	
	strcpy (REASON, "inisplit:ERROR: Unable to find End-Of-Section mark");
	break;
      case 204:
	
	strcpy (REASON, "inisplit:ERROR: expecting to find ON or OFF");
	break;
      case 205:
	
	strcpy (REASON, "inisplit:ERROR: Min weight must be >0.");
	break;
      case 206:
	
	strcpy (REASON,
		"inisplit:ERROR: Photon polarization is active. Only simple splitting can be used");
	break;
      case 207:
	
	strcpy (REASON, "inisplit:ERROR: Invalid factor");
	break;
      case 208:
	
	strcpy (REASON, "inisplit:ERROR: Invalid sign");
	break;
      case 209:
	
	strcpy (REASON, "inisplit:ERROR: Invalid sector");
	break;
      case 210:
	
	strcpy (REASON, "inisplit:ERROR: End-Of-Section mark not found");
	break;
      case 211:
	
	strcpy (REASON, "splitting:ERROR: internal error");
	break;
      case 212:
	
	strcpy (REASON, "inirussia:ERROR: incorrect section header");
	break;
      case 213:
	
	strcpy (REASON, "inirussia:ERROR: Unable to find End-Of-Section mark");
	break;
      case 214:
	
	strcpy (REASON, "inirussia:ERROR: expecting to find ON or OFF");
	break;
      case 215:
	
	strcpy (REASON, "inirussia:ERROR: Invalid survival probability");
	break;
      case 216:
	
	strcpy (REASON, "inirussia:ERROR: End-Of-Section mark not found");
	break;
      case 217:
	
	strcpy (REASON, "SDDinitially:ERROR: incorrect section header");
	break;
      case 218:
	
	strcpy (REASON, "inivox:ERROR: invalid transparent mat.");
	break;
      case 219:
	
	strcpy (REASON,
		"inivox:ERROR: there must be ONE body with transparent material.");
	break;
      case 220:
	
	strcpy (REASON,
		"inivox:ERROR: granularity must be between 2 and maxGranul");
	break;
      case 221:
	
	strcpy (REASON,
		"inivox:ERROR: internal inconsistency; expecting vacuum");
	break;
      case 222:
	
	strcpy (REASON, "readvox:ERROR: unable to open voxels file");
	break;
      case 223:
	
	strcpy (REASON, "getvoxline:ERROR: unable to read vox file");
	break;
      case 224:
	
	strcpy (REASON, "readvox:ERROR: incorrect section header");
	break;
      case 225:
	
	strcpy (REASON, "readvox:ERROR: invalid no. voxels.");
	break;
      case 226:
	
	strcpy (REASON, "readvox:ERROR: No. voxels exceeds nvoxmax.");
	break;
      case 227:
	
	strcpy (REASON, "readvox:ERROR: not enough memory.");
	break;
      case 228:
	
	strcpy (REASON, "inimassvox:ERROR: not enough memory for temp arrays.");
	break;
      case 229:
	
	strcpy (REASON, "inimassvox:ERROR: not enough memory.");
	break;
      case 230:
	
	strcpy (REASON, "readvox:ERROR: voxel side too small.");
	break;
      case 231:
	
	strcpy (REASON, "readvox:ERROR: VBB too large.");
	break;
      case 232:
	
	strcpy (REASON,
		"readvox:ERROR: column numbers must be between 1 and maxCol.");
	break;
      case 233:
	
	strcpy (REASON, "readvox:ERROR: End-Of-Section mark not found.");
	break;
      case 234:
	
	strcpy (REASON, "readvox:ERROR: invalid entry at line line.");
	break;
      case 235:
	
	strcpy (REASON, "readvox:ERROR: Line should be blank, line line.");
	break;
      case 236:
	
	strcpy (REASON, "writeMassvox:ERROR: unable to open file to write.");
	break;
      case 237:
	
	strcpy (REASON,
		"SDDinitally:ERROR: Unable to find End-Of-Section mark.");
	break;
      case 238:
	
	strcpy (REASON, "SDDinitally:ERROR: expecting to find ON or OFF.");
	break;
      case 239:
	
	strcpy (REASON, "SDDinitally:ERROR: invalid entry.");
	break;
      case 240:
	
	strcpy (REASON, "SDDinitally:ERROR: Zero bins defined.");
	break;
      case 241:
	
	strcpy (REASON,
		"SDDinitally:ERROR: nbinmax max no. of megabins exceeded.");
	break;
      case 242:
	
	strcpy (REASON, "SDDinitally:ERROR: expecting 1,0 or -1.");
	break;
      case 243:
	
	strcpy (REASON, "SDDinitally:ERROR: not enough memory.");
	break;
      case 244:
	
	strcpy (REASON, "SDDinitally:ERROR: End-Of-Section mark not found.");
	break;
      case 245:
	
	strcpy (REASON, "PSFinitally:ERROR: incorrect section header.");
	break;
      case 246:
	
	strcpy (REASON,
		"PSFinitally:ERROR: Unable to find End-Of-Section mark.");
	break;
      case 247:
	
	strcpy (REASON, "PSFinitally:ERROR: expecting to find ON or OFF.");
	break;
      case 248:
	
	strcpy (REASON,
		"PSFinitally:ERROR: IAEA PSF format requested but not available.");
	break;
      case 249:
	
	strcpy (REASON, "PSFinitally:ERROR: PSF format must be 0 or 1.");
	break;
      case 250:
	
	strcpy (REASON,
		"PSFinitally:ERROR: detection material out of range: 1,MAXMAT.");
	break;
      case 251:
	
	strcpy (REASON,
		"PSFinitally:ERROR: PSF detection material must be a perfect absorbent.");
	break;
      case 252:
	
	strcpy (REASON, "PSFinitally:ERROR: Could not append PSF.");
	break;
      case 253:
	
	strcpy (REASON, "PSFinitally:ERROR: End-Of-Section mark not found.");
	break;
      case 254:
	
	strcpy (REASON, "IAEAiniwrite:ERROR: Unable to open PSF.");
	break;
      case 255:
	
	strcpy (REASON,
		"IAEAiniwrite:ERROR: Could not open PSF to append; make sure the file exists and it is accessible.");
	break;
      case 256:
	
	strcpy (REASON, "IAEAiniwrite:ERROR: Unable to set an extra variable.");
	break;
      case 257:
	
	strcpy (REASON,
		"IAEAiniwrite:internalERROR: Extra variable index is out of range.");
	break;
      case 258:
	
	strcpy (REASON,
		"IAEAiniwrite:internalERROR: Extra variable type is out of range.");
	break;
      case 259:
	
	strcpy (REASON,
		"IAEAiniwrite:internalERROR: Undefined error while setting an extra variable.");
	break;
      case 260:
	
	strcpy (REASON, "IAEAwrite:ERROR: protons not implemented.");
	break;
      case 261:
	
	strcpy (REASON, "IAEAwrite:ERROR: Invalid KPAR.");
	break;
      case 262:
	
	strcpy (REASON, "IAEAwrite:ERROR: Unable to write particle.");
	break;
      case 263:
	
	strcpy (REASON, "VDDinitially:ERROR: incorrect section header");
	break;
      case 264:
	
	strcpy (REASON,
		"VDDinitially:ERROR: voxel dose tally is ON but no voxelized geometry has been defined.");
	break;
      case 265:
	
	strcpy (REASON,
		"VDDinitally:ERROR: Unable to find End-Of-Section mark.");
	break;
      case 266:
	
	strcpy (REASON, "VDDinitally:ERROR: expecting to find ON or OFF.");
	break;
      case 267:
	
	strcpy (REASON, "VDDinitally:ERROR: invalid ROI.");
	break;
      case 268:
	
	strcpy (REASON, "VDDinitally:ERROR: expecting 1,0 or -1.");
	break;
      case 269:
	
	strcpy (REASON, "VDDinitally:ERROR: End-Of-Section mark not found.");
	break;
      case 270:
	
	strcpy (REASON, "VDDinitally:ERROR: not enough memory.");
	break;
      case 271:
	
	strcpy (REASON, "CDDinitally:ERROR: incorrect section header.");
	break;
      case 272:
	
	strcpy (REASON,
		"CDDinitally:ERROR: Unable to find End-Of-Section mark.");
	break;
      case 273:
	
	strcpy (REASON, "CDDinitally:ERROR: expecting to find ON or OFF.");
	break;
      case 274:
	
	strcpy (REASON, "CDDinitally:ERROR: invalid entry.");
	break;
      case 275:
	
	strcpy (REASON, "CDDinitally:ERROR: Too many bins.");
	break;
      case 276:
	
	strcpy (REASON, "CDDinitally:ERROR: End-Of-Section mark not found.");
	break;
      case 277:
	
	strcpy (REASON, "PSFinisrc:ERROR: incorrect section header.");
	break;
      case 278:
	
	strcpy (REASON, "PSFinisrc:ERROR: Unable to find End-Of-Section mark.");
	break;
      case 279:
	
	strcpy (REASON, "PSFinisrc:ERROR: expecting to find ON or OFF.");
	break;
      case 280:
	
	strcpy (REASON,
		"PSFinisrc:ERROR: IAEA PSF format requested but not available.");
	break;
      case 281:
	
	strcpy (REASON, "PSFinisrc:ERROR: PSF format must be 0 or 1.");
	break;
      case 282:
	
	strcpy (REASON, "PSFinisrc:ERROR: split < 1.");
	break;
      case 283:
	
	strcpy (REASON,
		"PSFinisrc:ERROR: invalid entry. VALIDATE field must be 0 or 1.");
	break;
      case 284:
	
	strcpy (REASON, "PSFinisrc:ERROR: cannot open the PSF.");
	break;
      case 285:
	
	strcpy (REASON,
		"PSFinisrc:ERROR: No. of histories in PSF exceeds nmax.");
	break;
      case 286:
	
	strcpy (REASON, "PSFinisrc:ERROR: invalid KPAR: at line:.");
	break;
      case 287:
	
	strcpy (REASON, "PSFinisrc:ERROR: invalid energy(eV): at line:.");
	break;
      case 288:
	
	strcpy (REASON,
		"PSFinisrc:ERROR: null vector direction found at line:.");
	break;
      case 289:
	
	strcpy (REASON,
		"PSFinisrc:ERROR: PSF end-of-file reached, not enough particles to initialize.");
	break;
      case 290:
	
	strcpy (REASON,
		"PSFinisrc:ERROR: Inconsistency found in PSF incremental history no.");
	break;
      case 291:
	
	strcpy (REASON, "PSFinisrc:ERROR: End-Of-Section mark not found.");
	break;
      case 292:
	
	strcpy (REASON, "getpar:ERROR: unable to read PSF line no.:.");
	break;
      case 293:
	
	strcpy (REASON, "getpar:ERROR: invalid or missing datum in PSF line:.");
	break;
      case 294:
	
	strcpy (REASON, "checkFormat:ERROR: cannot open the PSF.\n");
	break;
      case 295:
	
	strcpy (REASON, "ckeckFormat:ERROR: unable to read first PSF line.\n");
	break;
      case 296:
	
	strcpy (REASON, "checkFormat:ERROR: unable to identify PSF format.\n");
	break;
      case 297:
	
	strcpy (REASON, "getparIAEA:ERROR: unable to read particle no.:.\n");
	break;
      case 298:
	
	strcpy (REASON,
		"getparIAEA:ERROR: EOF reached when attempting to read particle no.:.\n");
	break;
      case 299:
	
	strcpy (REASON,
		"getparIAEA:ERROR: undefined error while attempting to read particle no.:.\n");
	break;
      case 300:
	
	strcpy (REASON,
		"getparIAEA:ERROR: Invalid KPAR: found at particle no.:\n");
	break;
      case 301:
	
	strcpy (REASON, "IAEAiniread:ERROR: unable to open PSF.\n");
	break;
      case 302:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: Unable to get the total number of particles.\n");
	break;
      case 303:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: Unable to get the total number of histories.\n");
	break;
      case 304:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: No. of histories in PSF exceeds nmax.\n");
	break;
      case 305:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: Unable to get constant variables.\n");
	break;
      case 306:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: Variable constant index out of range.\n");
	break;
      case 307:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: More than xtraMax extra int or real variables in PSF.\n");
	break;
      case 308:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: Unable to check file size and byte order of the PSF.\n");
	break;
      case 309:
	
	strcpy (REASON, "IAEAiniread:ERROR: The function fseek fails.\n");
	break;
      case 310:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: File size inconsistent with header checksum.\n");
	break;
      case 311:
	
	strcpy (REASON, "IAEAiniread:ERROR: There is a byte order mismatch.\n");
	break;
      case 312:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: There is a file size and byte order mismatch.\n");
	break;
      case 313:
	
	strcpy (REASON, "IAEAiniread:ERROR: Unidentified error code.\n");
	break;
      case 314:
	
	strcpy (REASON, "IAEAiniread:internalERROR: invalid KPAR.\n");
	break;
      case 315:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: energy out of range found in particle no.:.\n");
	break;
      case 316:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: null direction vector found in particle no.:.\n");
	break;
      case 317:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: No. of particles inferred from PSF differs from that stated in header file.\n");
	break;
      case 318:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: No. of histories inferred from PSF is greater than that stated in header file.\n");
	break;
      case 319:
	
	strcpy (REASON, "IAEAiniread:ERROR: Unable to get maximum energy.\n");
	break;
      case 320:
	
	strcpy (REASON, "IAEAiniread:ERROR: unable to close PSF.\n");
	break;
      case 321:
	
	strcpy (REASON, "IAEAiniread:ERROR: unable to open PSF.\n");
	break;
      case 322:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: PSF end-of-file reached, not enough particles to initialize.\n");
	break;
      case 323:
	
	strcpy (REASON,
		"IAEAiniread:ERROR: Inconsistency found in PSF incremental history.\n");
	break;
      case 324:
	
	strcpy (REASON, "PSFinitally:ERROR: incorrect section header.\n");
	break;
      case 325:
	
	strcpy (REASON,
		"PSFinitally:ERROR: Unable to find End-Of-Section mark.\n");
	break;
      case 326:
	
	strcpy (REASON, "PSFinitally:ERROR: expecting to find ON or OFF.\n");
	break;
      case 327:
	
	strcpy (REASON,
		"PSFinitally:ERROR: IAEA PSF format requested but not available.\n");
	break;
      case 328:
	
	strcpy (REASON, "PSFinitally:ERROR: PSF format must be 0 or 1.\n");
	break;
      case 329:
	
	strcpy (REASON,
		"PSFinitally:ERROR: detection material out of range.\n");
	break;
      case 330:
	
	strcpy (REASON,
		"PSFinitally:ERROR: PSF detection material must be a perfect absorbent.\n");
	break;
      case 331:
	
	strcpy (REASON, "PSFinitally:ERROR: Could not append PSF.\n");
	break;
      case 332:
	
	strcpy (REASON, "PSFinitally:ERROR: End-Of-Section mark not found.\n");
	break;
      case 333:
	
	strcpy (REASON,
		"IAEAwriteReport:ERROR: unable to write no. of histories to header file.\n");
	break;
      case 334:
	
	strcpy (REASON,
		"IAEAwriteReport:ERROR: unable to update header file.\n");
	break;
      case 335:
	
	strcpy (REASON, "FTLinitally:ERROR: incorrect section header.\n");
	break;
      case 336:
	
	strcpy (REASON,
		"FTLinitally:ERROR: Unable to find End-Of-Section mark.\n");
	break;
      case 337:
	
	strcpy (REASON, "FTLinitally:ERROR: expecting to find ON or OFF.\n");
	break;
      case 338:
	
	strcpy (REASON, "FTLinitally:ERROR: Too many bins.\n");
	break;
      case 339:
	
	strcpy (REASON, "FTLinitally:ERROR: End-Of-Section mark not found.\n");
	break;
      case 340:
	
	strcpy (REASON, "PCSinitally:ERROR: incorrect section header.\n");
	break;
      case 341:
	
	strcpy (REASON,
		"PCSinitally:ERROR: Unable to find End-Of-Section mark.\n");
	break;
      case 342:
	
	strcpy (REASON, "PCSinitally:ERROR: expecting to find ON or OFF.\n");
	break;
      case 343:
	
	strcpy (REASON, "PCSinitally:ERROR: Too many bins.\n");
	break;
      case 344:
	
	strcpy (REASON, "PCSinitally:ERROR: End-Of-Section mark not found.\n");
	break;
      case 345:
	
	strcpy (REASON, "PTSinitally:ERROR: incorrect section header.\n");
	break;
      case 346:
	
	strcpy (REASON,
		"PTSinitally:ERROR: Unable to find End-Of-Section mark.\n");
	break;
      case 347:
	
	strcpy (REASON, "PTSinitally:ERROR: expecting to find ON or OFF.\n");
	break;
      case 348:
	
	strcpy (REASON, "PTSinitally:ERROR: cannotopen track data file.\n");
	break;
      case 349:
	
	strcpy (REASON, "PTSinitally:ERROR: End-Of-Section mark not found.\n");
	break;
      case 350:
	
	strcpy (REASON, "SPDinitally:ERROR: incorrect section header.\n");
	break;
      case 351:
	
	strcpy (REASON,
		"SPDinitally:ERROR: Unable to find End-Of-Section mark.\n");
	break;
      case 352:
	
	strcpy (REASON, "SPDinitally:ERROR: expecting to find ON or OFF.\n");
	break;
      case 353:
	
	strcpy (REASON, "SPDinitally:ERROR: Invalid entry.\n");
	break;
      case 354:
	
	strcpy (REASON, "SPDinitally:ERROR: Too many bins.\n");
	break;
      case 355:
	
	strcpy (REASON, "SPDinitally:ERROR: End-Of-Section mark not found.\n");
	break;
      case 356:
	
	strcpy (REASON, "PHSinitally:ERROR: incorrect section header.\n");
	break;
      case 357:
	
	strcpy (REASON,
		"PHSinitally:ERROR: Unable to find End-Of-Section mark.\n");
	break;
      case 358:
	
	strcpy (REASON, "PHSinitally:ERROR: expecting to find ON or OFF.\n");
	break;
      case 359:
	
	strcpy (REASON, "PHSinitally:ERROR: Invalid entry.\n");
	break;
      case 360:
	
	strcpy (REASON, "PHSinitally:ERROR: Too many bins.\n");
	break;
      case 361:
	
	strcpy (REASON, "PHSinitally:ERROR: End-Of-Section mark not found.\n");
	break;

      case 362:
	
	strcpy (REASON, "PIDinitally:ERROR: incorrect section header.\n");
	break;
      case 363:
	
	strcpy (REASON,
		"PIDinitally:ERROR: Unable to find End-Of-Section mark.\n");
	break;
      case 364:
	
	strcpy (REASON, "PIDinitally:ERROR: expecting to find ON or OFF.\n");
	break;
      case 365:
	
	strcpy (REASON, "PIDinitally:ERROR: Invalid entry.\n");
	break;
      case 366:
	
	strcpy (REASON,
		"PIDinitally:ERROR: detection material must be a perfect absorbent; increase absorption energies above einf.\n");
	break;
      case 367:
	
	strcpy (REASON, "PIDinitally:ERROR: invalid value.\n");
	break;
      case 368:
	
	strcpy (REASON,
		"PIDinitally:ERROR: pixel size and no. pixels are both zero.\n");
	break;
      case 369:
	
	strcpy (REASON, "PIDinitally:ERROR: max no. megapixels exceeded.\n");
	break;
      case 370:
	
	strcpy (REASON,
		"PIDinitally:ERROR: emin, emax, nebin invalid values.\n");
	break;
      case 371:
	
	strcpy (REASON, "PIDinitally:ERROR: invalid mode.\n");
	break;
      case 372:
	
	strcpy (REASON,
		"PIDinitally:ERROR: max no. (Mpixels x E bins) exceeded.\n");
	break;
      case 373:
	
	strcpy (REASON,
		"PIDinitally:ERROR: c0, c1 parameters cannot be negative.\n");
	break;
      case 374:
	
	strcpy (REASON,
		"PIDinitally:ERROR: Matrix format is incompatible with energy discriminating mode.\n");
	break;
      case 375:
	
	strcpy (REASON, "PIDinitally:ERROR: invalid format.\n");
	break;
      case 376:
	
	strcpy (REASON, "PIDinitally:ERROR: End-Of-Section mark not found.\n");
	break;
      case 377:
	
	strcpy (REASON, "PIDinitally:ERROR: not enough memory.\n");
	break;
      case 378:
	
	strcpy (REASON,
		"setDetectFrame:ERROR: detection material not found.\n");
	break;

      case 400:
	
	strcpy (REASON,
		"PMRDR:ERROR: The input file must begin with the TITLE line.\n");
	break;
      case 401:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect particle type.\n");
	break;
      case 402:
	
	strcpy (REASON,
		"PMRDR:ERROR: Source energy spectrum. The number of energy bins is too large.\n");
	break;
      case 403:
	
	strcpy (REASON,
		"PMRDR:ERROR: The source energy spectrum is not defined.\n");
	break;
      case 404:
	
	strcpy (REASON, "PMRDR:ERROR: The initial energy E0 is too small.\n");
	break;
      case 405:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect body label.\n");
	break;
      case 406:
	
	strcpy (REASON, "PMRDR:ERROR: THETA must be between 0 and 180 deg.\n");
	break;
      case 407:
	
	strcpy (REASON, "PMRDR:ERROR: PHI must be between 0 and 360 deg.\n");
	break;
      case 408:
	
	strcpy (REASON, "PMRDR:ERROR: ALPHA must be between 0 and 180 deg.\n");
	break;
      case 409:
	
	strcpy (REASON,
		"PMRDR:ERROR: Inconsistent definition of the primary source.\n");
	break;
      case 410:
	
	strcpy (REASON, "PMRDR:ERROR: Too many phase-space files.\n");
	break;
      case 411:
	
	strcpy (REASON, "PMRDR:ERROR: Inconsistent window end points.\n");
	break;
      case 412:
	
	strcpy (REASON,
		"PMRDR:ERROR: You have to specify a material file (line MFNAME).\n");
	break;
      case 413:
	
	strcpy (REASON, "PMRDR:ERROR: Wrong number of materials.\n");
	break;
      case 414:
	
	strcpy (REASON, "PMRDR:ERROR: Geometry file could not be opened.\n");
	break;
      case 415:
	
	strcpy (REASON, "PMRDR:ERROR: The PARINP index must be positive.\n");
	break;
      case 416:
	
	strcpy (REASON, "PMRDR:ERROR: Too many modified parameters.\n");
	break;
      case 417:
	
	strcpy (REASON, "PMRDR:ERROR: NMATG must be greater than 0.\n");
	break;
      case 418:
	
	strcpy (REASON, "PMRDR:ERROR: Too many bodies.\n");
	break;
      case 419:
	
	strcpy (REASON, "PMRDR:ERROR: Too many different materials.\n");
	break;
      case 420:
	
	strcpy (REASON, "PMRDR:ERROR: Some source bodies are undefined.\n");
	break;
      case 421:
	
	strcpy (REASON, "PMRDR:ERROR: You have to specify a geometry file.\n");
	break;
      case 422:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect body number.\n");
	break;
      case 423:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect KB value.\n");
	break;
      case 424:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect value of KPAR.\n");
	break;
      case 425:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect value of ICOL.\n");
	break;
      case 426:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect weight window limits.\n");
	break;
      case 427:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect value of IBRSPL.\n");
	break;
      case 428:
	
	strcpy (REASON,
		"PMRDR:ERROR: Interaction forcing unactive in this body.\n");
	break;
      case 429:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect value of IXRSPL.\n");
	break;
      case 430:
	
	strcpy (REASON, "PMRDR:ERROR: NBE equal to 0.\n");
	break;
      case 431:
	
	strcpy (REASON, "PMRDR:ERROR: NBTH equal to 0.\n");
	break;
      case 432:
	
	strcpy (REASON, "PMRDR:ERROR: Wrong number of PHI bins.\n");
	break;
      case 433:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect number of energy bins.\n");
	break;
      case 434:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect energy limits.\n");
	break;
      case 435:
	
	strcpy (REASON, "PMRDR:ERROR: Wrong IPSF value.\n");
	break;
      case 436:
	
	strcpy (REASON, "PMRDR:ERROR: Wrong IDCUT value.\n");
	break;
      case 437:
	
	strcpy (REASON,
		"PMRDR:ERROR: No impact detector has been defined yet.\n");
	break;
      case 438:
	
	strcpy (REASON,
		"PMRDR:ERROR: Only one PSF can be generated in a each run.\n");
	break;
      case 439:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect number of age bins.\n");
	break;
      case 440:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect age limits.\n");
	break;
      case 441:
	
	strcpy (REASON, "PMRDR:ERROR: Undefined age distribution limits.\n");
	break;
      case 442:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect body label.\n");
	break;
      case 443:
	
	strcpy (REASON,
		"PMRDR:ERROR: A body cannot be part of two detectors.\n");
	break;
      case 444:
	
	strcpy (REASON,
		"PMRDR:ERROR: A void body cannot be part of a detectors.\n");
	break;
      case 445:
	
	strcpy (REASON, "PMRDR:ERROR: This detector has no active bodies.\n");
	break;
      case 446:
	
	strcpy (REASON, "PMRDR:ERROR: XU must be greater than XL+1.0E-6.\n");
	break;
      case 447:
	
	strcpy (REASON, "PMRDR:ERROR: Incorrect keyword.\n");
	break;
      case 448:
	
	strcpy (REASON, "PMRDR:ERROR: YU must be greater than YL+1.0E-6.\n");
	break;
      case 449:
	
	strcpy (REASON, "PMRDR:ERROR: ZU must be greater than ZL+1.0E-6.\n");
	break;
      case 450:
	
	strcpy (REASON, "PMRDR:ERROR: RU must be greater than 1.0E-6.\n");
	break;
      case 451:
	
	strcpy (REASON,
		"PMRDR:ERROR: The dump file is corrupted (the TITLE does not match).\n");
	break;
      case 452:
	
	strcpy (REASON, "PMRDR:ERROR: File could not be opened.\n");
	break;
      case 453:
	
	strcpy (REASON, "PMRDR:ERROR: The file is empty or corrupted.\n");
	break;
      case 454:
	
	strcpy (REASON, "ENANG0:ERROR: NBE is too large.\n");
	break;
      case 455:
	
	strcpy (REASON, "ENANG0:ERROR: NBTH is too large.\n");
	break;
      case 456:
	
	strcpy (REASON, "ENANG0:ERROR: NBPH is too large.\n");
	break;
      case 457:
	
	strcpy (REASON,
		"IMDET0:ERROR: SIMDET: Detector already defined. Detector cannot be defined.\n");
	break;
      case 458:
	
	strcpy (REASON, "IMDET0:ERROR: SIMDET: Too many detectors.\n");
	break;
      case 459:
	
	strcpy (REASON, "IMDET0:ERROR: SIMDET: NB is too large.\n");
	break;
      case 460:
	
	strcpy (REASON,
		"ENDET0:ERROR: SENDET: Detector already defined. Detector cannot be defined.\n");
	break;
      case 461:
	
	strcpy (REASON, "ENDET0:ERROR: SENDET: Too many detectors.\n");
	break;
      case 462:
	
	strcpy (REASON, "ENDET0:ERROR: SENDET: NB is too large.\n");
	break;
      case 463:
	
	strcpy (REASON, "DOSE0:ERROR: IDOSE should be 1, 2, or 3.\n");
	break;
      case 464:
	
	strcpy (REASON,
		"DOSE0:ERROR: SDOSE: NBX must be .GT.0. and .LE.NDXM\n");
	break;
      case 465:
	
	strcpy (REASON,
		"DOSE0:ERROR: SDOSE: NBY must be .GT.0. and .LE.NDYM\n");
	break;
      case 466:
	
	strcpy (REASON,
		"DOSE0:ERROR: SDOSE: NBZ must be .GT.0. and .LE.NDZM\n");
	break;
      case 1000:
	
	strcpy (REASON, "");
	break;
      default:
	break;
      }
    }
    
    //  *********************************************************************
    //                       SUBROUTINE EELaW
    //  *********************************************************************
    void materialCreator::EELaW (FILE * IWR)
    {
      //  This subroutine generates a table of integrated cross sections for
      //  elastic scattering of electrons and positrons in material M, and
      //  writes it on the material definition file. Data are read from the
      //  files 'pdeelZZ.p08'.

      const char LDIG[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //Get required compos variables
      double (&STF)[30] = COMPOS.STF;
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      
      //  ****  Elastic scattering of electrons and positrons.
      double EJT[NEGP], XE0[NEGP], XE1[NEGP],
	XE2[NEGP], XP0[NEGP], XP1[NEGP], XP2[NEGP];
      
      //  ****  Building the cross section table.

      for (int I = 0; I < NEGP; I++)
	{
	  XE0[I] = 0.0;
	  XE1[I] = 0.0;
	  XE2[I] = 0.0;
	  XP0[I] = 0.0;
	  XP1[I] = 0.0;
	  XP2[I] = 0.0;
	}

      int IZZ, IZZZ, NLD, NLD1, NLD2, NPTAB = 0;
      double WGHT;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{

	  IZZ = IZ[IEL];
	  WGHT = STF[IEL];
	  NLD = IZZ;
	  NLD1 = NLD - 10 * (NLD / 10);
	  NLD2 = (NLD - NLD1) / 10;

	  //Construct database filename
	  std::string pdfFile("pdeel");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p08");

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;
	  }

	  std::string line;
	  iss.getline(line);
	  sscanf(line.c_str(), " %d", &IZZZ);

	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1303);
	      return;
	    }
	  for (int I = 0; I < NEGP; I++)
	    {
	      double XE0P, XE1P, XE2P, XP0P, XP1P, XP2P;
	      iss.getline(line);
	      sscanf(line.c_str(), " %lf %lf %lf %lf %lf %lf %lf",
		     &EJT[I], &XE0P, &XE1P, &XE2P, &XP0P, &XP1P, &XP2P);
	      if (iss.eof())
		{
		  break;
		}
	  
	      XE0[I] = XE0[I] + WGHT * XE0P;
	      XE1[I] = XE1[I] + WGHT * XE1P;
	      XE2[I] = XE2[I] + WGHT * XE2P;
	      XP0[I] = XP0[I] + WGHT * XP0P;
	      XP1[I] = XP1[I] + WGHT * XP1P;
	      XP2[I] = XP2[I] + WGHT * XP2P;
	      NPTAB = I + 1;
	    }
	}

      //  ****  Write final x-section table.

      fprintf (IWR,
	       " *** Electron and positron elastic cross sections,  NDATA =%4d\n",
	       NPTAB);
      for (int I = 0; I < NPTAB; I++)
	{
	  fprintf (IWR, "%10.3E %11.5E %11.5E %11.5E %11.5E %11.5E %11.5E\n",
		   EJT[I], XE0[I], XE1[I], XE2[I], XP0[I], XP1[I], XP2[I]);
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE ESIaW
    //  *********************************************************************
    void materialCreator::ESIaW (FILE * IWR)
    {
      //  This subroutine generates tables of cross sections for inner-shell
      //  ionisation by electron impact for the elements in material M and
      //  writes them on the material data file.

      //  Data are read from the files 'pdesiZZ.p14'.

      const char LDIG[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //Get required compos variables
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      const int NES = 850;
      double E[NES], XESIR[NES][16];

      int IZZ, IZZZ, NLD, NLD1, NLD2, NSHR, NPTAB = 0;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{

	  IZZ = IZ[IEL];
	  NLD = IZZ;
	  NLD1 = NLD - 10 * (NLD / 10);
	  NLD2 = (NLD - NLD1) / 10;
      
	  //Construct database filename
	  std::string pdfFile("pdesi");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p14");

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;	
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;
	  }

	  std::string line;
	  iss.getline(line);
	  sscanf(line.c_str(), "%*16c%2d%*6c%2d", &IZZZ, &NSHR);
	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1308);
	      return;
	    }
	  if (NSHR > 16)
	    {
	      ErrorFunction (1309);
	      return;
	    }
	  //Skip two lines
	  iss.ignoreLine();
	  iss.ignoreLine();

	  for (int IE = 0; IE < NES; IE++)
	    {
	      if (iss.eof())
		{
		  break;
		}
	      iss >> E[IE];
	      for (int IS = 0; IS < NSHR; IS++)
		{
		  iss >> XESIR[IE][IS];
		}
	      //Skip line
	      iss.ignoreLine();
	  
	      NPTAB = IE + 1;
	      if (E[IE] > 0.999E9)
		{
		  break;
		}
	    }
	  fprintf (IWR,
		   " *** Electron ionisation cross sections,  IZ =%3d,  NSHELL =%3d,  NDATA =%4d\n",
		   IZZ, NSHR, NPTAB);
	  for (int IE = 0; IE < NPTAB; IE++)
	    {
	      fprintf (IWR, "%12.5E", E[IE]);
	      for (int IS = 0; IS < NSHR; IS++)
		{
		  if (IS < NSHR - 1)
		    {
		      fprintf (IWR, "%12.5E", XESIR[IE][IS]);
		    }
		  else
		    {
		      fprintf (IWR, "%12.5E\n", XESIR[IE][IS]);
		    }
		}
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE PSIaW
    //  *********************************************************************
    void materialCreator::PSIaW (FILE * IWR)
    {
      //  This subroutine generates tables of cross sections for inner-shell
      //  ionisation by positron impact for the elements in material M and
      //  writes them on the material data file.

      //  Data are read from the files 'pdpsiZZ.p14'.

      const char LDIG[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //Get required compos variables
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      const int NES = 800;
      double E[NES], XPSIR[NES][16];

      int IZZ, NLD, NLD1, NLD2, IZZZ, NSHR, NPTAB = 0;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{
      
	  IZZ = IZ[IEL];
	  NLD = IZZ;
	  NLD1 = NLD - 10 * (NLD / 10);
	  NLD2 = (NLD - NLD1) / 10;

	  //Construct database filename
	  std::string pdfFile("pdpsi");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p14");

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;	
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction(901);
	    return;
	  }

	  std::string line;
	  iss.getline(line);
	  sscanf(line.c_str(), "%*16c%2d%*6c%2d", &IZZZ, &NSHR);
	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1314);
	      return;
	    }
	  if (NSHR > 16)
	    {
	      ErrorFunction (1315);
	      return;
	    }
	  //Skip two lines
	  iss.ignoreLine();
	  iss.ignoreLine();

	  for (int IE = 0; IE < NES; IE++)
	    {
	      if (iss.eof())
		{
		  break;
		}
	      iss >> E[IE];
	      for (int IS = 0; IS < NSHR; IS++)
		{
		  iss >> XPSIR[IE][IS];
		}
	      //Skip the line
	      iss.ignoreLine();

	      NPTAB = IE + 1;
	      if (E[IE] > 0.999E9)
		{
		  break;
		}
	    }
	  fprintf (IWR,
		   " *** Positron ionisation cross sections,  IZ =%3d,  NSHELL =%3d,  NDATA =%4d\n",
		   IZZ, NSHR, NPTAB);
	  for (int IE = 0; IE < NPTAB; IE++)
	    {
	      fprintf (IWR, "%12.5E", E[IE]);
	      for (int IS = 0; IS < NSHR; IS++)
		{
		  if (IS < NSHR - 1)
		    {
		      fprintf (IWR, "%12.5E", XPSIR[IE][IS]);
		    }
		  else
		    {
		      fprintf (IWR, "%12.5E\n", XPSIR[IE][IS]);
		    }
		}
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE EBRaW
    //  *********************************************************************
    void materialCreator::EBRaW (FILE * IWR)
    {
      //  This subroutine generates a table of the scaled energy-loss cross
      //  section for bremsstrahlung emission by electrons in material M. Data
      //  are read from the files 'pdebrZZ.p08'.

      const double TREV = 2.0 * REV;

      const char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //Get required compos variables
      double (&STF)[30] = COMPOS.STF;
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;

      //Get required CEBR01 variables
      double (&EBT)[NBE] = CEBR01.EBT;
      double (&XS)[NBE][NBW] = CEBR01.XS;
      double (&TXS)[NBE] = CEBR01.TXS;
      double (&X)[NBE] = CEBR01.X;
      double (&Y)[NBE] = CEBR01.Y;
      
      
      double A[NEGP], B[NEGP], C[NEGP], D[NEGP];
      double WB0[NBW] =
	{ 1.0E-12, 0.025, 0.05, 0.075, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45,
	  0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.925, 0.95, 0.97, 0.99, 0.995, 0.999,
	  0.9995, 0.9999, 0.99995, 0.99999, 1.0 };
      double PDF[NBE];


      //  ****  'Equivalent' atomic number.

      double SUMZ2 = 0.0;
      double SUMS = 0.0;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{
	  SUMZ2 = SUMZ2 + STF[IEL] * pow (IZ[IEL], 2);
	  SUMS = SUMS + STF[IEL];
	}
      ZBR2 = SUMZ2 / SUMS;

      //  ****  Building the scaled cross section table.

      for (int IE = 0; IE < NBE; IE++)
	{
	  TXS[IE] = 0.0;
	  for (int IW = 0; IW < NBW; IW++)
	    {
	      XS[IE][IW] = 0.0;
	    }
	}
      int IZZ, NLD, NLD1, NLD2, IZZZ;
      double WGHT, TXSP;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{
      
	  IZZ = IZ[IEL];
	  WGHT = STF[IEL] * IZZ * IZZ / ZBR2;
	  NLD = IZZ;
	  NLD1 = NLD - 10 * (NLD / 10);
	  NLD2 = (NLD - NLD1) / 10;

	  //Construct database filename
	  std::string pdfFile("pdebr");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p08");

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;	
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;
	  }

	  std::string line;
	  iss.getline(line);      
	  sscanf(line.c_str(), "%d", &IZZZ);
	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1317);
	      return;
	    }
	  for (int IE = 0; IE < NBE; IE++)
	    {
	      iss >> EBT[IE];
	      for (int IW = 0; IW < NBW; IW++)
		{
		  iss >> PDF[IW];
		  if ((IW + 1) % 5 == 0){
		    //Skip line
		    iss.ignoreLine();
		  }
		}
	      iss.getline(line);	  
	      sscanf (line.c_str(), "%*36c %lf", &TXSP);
	      TXS[IE] = TXS[IE] + WGHT * TXSP;
	      for (int IW = 0; IW < NBW; IW++)
		{
		  XS[IE][IW] = XS[IE][IW] + WGHT * PDF[IW];
		}
	    }
	}

      //  ****  The energy loss spectrum is re-normalised to reproduce the
      //        total scaled cross section of Berger and Seltzer.

      double RSUM, FACT, FNORM, TST;
      for (int IE = 0; IE < NBE; IE++)
	{
	  for (int IW = 0; IW < NBW; IW++)
	    {
	      X[IW] = WB0[IW];
	      Y[IW] = XS[IE][IW];
	    }
	  RSUM = RLMOM (X, Y, 1.0, NBW, 0);
	  FACT =
	    (EBT[IE] +
	     REV) * 1.0E-27 * 137.03604 / (pow (ELRAD, 2) * (EBT[IE] + TREV));
	  FNORM = TXS[IE] / (RSUM * FACT);
	  TST = 100.0 * fabs (FNORM - 1.0);
	  if (TST > 1.0)
	    {
	      ErrorFunction (1318);
	      return;
	    }
	  for (int IW = 0; IW < NBW; IW++)
	    {
	      XS[IE][IW] = XS[IE][IW] * FNORM;
	    }
	}

      //  ****  Write output scaled x-section table.

      fprintf (IWR,
	       " *** Electron scaled bremss x-section,  ZEQ =%12.5E,  NDATA =%4d\n",
	       sqrt (ZBR2), NBE);
      for (int IE = 0; IE < NBE; IE++)
	{
	  fprintf (IWR, "%9.2E", EBT[IE]);
	  for (int IW = 0; IW < NBW; IW++)
	    {
	      if (IW != 0 && IW % 5 == 0)
		{
		  fprintf (IWR, "%*c", 9, ' ');
		}
	      if ((IW + 1) % 5 == 0)
		{
		  fprintf (IWR, "%12.5E\n", XS[IE][IW]);
		}
	      else
		{
		  fprintf (IWR, "%12.5E", XS[IE][IW]);
		}

	    }
	  fprintf (IWR, "%*c%10.3E\n", 36, ' ', TXS[IE]);
	}


      //  ************  Initialisation of the calculation routines.

      for (int I = 0; I < NBW; I++)
	{
	  WB[I] = WB0[I];
	}

      //  ****  Compute the scaled energy loss distribution and sampling
      //        parameters for the energies in the simulation grid.

      //  ****  Interpolation in E.

      double F1, FP1, ELL;
      int J;
      for (int IE = 0; IE < NBE; IE++)
	{
	  X[IE] = log (EBT[IE]);
	}
      for (int IW = 0; IW < NBW; IW++)
	{
	  for (int IE = 0; IE < NBE; IE++)
	    {
	      Y[IE] = log (XS[IE][IW]);
	    }
	  SPLINE (X, Y, A, B, C, D, 0.0, 0.0, NBE);
	  if (IRETRN != 0)
	    {
	      return;
	    }
	  for (int I = 0; I < NEGP; I++)
	    {
	      ELL = DLEMP[I];
	      if (ELL > X[0])
		{
		  FINDI (X, ELL, NBE, J);
		  P0[I][IW] =
		    exp (A[J - 1] +
			 ELL * (B[J - 1] + ELL * (C[J - 1] + ELL * D[J - 1])));
		}
	      else
		{
		  F1 = A[0] + X[0] * (B[0] + X[0] * (C[0] + X[0] * D[0]));
		  FP1 = B[0] + X[0] * (2.0 * C[0] + X[0] * 3.0 * D[0]);
		  P0[I][IW] = exp (F1 + FP1 * (ELL - X[0]));
		}
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE BRaAW
    //  *********************************************************************
    void materialCreator::BRaAW (double &ZEQ, FILE * IWR)
    {
      //  This subroutine generates the parameters of the angular distribution
      //  of bremsstrahlung photons for the element of atomic number ZEQ. In
      //  the case of compounds (and mixtures) ZEQ is the average atomic number
      //  of the elements in the molecule. The evaluated parameters are written
      //  on the material definition file. Data are read from the database file
      //  'pdbrang.p18'.

      const int NZ = 13;
      const int NE = 7;
      const int NK = 10;

      double Z[NZ], E[NE], XK[NK], P1[NZ][NE][NK], P2[NZ][NE][NK], Q1[NE][NK],
	Q2[NE][NK];
      double Y1[NZ], Y2[NZ], A[NZ], B[NZ], C[NZ], D[NZ], A2[NZ], B2[NZ];

      Z[0] = 1.0;
      Z[1] = 2.0;
      Z[2] = 5.0;
      Z[3] = 8.0;
      Z[4] = 11.0;
      Z[5] = 13.0;
      Z[6] = 26.0;
      Z[7] = 37.0;
      Z[8] = 47.0;
      Z[9] = 64.0;
      Z[10] = 79.0;
      Z[11] = 86.0;
      Z[12] = 92.0;

      E[0] = 1.0E3;
      E[1] = 5.0E3;
      E[2] = 1.0E4;
      E[3] = 5.0E4;
      E[4] = 1.0E5;
      E[5] = 5.0E5;
      E[6] = 1.0E6;

      XK[0] = 0.0;
      XK[1] = 0.1;
      XK[2] = 0.2;
      XK[3] = 0.3;
      XK[4] = 0.4;
      XK[5] = 0.5;
      XK[6] = 0.6;
      XK[7] = 0.7;
      XK[8] = 0.8;
      XK[9] = 0.95;

      //  ****  Read database file.
      int IZ, IE, IK, I;
      double ZR, ER, RKR, P1R, P2R, ERROR;

      //Ensure data base existence and get it
      const char* const pdata = penred::penMatDB::readDataBaseFile("pdbrang.p18",0);
      if(pdata == nullptr){
	printf("Error: Data base file not found: 'pdbrang.p18'\n");
	ErrorFunction(901);
	return;	
      }

      //Create a stream to read it
      penred::dataBases::literalArrayStream iss([](unsigned i){
	return penred::penMatDB::readDataBaseFile("pdbrang.p18",i);
      });
      if(!iss){
	printf("Error: Unable to create stream from "
	       "data base file: 'pdbrang.p18'\n");	
	ErrorFunction(901);
	return;
      }

      std::string line;
      //Skip a line
      iss.ignoreLine();

      for (int IZ1 = 0; IZ1 < NZ; IZ1++)
	{
	  for (int IE1 = 0; IE1 < NE; IE1++)
	    {
	      for (int IK1 = 0; IK1 < NK; IK1++)
		{
		  iss.getline(line);
		  sscanf(line.c_str(), "%d %d %d %lf %lf %lf %lf %lf %lf",
			 &IZ, &IE, &IK, &ZR, &ER, &RKR, &P1R, &P2R, &ERROR);
	      
		  if ((fabs (ZR - Z[IZ - 1]) < 1.0E-6)
		      && (fabs (ER - E[IE - 1]) < 1.0E-6)
		      && (fabs (RKR - XK[IK - 1]) < 1.0E-6))
		    {
		      P1[IZ - 1][IE - 1][IK - 1] = P1R;
		      P2[IZ - 1][IE - 1][IK - 1] = P2R;
		    }
		  else
		    {
		      printf ("Corrupt data file (pdbrang.p08).\n");
		      ErrorFunction (1326);
		      return;
		    }
		}
	    }
	}

      //  ****  Interpolation in Z.

      for (IE = 0; IE < NE; IE++)
	{
	  for (IK = 0; IK < NK; IK++)
	    {
	      for (IZ = 0; IZ < NZ; IZ++)
		{
		  Y1[IZ] = log (P1[IZ][IE][IK] * Z[IZ]);
		  Y2[IZ] = P2[IZ][IE][IK];
		}
	      for (IZ = 0; IZ < NZ - 1; IZ++)
		{
		  A2[IZ] =
		    Y2[IZ] - (Y2[IZ + 1] - Y2[IZ]) * Z[IZ] / (Z[IZ + 1] - Z[IZ]);
		  B2[IZ] = (Y2[IZ + 1] - Y2[IZ]) / (Z[IZ + 1] - Z[IZ]);
		}
	      A2[NZ - 1] = A2[NZ - 2];
	      B2[NZ - 1] = B2[NZ - 2];
	      SPLINE (Z, Y1, A, B, C, D, 0.0, 0.0, NZ);
	      if (IRETRN != 0)
		{
		  return;
		}
	      FINDI (Z, ZEQ, NZ, I);
	      Q1[IE][IK] =
		exp (A[I - 1] +
		     ZEQ * (B[I - 1] + ZEQ * (C[I - 1] + ZEQ * D[I - 1]))) / ZEQ;
	      if (Q1[IE][IK] > 1.0E0)
		{
		  Q1[IE][IK] = 1.0E0;
		}			// Corrects wrong values.
	      Q2[IE][IK] = A2[I - 1] + ZEQ * B2[I - 1];
	    }
	}

      //  ****  Write final table of parameters.

      int NDATA = 70;
      fprintf (IWR,
	       " *** Bremss angular distribution,  ZEQ =%12.5E,  NDATA =%4d\n",
	       ZEQ, NDATA);
      for (IE = 0; IE < NE; IE++)
	{
	  for (IK = 0; IK < NK; IK++)
	    {
	      fprintf (IWR, "%3d%3d %10.3E %10.3E %14.7E %14.7E\n", IE + 1,
		       IK + 1, E[IE], XK[IK], Q1[IE][IK], Q2[IE][IK]);
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE GRAaW
    //  *********************************************************************
    void materialCreator::GRAaW (FILE * IWR)
    {
      //  This subroutine generates tables of molecular form factors and cross
      //  sections for Rayleigh scattering of photons in material M and writes
      //  them on the material data file. Data are read from the files
      //  'pdgraZZ.p08'.

      const char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //Get required compos variables
      double (&STF)[30] = COMPOS.STF;
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      std::vector<double> Q(NQ), FF(NQ), FF2(NQ), ER(NEM), XSR(NEM);
      std::vector<double> EI(NEM), XS(NEM);

      //  ****  Momentum-transfer grid points and atomic form factor.
      for (int I = 0; I < NQ; I++)
	{
	  Q[I] = 0.0;
	  FF2[I] = 0.0;
	}
      //  ****  Energy grid points and Rayleigh x sections.
      double FACT1 = pow (10.0, (1.0 / 250.0));
      double FACT2 = pow (10.0, (1.0 / 25.0));
      double E = 10.0 / FACT1;
      int NE = 0;
      for (int I = 0; I < 2 * NEM; I++)
	{
	  if (E < 1.5848E5)
	    {
	      E = E * FACT1;
	    }
	  else
	    {
	      E = E * FACT2;
	    }
	  if (E > 49.0)
	    {
	      NE = NE + 1;
	      ER[NE - 1] = E;
	      XSR[NE - 1] = 0.0;
	      if (E > 1.2E9)
		{
		  break;
		}
	    }
	}

      int IZZ, NLD, NLD1, NLD2, IZZZ, NQI, NEI;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{
	  IZZ = IZ[IEL];
	  NLD = IZZ;
	  NLD1 = NLD - 10 * (NLD / 10);
	  NLD2 = (NLD - NLD1) / 10;

	  //Construct database filename
	  std::string pdfFile("pdaff");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p08");

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;	
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction (901);
	    return;
	  }

	  std::string line;
	  iss.getline(line);            
	  sscanf(line.c_str(), "%d %d", &IZZZ, &NQI);

	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1330);
	      return;
	    }
	  if (NQI != NQ)
	    {
	      ErrorFunction (1331);
	      return;
	    }
	  for (int I = 0; I < NQ; I++)
	    {
	      iss.getline(line);
	      sscanf(line.c_str(), "%lf %lf", &Q[I], &FF[I]);
	    }

	  //Get pdgra data
	  pdfFile.assign("pdgra");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p08");

	  const char* const pdgra = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdgra == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction(901);
	    return;
	  }

	  //Set stream string
	  iss.str([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction (901);
	    return;
	  }	  

	  //Read data
	  iss.getline(line);
	  sscanf(line.c_str(), "%d %d", &IZZZ, &NEI);
	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1332);
	      return;
	    }
	  for (int I = 0; I < NEI; I++)
	    {
	      double FA1, FA2;
	      iss.getline(line);
	      sscanf(line.c_str(), "%lf %lf %lf %lf",
		     &EI[I], &FA1, &FA2, &XS[I]);
	      EI[I] = log (EI[I]);
	      XS[I] = log (XS[I]);
	    }

	  for (int I = 0; I < NQ; I++)
	    {
	      FF2[I] = FF2[I] + STF[IEL] * pow (FF[I], 2);
	    }
	  for (int I = 0; I < NE; I++)
	    {
	      int J;
	      double EE = log (ER[I]);
	      FINDI (EI.data(), EE, NEI, J);
	      double XSE =
		exp (XS[J - 1] +
		     (XS[J + 1 - 1] - XS[J - 1]) * (EE -
						    EI[J - 1]) / (EI[J + 1 - 1] -
								  EI[J - 1]));
	      XSR[I] = XSR[I] + STF[IEL] * XSE;
	    }
	}

      fprintf (IWR, " *** Rayleigh scattering.  NQ = %3d,  NE = %4d\n", NQ, NE);
      for (int I = 0; I < NQ; I++)
	{
	  fprintf (IWR, "%9.2E%12.5E\n", Q[I], sqrt (FF2[I]));
	}
      for (int I = 0; I < NE; I++)
	{
	  fprintf (IWR, "%12.5E%12.5E\n", ER[I], XSR[I]);
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE GPHaW
    //  *********************************************************************
    void materialCreator::GPHaW (FILE * IWR)
    {
      //  This subroutine generates the table of photoelectric cross sections
      //  for photons in material M and writes it on the material data file.
      //  Data are read from the files 'pdgphZZ.p18'.

      const char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //Get required compos variables
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      const int NPHM = 2000;
      double XS[17], E0[500], XS0[500][17];
      int ISH[17];

      int IZZ, NLD, NLD1, NLD2, IZZZ, NGP, NSHR;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{
	  IZZ = IZ[IEL];
	  NLD = IZZ;
	  NLD1 = NLD - 10 * (NLD / 10);
	  NLD2 = (NLD - NLD1) / 10;

	  //Construct database filename
	  std::string pdfFile("pdgph");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p18");

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction(901);
	    return;	
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction(901);
	    return;
	  }

	  std::string line;
	  iss.getline(line);
	  sscanf(line.c_str(), "%*15c%2d %2d %4d", &IZZZ, &NSHR, &NGP);

	  if (NGP > NPHM)
	    {
	      ErrorFunction (1337);
	      return;
	    }
	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1338);
	      return;
	    }
	  if (NSHR > 16)
	    {
	      ErrorFunction (1339);
	      return;
	    }
	  ISH[0] = 0;
	  if (NSHR > 0)
	    {
	      iss.ignore(25);
	      for (int IS = 1; IS < NSHR; IS++)
		{
		  iss >> ISH[IS];
		  iss.ignore(10);
		}
	      iss.getline(line);
	      sscanf(line.c_str(), "%2d", &ISH[NSHR]);
	    }
	  else
	    {
	      //Skip line
	      iss.ignoreLine();
	    }
	  //Skip line
	  iss.ignoreLine();

	  int NPTAB = 0;
	  for (int IE = 0; IE < NGP; IE++)
	    {
	      double ER;
	      if (iss.eof())
		{
		  break;
		}
	      iss >> ER;
	      for (int IS = 0; IS < NSHR + 1; IS++)
		{
		  iss >> XS[IS];
		}
	      //Skip remaining line
	      iss.ignoreLine();
	      
	      if (ER > 49.9 && ER < 1.01E9)
		{
		  NPTAB = NPTAB + 1;
		  E0[NPTAB - 1] = ER;
		  for (int IS = 0; IS < NSHR + 1; IS++)
		    {
		      XS0[NPTAB - 1][IS] = XS[IS] * 1.0E-24;
		    }
		}
	    }
	  fprintf (IWR,
		   " *** Photoelectric cross sections,  IZ =%3d,  NSHELL =%3d,  NDATA =%5d\n",
		   IZZ, NSHR, NPTAB);

	  fprintf (IWR, "%13c%2d", ' ', 0);
	  for (int IS = 1; IS < NSHR + 1; IS++)
	    {
	      fprintf (IWR, "%10c%2d", ' ', ISH[IS]);
	    }
	  fprintf (IWR, "\n");
	  for (int IE = 0; IE < NPTAB; IE++)
	    {
	      fprintf (IWR, "%12.5E", E0[IE]);
	      for (int IS = 0; IS < NSHR + 1; IS++)
		{
		  fprintf (IWR, "%12.5E", XS0[IE][IS]);
		}
	      fprintf (IWR, "\n");
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE GPPaW
    //  *********************************************************************
    void materialCreator::GPPaW (double *EIT, double *XGP0, double *XGT0, int &NPTAB)
    {
      //  This subroutine generates a table of electron-positron pair produc-
      //  tion cross sections for photons in material M. Data are read from the
      //  files 'pdgppZZ.p11'.

      const char LDIG[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //Get required compos variables
      double (&STF)[30] = COMPOS.STF;
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      const int NEGPP = 10000;
      //double EIT[NEGPP], XGP0[NEGPP], XGT0[NEGPP];

      //  ****  Building the cross section table.

      for (int I = 0; I < NEGPP; I++)
	{
	  XGP0[I] = 0.0;
	  XGT0[I] = 0.0;
	}

      int IZZ, NLD, NLD1, NLD2, IZZZ;
      double WGHT;
      for (int IEL = 0; IEL < NELEM; IEL++)
	{

	  IZZ = IZ[IEL];
	  WGHT = STF[IEL] * 1.0E-24;
	  NLD = IZZ;
	  NLD1 = NLD - 10 * (NLD / 10);
	  NLD2 = (NLD - NLD1) / 10;

	  //Construct database filename
	  std::string pdfFile("pdgpp");
	  pdfFile.append(1, LDIG[NLD2]);
	  pdfFile.append(1, LDIG[NLD1]);
	  pdfFile.append(".p11");

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction(901);
	    return;	
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction(901);
	    return;
	  }

	  std::string line;
	  iss.getline(line);      
	  sscanf(line.c_str(), "%d", &IZZZ);

	  if (IZZZ != IZZ)
	    {
	      ErrorFunction (1340);
	      return;
	    }
	  for (int I = 0; I < NEGPP; I++)
	    {
	      double XG0P, XG0T;
	      iss.getline(line);
	      sscanf (line.c_str(), "%lf %lf %lf", &EIT[I], &XG0P, &XG0T);
	      XGP0[I] = XGP0[I] + WGHT * XG0P;
	      XGT0[I] = XGT0[I] + WGHT * XG0T;
	      NPTAB = I + 1;
	      if (EIT[I] > 0.999E9)
		{
		  break;
		}
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE RELAXW
    //  *********************************************************************
    void materialCreator::RELAXW (const int &IZ, FILE * IWR)
    {
      //  This subroutine produces a table of atomic relaxation data for the
      //  element IZ, and prints it on unit IWR. The output table is part of
      //  PENELOPE's material definition file.

      //  Data are read from file 'pdrelax.p11', which contains data pertaining
      //  to singly ionised atoms with the initial vacancy in one of the K, L,
      //  M and N shells. This file was prepared from the Livermore Evaluated
      //  Atomic Data Library (EADL). The energies of x-ray lines were replaced
      //  by more accurate experimental and theoretical values given by
      //  Deslattes et al. (2003) -K and L shells- and by Burr (1967) -M
      //  shells.

      //  NOTE: The transition probabilities and emission energies can be
      //  modified by editing the material data file. For each initial vacancy,
      //  the sum of transition probabilities _must_ be equal to unity.

      char CSH5[30][6] =
	{ "1s1/2", "2s1/2", "2p1/2", "2p3/2", "3s1/2", "3p1/2", "3p3/2", "3d3/2",
	  "3d5/2", "4s1/2", "4p1/2", "4p3/2", "4d3/2", "4d5/2", "4f5/2", "4f7/2", "5s1/2", "5p1/2",
	  "5p3/2", "5d3/2", "5d5/2", "5f5/2", "5f7/2", "6s1/2", "6p1/2", "6p3/2", "6d3/2", "6d5/2",
	  "7s1/2", " free" };

      const int NM = 2500;
      int IS0[NM], IS1[NM], IS2[NM];
      double P[NM], EI[NM], EE[99];

      int NT = 0;
      double ET_RELAXW;

      if (NSHT[IZ - 1] <= 0)
	{
	  ErrorFunction (1345);
	  return;
	}

      int IZR, IS0R;
  
      //Ensure data base existence and get it
      const char* const pdata = penred::penMatDB::readDataBaseFile("pdrelax.p11",0);
      if(pdata == nullptr){
	printf("Error: Data base file not found: 'pdrelax.p11'\n");	    
	ErrorFunction (901);
	return;	
      }

      //Create a stream to read it
      penred::dataBases::literalArrayStream iss([](unsigned i){
	return penred::penMatDB::readDataBaseFile("pdrelax.p11",i);
      });
      if(!iss){
	printf("Error: Unable to create stream from "
	       "data base file: 'pdrelax.p11'\n");	    	
	ErrorFunction (901);
	return;
      }

      //Get first line
      std::string line;
      iss.getline(line);

      int nRead = sscanf(line.c_str(), "%d %d", &IZR, &IS0R); // Ignores the data.
      if (nRead == 2)
	{
	  NT = 0;
	  int IS1R, IS2R;
	  double PR, EIN;
	  for (int I = 0; I < 150000; I++)
	    {
	      //Get next line
	      iss.getline(line);
	      nRead =
		sscanf(line.c_str(), "%d %d %d %d %lf %lf",
		       &IZR, &IS0R, &IS1R, &IS2R, &PR, &EIN);
	      if (nRead != 6)
		{
		  break;
		}

	      if (IZR == IZ)
		{
		  NT = NT + 1;
		  if (NT > NM)
		    {
		      ErrorFunction (1346);
		      return;
		    }
		  IS0[NT - 1] = IS0R;
		  IS1[NT - 1] = IS1R;
		  IS2[NT - 1] = IS2R;
		  P[NT - 1] = PR;
		  EI[NT - 1] = EIN;
		}
	    }
	}

      fprintf (IWR,
	       " *** RELAX:  Z =%3d,  no. of shells =%3d,  no. of transitions =%5d\n",
	       IZ, NSHT[IZ - 1], NT);

      for (int I = 0; I < 99; I++)
	{
	  EE[I] = 0.0;
	}
      int KS_RELAXW;
      for (int J = 0; J < 30; J++)
	{
	  KS_RELAXW = IKS[IZ - 1][J];
	  if (KS_RELAXW > 0)
	    {
	      if (IFI[IZ - 1][KS_RELAXW - 1] != 0)
		{
		  fprintf (IWR, " %3d %5s %1d %12.5E %12.5E %12.5E\n", KS_RELAXW,
			   CSH5[KS_RELAXW - 1], IFI[IZ - 1][KS_RELAXW - 1],
			   EB[IZ - 1][KS_RELAXW - 1],
			   ALW[IZ - 1][KS_RELAXW - 1],
			   CP0[IZ - 1][KS_RELAXW - 1]);
		  EE[KS_RELAXW - 1] = EB[IZ - 1][KS_RELAXW - 1];
		}
	    }
	}

      if (NT > 0)
	{
	  for (int I = 0; I < NT; I++)
	    {
	      if (IS2[I] == 0)
		{
		  if (EI[I] < 1.0)
		    {
		      ET_RELAXW = EE[IS0[I] - 1] - EE[IS1[I] - 1];
		    }
		  else
		    {
		      ET_RELAXW = EI[I];
		    }
		}
	      else
		{
		  if (EI[I] < 1.0)
		    {
		      ET_RELAXW = EE[IS0[I] - 1] - EE[IS1[I] - 1] - EE[IS2[I] - 1];
		    }
		  else
		    {
		      ET_RELAXW = EI[I];
		    }
		}
	      if (ET_RELAXW < 1.0)
		{
		  ET_RELAXW = 1.0;
		}
	      fprintf (IWR, " %3d%3d%3d %12.5E %12.5E\n", IS0[I], IS1[I], IS2[I],
		       P[I], ET_RELAXW);
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE EELdW
    //  *********************************************************************
    void materialCreator::EELdW (FILE * IWR)
    {
      //  This subroutine generates a table of differential cross sections for
      //  elastic scattering of electrons and positrons in material M, and
      //  writes it on the material definition file. Data are read from the
      //  ELSEPA elastic database files.

      const int NE = 96;

      //Get required compos variables
      double (&STF)[30] = COMPOS.STF;
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      int IZM[30];
      double STFM[30];

      for (int I = 0; I < NELEM; I++)
	{
	  IZM[I] = IZ[I];
	  STFM[I] = STF[I];
	}
      ELINIT (IZM, STFM, NELEM);
      if (IRETRN != 0)
	{
	  return;
	}

      //  ************  Write final DCS tables.

      //  ****  Electrons.

      int IELEC = -1;
      fprintf (IWR, " *** Electron elastic differential cross sections\n");
      double ECS0, ECS1, ECS2, TCS1, TCS2, TS0, TS1, TS2, TSTE;
      for (int IE = 0; IE < NE; IE++)
	{
	  for (int K = 0; K < NA; K++)
	    {
	      DCSI[K] = EDCS[IE][K];
	    }
	  ECS0 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 0);
	  if (IRETRN != 0)
	    {
	      return;
	    }
	  ECS1 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 1);
	  ECS2 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 2);
	  TCS1 = 2.0 * ECS1;
	  TCS2 = 6.0 * (ECS1 - ECS2);
	  fprintf (IWR, "%3d%10.3E%12.5E%12.5E%12.5E\n", IELEC, ETS[IE], ECS0,
		   TCS1, TCS2);
	  for (int K = 0; K < NA; K++)
	    {
	      fprintf (IWR, " %11.5E", EDCS[IE][K]);
	      if ((K + 1) % 10 == 0)
		{
		  fprintf (IWR, "\n");
		}
	    }
	  fprintf (IWR, "\n");
	  //  ****  Consistency test.
	  TS0 = (ECS0 - ECS[IE]) / ECS[IE];
	  TS1 = (TCS1 - ETCS1[IE]) / ETCS1[IE];
	  TS2 = (TCS2 - ETCS2[IE]) / ETCS2[IE];

	  TSTE = fabs (TS0);
	  if (TSTE < fabs (TS1))
	    {
	      TSTE = fabs (TS1);
	    }
	  if (TSTE < fabs (TS2))
	    {
	      TSTE = fabs (TS2);
	    }

	  if (TSTE > 1.0E-2)
	    {
	      fprintf (IWR, "( E=%12.5E)", ETS[IE]);
	      fprintf (IWR, "(    %11.5E %11.5E %11.5E)", ECS0, TCS1, TCS2);
	      fprintf (IWR, "(    %11.5E %11.5E %11.5E)", ECS[IE], ETCS1[IE],
		       ETCS2[IE]);
	      fprintf (IWR, " Electron cross section data are corrupt.\n");
	      ErrorFunction (1347);
	      return;
	    }
	}

      //  ****  Positrons.

      IELEC = +1;
      fprintf (IWR, " *** Positron elastic differential cross sections\n");

      for (int IE = 0; IE < NE; IE++)
	{
	  for (int K = 0; K < NA; K++)
	    {
	      DCSI[K] = PDCS[IE][K];
	    }
	  ECS0 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 0);
	  if (IRETRN != 0)
	    {
	      return;
	    }
	  ECS1 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 1);
	  ECS2 = 4.0 * PI * RMOMX (XMU, DCSI, 0.0, 1.0, NA, 2);
	  TCS1 = 2.0 * ECS1;
	  TCS2 = 6.0 * (ECS1 - ECS2);
	  fprintf (IWR, "%3d%10.3E%12.5E%12.5E%12.5E\n", IELEC, ETS[IE], ECS0,
		   TCS1, TCS2);
	  for (int K = 0; K < NA; K++)
	    {
	      fprintf (IWR, " %11.5E", PDCS[IE][K]);
	      if ((K + 1) % 10 == 0)
		{
		  fprintf (IWR, "\n");
		}
	    }
	  fprintf (IWR, "\n");
	  //  ****  Consistency test.
	  TS0 = (ECS0 - PCS[IE]) / PCS[IE];
	  TS1 = (TCS1 - PTCS1[IE]) / PTCS1[IE];
	  TS2 = (TCS2 - PTCS2[IE]) / PTCS2[IE];

	  TSTE = fabs (TS0);
	  if (TSTE < fabs (TS1))
	    {
	      TSTE = fabs (TS1);
	    }
	  if (TSTE < fabs (TS2))
	    {
	      TSTE = fabs (TS2);
	    }

	  if (TSTE > 1.0E-2)
	    {
	      fprintf (IWR, "( E= %11.5E)\n", ETS[IE]);
	      fprintf (IWR, "    %11.5E %11.5E %11.5E\n", ECS0, TCS1, TCS2);
	      fprintf (IWR, "    %11.5E %11.5E %11.5E\n", PCS[IE], PTCS1[IE],
		       PTCS2[IE]);
	      fprintf (IWR, " Positron cross section data are corrupt.\n");
	      ErrorFunction (1348);
	      return;
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE PEMATW
    //  *********************************************************************
    void materialCreator::PEMATW (std::istream& in,
				  const bool disableOutput,
				  const std::string& filename)
    {

      //  This subroutine generates the material definition file ready to be
      //  used in penRed simulations
      //
      //  When IFILE=1 the output file is given the name MFNAME, otherwise the
      //  user is asked to provide the filename. 

      char PFILE[81], NAME[63];
      const double TREV = 2.0 * REV;
      const double FOURPI = 4.0 * PI;

      //Get compos variables
      double (&STF)[30] = COMPOS.STF;
      double& ZT = COMPOS.ZT;
      double& AT = COMPOS.AT;
      double& RHO = COMPOS.RHO;
      double& VMOL = COMPOS.VMOL;
      int (&IZ)[30] = COMPOS.IZ;
      int& NELEM = COMPOS.NELEM;
      
      std::vector<double> FBW(30);
      std::vector<double> FF(NOM), UUI(NOM), FFJ0(NOM), WWRI(NOM);
      std::vector<int> KKZ(NOM), KKS(NOM);
      std::vector<double> FFT(NOM), UIT(NOM), WRIT(NOM);
      std::vector<int> KZT(NOM), KST(NOM);
      std::vector<double> FC(NOM), UIC(NOM), FJ0C(NOM);
      std::vector<int> KZC(NOM), KSC(NOM);

      double EGRT[17] =
	{ 1.0, 1.25, 1.50, 1.75, 2.00, 2.50, 3.00, 3.50, 4.00, 4.50, 5.00, 5.50,
	  6.00, 7.00, 8.00, 9.00, 1.00E1 };

      //  ****  'Standard' energy grid.
      std::vector<double> EIT(NEGP1), ES(NEGP1), ESS(NEGP1);
      std::vector<double> XGP0(NEGP1), XGT0(NEGP1), PPE(NEGP1), PPT(NEGP1);


      //  ****  Lowest negative valences of the elements.

      double VAL[99] = { 0, 0, -1, -2, -3, -2, 0, 0, 0,
			 /*1 */ 0, -1, -2, -3, -2, -3, -4, 0, 0, -1,
			 /*2 */ -2, -3, -2, -2, -2, -2, -2, -2, -2, -1,
			 /*3 */ -2, -3, -2, -3, -4, 0, 0, -1, -2, -3,
			 /*4 */ -4, -3, -6, -4, -3, -3, -2, -1, -2, -3,
			 /*5 */ -2, -3, -4, 0, 0, -1, -2, -3, -3, -3,
			 /*6 */ -3, -3, -2, -2, -3, -3, -3, -3, -3, -3,
			 /*7 */ -2, -3, -4, -5, -6, -4, -3, -3, -2, -1,
			 /*8 */ -1, -1, -2, -3, -2, 0, 0, -1, -2, -3,
			 /*9 */ -4, -4, -3, -3, -3, -3, -3, -3, -3, -3
      };
      //           0   1   2   3   4   5   6   7   8   9


      int IREAD;
      int IREAD2;
      int IZZ;
      int IORD;
      int NS;
      int IIF;
      double RGROUP;
      int IDNUM;
      std::string line;

      if(!disableOutput){
	printf("      \n Select one option (1 or 2):\n"
	       "   1: Enter composition data from the keyboard\n"
	       "   2: Read them from the file pdcompos.pen\n");
      }
      in >> IREAD;
      if (IREAD == 1)
	{
	  //  ************  Data entered from keyboard.

	  if(!disableOutput){
	    printf
	      ("Enter material name, for your information"
	       " (no more than 60 characters) ...\n");
	  }
	  //Ignore previous line
	  in.ignore(std::numeric_limits<std::streamsize>::max(),'\n');
	  std::getline(in,line);
	  sscanf(line.c_str(),"%62s", NAME);

	  if(!disableOutput){
	    printf (" Material: %s\n", NAME);
	  }

	  ZT = 0.0;
	  AT = 0.0;
	  EXPOT = 0.0;
	  //  ****  Chemical formula or fractions by weight.
	  for(;;){
	    if(!disableOutput){
	      printf (" Chemical formula:\n"
		      " Number of elements in the molecule...\n");
	    }
	    in >> NELEM;
	    if (NELEM < 1 || NELEM > 30)
	      {
		if(disableOutput){
		  printf("Error: Number of elements in the molecule must be positive"
			 " and less than 31\n");
		  ErrorFunction(1348);
		  return;
		}else{
		  printf (" NELEM must be positive and less than 31.\n");
		  printf (" Please, enter an allowed value.\n");
		  continue;
		}
	      }
	    break;
	  }
	  if(!disableOutput){
	    printf (" Number of elements = %2d\n", NELEM);
	  }

	  if (NELEM == 1)
	    {
	      for(;;){
		if(!disableOutput){
		  printf ("\n Enter atomic number of the element...\n");
		}
		in >> IZZ;
		if (IZZ < 1 || IZZ > 99)
		  {
		    if(disableOutput){
		      printf ("Error: The atomic number must be in the range 1-99.\n");
		      ErrorFunction(1348);
		      return;
		    }else{		  
		      printf (" The atomic number must be in the range 1-99.\n");
		      printf (" Please, enter an allowed value.\n");
		      continue;
		    }
		  }
		break;
	      }
	      IZ[0] = IZZ;
	      STF[0] = 1.0;
	      if(!disableOutput){
		printf ("  Element: %2s (Z=%2d), atoms/molecule = %12.5E\n",
			LASYMB[IZZ - 1], IZZ, STF[0]);
	      }
	      ZT = IZZ;
	      AT = ATW[IZZ - 1];
	      EXPOT = IZZ * log (EPX[IZZ - 1]);
	    }
	  else
	    {
	      if(!disableOutput){
		printf (" Select one option (1 or 2):\n"
			"   1: Enter chemical (stoichiometric) formula\n"
			"   2: Enter fraction by weight of each element\n");
	      }
	      in >> IREAD2;

	      if (IREAD2 == 2)
		{
		  if(!disableOutput){
		    printf ("\n Weight fractions...\n");
		  }
		  for (int I = 0; I < NELEM; I++)
		    {
		      for(;;)
			{
			  if(!disableOutput){
			    printf("  Enter atomic number and fraction by weight of the ");
			    if (I == 0)
			      {
				printf("first element ...\n");
			      }
			    else if (I == 1)
			      {
				printf("second element ...\n");
			      }
			    else if (I == 2)
			      {
				printf("third element ...\n");
			      }
			    else
			      {
				printf("%d-th element ...\n",I + 1);
			      }
			  }
			  in >> IZZ;
			  in >> FBW[I];
			  if (IZZ < 1 || IZZ > 99)
			    {
			      if(disableOutput){
				printf("Error: The atomic number must be in the range 1-99.\n");
				ErrorFunction(1348);
				return;
			      }else{
				printf(" The atomic number must be in the range 1-99.\n");
				printf (" Please, enter an allowed value.\n");
				continue;
			      }
			    }
			  if (FBW[I] <= 0.0)
			    {
			      if(disableOutput){
				printf("Error: The fraction by weight must be positive.\n");
				ErrorFunction(1348);
				return;
			      }else{			    
				printf(" The fraction by weight must be positive.\n");
				printf (" Please, enter a positive value.\n");
				continue;
			      }
			    }
			  break;
			}
		    
		      IZ[I] = IZZ;
		      if(!disableOutput){
			printf("\n  Element: %2s (Z=%2d), fraction by weight = %12.5E\n",
			       LASYMB[IZZ - 1], IZZ, FBW[I]);
		      }
		      if (I > 0)
			{
			  for (int K = 0; K <= I - 1; K++)
			    {
			      if (IZZ == IZ[K])
				{
				  ErrorFunction (1101);
				  return;
				}
			    }
			}
		      STF[I] = FBW[I] / ATW[IZZ - 1];
		    }		//END FOR I

		  double STFM = 0.0;
		  for (int I = 0; I < NELEM; I++)
		    {
		      if (STF[I] > STFM)
			{
			  STFM = STF[I];
			}
		    }
		  if (STFM < 1.0E-16)
		    {
		      ErrorFunction (1102);
		      return;
		    };
		  for (int I = 0; I < NELEM; I++)
		    {
		      STF[I] = STF[I] / STFM;
		    }

		  printf ("\n");
		  for (int I = 0; I < NELEM; I++)
		    {
		      IZZ = IZ[I];
		      if(!disableOutput){
			printf ("  Element: %2s (Z=%2d) atoms/molecule = %12.5E\n",
				LASYMB[IZZ - 1], IZZ, STF[I]);
		      }
		      ZT = ZT + IZZ * STF[I];
		      AT = AT + ATW[IZZ - 1] * STF[I];
		      EXPOT = EXPOT + IZZ * log (EPX[IZZ - 1]) * STF[I];
		    }
		}
	      else			//IREAD2=1
		{

		  if(!disableOutput){		
		    printf (" Stoichiometric indexes...\n");
		  }
		  for (int I = 0; I < NELEM; I++)
		    {
		      for(;;)
			{
			  if(!disableOutput){
			    printf("  Enter atomic number and number of atoms/molecule of the "); 
			    if (I == 0)
			      {
				printf("first element ...\n");
			      }
			    else if (I == 1)
			      {
				printf("second element ...\n");
			      }
			    else if (I == 2)
			      {
				printf("third element ...\n");
			      }
			    else
			      {
				printf("%d-th element ...", I + 1);
			      }
			  }
			  in >> IZZ;
			  in >> STF[I];
			  if (IZZ < 1 || IZZ > 99)
			    {
			      if(disableOutput){
				printf("Error: The atomic number must be in the range 1-99.\n");
				ErrorFunction(900);
				return;
			      }else{
				printf(" The atomic number must be in the range 1-99.\n");
				printf (" Please, enter an allowed value.\n");
				continue;
			      }
			    }
			  if (STF[I] <= 0.0)
			    {
			      if(disableOutput){
				printf("Error: The stoichiometric fraction must be positive.\n");
				ErrorFunction(900);
				return;			      
			      }else{
				printf(" The stoichiometric fraction must be positive.\n");
				printf (" Please, enter a positive value.\n");
				continue;
			      }
			    }
			  break;
			}
		      IZ[I] = IZZ;
		      if(!disableOutput){		    
			printf ("  Element %s (Z=%2d), atoms/molecule = %12.5E\n",
				LASYMB[IZZ - 1], IZZ, STF[I]);
		      }
		      if (I > 0)
			{
			  for (int K = 0; K <= I - 1; K++)
			    {
			      if (IZZ == IZ[K])
				{
				  ErrorFunction (1103);
				  return;
				}
			    }
			}
		      ZT = ZT + IZZ * STF[I];
		      AT = AT + ATW[IZZ - 1] * STF[I];
		      EXPOT = EXPOT + IZZ * log (EPX[IZZ - 1]) * STF[I];
		    }
		}
	    }

	  EXPOT = exp (EXPOT / ZT);
	
	  if(!disableOutput){	
	    printf ("\n  The calculated mean excitation energy I is %12.5E eV\n",
		    EXPOT);
	    printf (" Do you want to change it?   (1=yes,2=no)\n");
	  }
	  int IYESNO;
	  in >> IYESNO;
	  if (IYESNO == 1)
	    {	    
	      for(;;)
		{
		  if(!disableOutput){
		    printf ("\n Enter mean excitation energy (eV) ...\n");
		  }
		  in >> EXPOT;
		  if(!disableOutput){
		    printf ("  Mean excitation energy =%12.5E eV\n", EXPOT);
		  }
		  if (EXPOT < 1.0)
		    {
		      if(disableOutput){
			printf("Error: The mean exc. energy must be larger than 1 eV.\n");
			ErrorFunction(900);
			return;
		      }else{
			printf(" The mean exc. energy must be larger than 1 eV.\n");
			printf(" Please, enter a valid value.\n");
			continue;
		      }
		    }
		  break;
		}
	    }

	  for(;;)
	    {
	      if(!disableOutput){
		printf ("\n Enter mass density (g/cm^3) ...\n");
	      }
	      in >> RHO;
	      if(!disableOutput){
		printf ("  Density = %12.5E g/cm**3\n", RHO);
	      }
	      if (RHO <= 0.0)
		{
		  if(disableOutput){
		    printf ("Error: The mass density must be positive.\n");
		    ErrorFunction(900);
		    return;
		  }else{
		    printf (" The mass density must be positive.\n");
		    printf (" Please, enter a positive value.\n");
		    continue;
		  }
		}
	      break;
	    }
	  VMOL = AVOG * RHO / AT;
	}
      else
	{
	  //
	  //  ************  Material data read from file 'pdcompos.pen'.
	  //
	  if(!disableOutput){
	    printf (" Enter material identification number ...\n");
	  }
	  in >> IDNUM;
	  if (IDNUM < 1 || IDNUM > 300)
	    {
	      ErrorFunction (1104);
	      return;
	    }

	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile("pdcompos.pen",0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: 'pdcompos.pen'\n");	    
	    ErrorFunction(901);
	    return;
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([](unsigned i){
	    return penred::penMatDB::readDataBaseFile("pdcompos.pen",i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: 'pdcompos.pen'\n");	    
	    ErrorFunction(901);
	    return;
	  }

	  for (int I = 0; I < 15; I++)	//Skip 15 lines
	    {
	      iss.ignoreLine();
	    }
	  for (int K1 = 0; K1 < 300; K1++)
	    {
	      iss.getline(line);
	      sscanf(line.c_str(), "%3d %62c", &IORD, NAME);
	      //Append end of string chars
	      NAME[62] = '\0';
	      double HOLLOW;
	      iss.getline(line);
	      sscanf(line.c_str(), "%d %lf %lf %lf",
		     &NELEM, &HOLLOW, &EXPOT, &RHO);
	      if (NELEM > 30)
		{
		  ErrorFunction (1105);
		  return;
		}
	      if (NELEM < 1)
		{
		  ErrorFunction (1106);
		  return;
		}
	      for (int I = 0; I < NELEM; I++)
		{
		  iss.getline(line);
		  sscanf(line.c_str(), "%d %lf %lf",
			 &IZ[I], &HOLLOW, &STF[I]);
		}
	      if (IORD == IDNUM)
		{
		  break;
		}
	    }

	  if(!disableOutput){
	    printf ("  %3d %62s\n", IORD, NAME);
	  }

	  ZT = 0.0;
	  AT = 0.0;
	  for (int I = 0; I < NELEM; I++)
	    {
	      IZZ = IZ[I];
	      if (IZZ < 1 || IZZ > 99)
		{
		  printf ("Error: Element:    (Z=%2d), atoms/molecule = %12.5E\n", IZZ,
			  STF[I]);
		  ErrorFunction (1108);
		  return;
		}
	      if(!disableOutput){	    
		printf ("  Element: %s (Z=%2d), atoms/molecule =%12.5E\n",
			LASYMB[IZZ - 1], IZZ, STF[I]);
	      }
	      if (STF[I] <= 0.0)
		{
		  ErrorFunction (1109);
		  return;
		}
	      if (I > 0)
		{
		  for (int K = 0; K <= I - 1; K++)
		    {
		      if (IZZ == IZ[K])
			{
			  ErrorFunction (1110);
			  return;
			}
		    }
		}
	      ZT = ZT + IZZ * STF[I];
	      AT = AT + ATW[IZZ - 1] * STF[I];
	    }
	  if(!disableOutput){	
	    printf ("  Density = %12.5E g/cm**3\n", RHO);
	    printf ("  Number of electrons per molecule = %12.5E\n", ZT);
	  }
	  if (RHO <= 0.0)
	    {
	      ErrorFunction (1111);
	      return;
	    }
	  if(!disableOutput){
	    printf ("  Mean excitation energy = %12.5E eV\n", EXPOT);
	  }
	  VMOL = AVOG * RHO / AT;
	}

      //  ************  Atomic configuration.

      for (int I = 0; I < 99; I++)
	{
	  NSHT[I] = 0;
	  for (int J = 0; J < 30; J++)
	    {
	      EB[I][J] = 0.0;
	      CP0[I][J] = 0.0;
	      IFI[I][J] = 0;
	      IKS[I][J] = 0;
	    }
	}
      for (int I = 0; I < NELEM; I++)
	{
	  IZZ = IZ[I];
	  //  ****  Loads element data only once. NSHT(IZZ) is used as a status
	  //        indicator.
	  if (NSHT[IZZ - 1] == 0)
	    {

	      //Ensure data base existence and get it
	      const char* const pdata = penred::penMatDB::readDataBaseFile("pdatconf.p14",0);
	      if(pdata == nullptr){
		printf("Error: Data base file not found: 'pdatconf.p14'\n");	    
		ErrorFunction(901);
		return;
	      }

	      //Set the new string to the stream
	      penred::dataBases::literalArrayStream iss([](unsigned i){
		return penred::penMatDB::readDataBaseFile("pdatconf.p14",i);
	      });
	      if(!iss){
		printf("Error: Unable to create stream from "
		       "data base file: 'pdatconf.p14'\n");	    		
		ErrorFunction(901);
		return;
	      }
	  
	      for (int J = 0; J < 22; J++) //Skip 22 lines
		{
		  iss.ignoreLine();
		}
	      NS = 0;
	      int IZZT = 0;
	      for (int J = 0; J < 150000; J++)
		{
		  int IS, IIZ;
		  char CH2[3];
		  char CH5[6];
		  double EIE, CCP, GA1, GA2;

		  iss.getline(line);
		  if(iss.eof()){
		    break;
		  }
		  sscanf(line.c_str(),
			 "%3d %4d %2s %5s %3d %lf %lf %lf %lf", &IIZ,
			 &IS, CH2, CH5, &IIF, &EIE, &CCP, &GA1, &GA2);

		  if (IIZ == IZZ)
		    {
		      NS = NS + 1;
		      if (NS > 30)
			{
			  printf ("Error: NS =%4d\n", NS);
			  ErrorFunction (1112);
			  return;
			}
		      if (IS < 1 || IS > 30)
			{
			  printf ("Error: IS =%4d\n", IS);
			  ErrorFunction (1113);
			  return;
			}
		      IZZT = IZZT + IIF;
		      EB[IZZ - 1][IS - 1] = EIE;
		      if (GA2 > 0.0)
			{
			  ALW[IZZ - 1][IS - 1] = GA2;
			}
		      else if (GA1 > 0.0)
			{
			  ALW[IZZ - 1][IS - 1] = GA1;
			}
		      else
			{
			  ALW[IZZ - 1][IS - 1] = 0.0;
			}
		      CP0[IZZ - 1][IS - 1] = CCP;
		      IFI[IZZ - 1][IS - 1] = IIF;
		      IKS[IZZ - 1][NS - 1] = IS;
		    }
		}
	      NSHT[IZZ - 1] = NS;
	      if (IZZ != IZZT)
		{
		  ErrorFunction (1114);
		  return;
		}
	    }
	}

      //  ************  E/P inelastic scattering model parameters.

      //  ****  Set the oscillator table (analogous to ICRU37).

      for (int I = 0; I < NO; I++)
	{
	  F[I] = 0.0;
	  UI[I] = 0.0;
	  WRI[I] = 0.0;
	  KZ[I] = 0;
	  KS[I] = 0;
	}

      for (int I = 0; I < NOM; I++)
	{
	  FF[I] = 0.0;
	  UUI[I] = 0.0;
	  WWRI[I] = 0.0;
	  FFJ0[I] = 0.0;
	  KKZ[I] = 0;
	  KKS[I] = 0;
	}
      double FT = 0.0;
      //  ****  The 1st oscillator corresponds to the conduction band, which is
      //  tentatively assumed to consist of valence electrons (each atom con-
      //  tributes a number of electrons equal to its lowest chemical valence).
      int NOS = 1;
      FF[0] = 0.0;
      UUI[0] = 0.0;
      FFJ0[0] = 0.0;
      KKZ[0] = 0;
      KKS[0] = 30;
      for (int I = 0; I < NELEM; I++)
	{
	  IZZ = IZ[I];
	  FF[0] = FF[0] + fabs (VAL[IZZ - 1]) * STF[I];
	  for (int K = 0; K < 30; K++)
	    {
	      int JS = IKS[IZZ - 1][K];
	      if (JS > 0)
		{
		  NOS = NOS + 1;
		  if (NOS > NOM)
		    {
		      ErrorFunction (1115);
		      return;
		    }
		  FF[NOS - 1] = IFI[IZZ - 1][JS - 1] * STF[I];
		  UUI[NOS - 1] = EB[IZZ - 1][JS - 1];
		  FFJ0[NOS - 1] = CP0[IZZ - 1][JS - 1];
		  KKZ[NOS - 1] = IZZ;
		  if (IZZ > 2 && JS < 17)
		    {
		      KKS[NOS - 1] = JS;
		    }
		  else
		    {
		      KKS[NOS - 1] = 30;
		    }
		  FT = FT + FF[NOS - 1];
		}
	    }
	}

      if (fabs (FT - ZT) > 1.0E-10 * ZT)
	{
	  ErrorFunction (1116);
	  return;
	}
      //  ****  Oscillators are sorted by increasing ionisation energies.
      for (int I = 0; I < NOS - 1; I++)
	{
	  for (int J = I + 1; J < NOS; J++)
	    {
	      if (UUI[I] >= UUI[J])
		{
		  double SAVE = UUI[I];
		  UUI[I] = UUI[J];
		  UUI[J] = SAVE;
		  SAVE = FF[I];
		  FF[I] = FF[J];
		  FF[J] = SAVE;
		  SAVE = FFJ0[I];
		  FFJ0[I] = FFJ0[J];
		  FFJ0[J] = SAVE;
		  int ISAVE = KKZ[I];
		  KKZ[I] = KKZ[J];
		  KKZ[J] = ISAVE;
		  ISAVE = KKS[I];
		  KKS[I] = KKS[J];
		  KKS[J] = ISAVE;
		}
	    }
	}

      //  ************  Plasma energy and conduction band excitations.

      OP2 = FOURPI * ZT * VMOL * pow (A0B, 3) * pow (HREV, 2);
      double OMEGA = sqrt (OP2);
      double EPP = OMEGA * sqrt (FF[0] / ZT);
      if(!disableOutput){
	printf("\n  Estimated oscillator strength and energy"
	       " of the plasmon:\n  Fcb = %12.5E,  Wcb = %12.5E, eV,\n"
	       "  (for insulators, these quantities should be set equal to zero)\n",
	       FF[0], EPP);
      
	printf("\n  Do you wish to change the Fcb and Wcb values?"
	       "   (1=yes,2=no)\n  (type 2 if you are not sure...)\n");
      }
      int IPLOSP;
      int IFCB = 0;
      in >> IPLOSP;

      double FP, EP;
      if (IPLOSP == 1)
	{
	  if(!disableOutput){
	    printf("\n Enter the oscillator strength Fcb and energy Wcb"
		   " (in eV) of the plasmon ...\n");
	  }
	  in >> FP;
	  in >> EP;
	  if (FP < 0.5)
	    {
	      FP = 0.0;
	      EP = 0.0;
	    }
	  else if (EP < 0.1)
	    {
	      EP = OMEGA * sqrt (FP / ZT);
	    }
	}
      else
	{
	  EP = EPP;
	  FP = FF[0];
	}
      if(!disableOutput){
	printf ("\n  Fcb =%12.5E, Wcb =%12.5E, eV\n", FP, EP);
      }
      if (FP > ZT + 1.0E-13)
	{
	  ErrorFunction (1117);
	  return;
	}
      if (EP < 1.0 || FP < 0.5)
	{
	  //  ****  Insulator. There is no conduction band.
	  for (int J = 0; J < NOS - 1; J++)
	    {
	      FF[J] = FF[J + 1];
	      UUI[J] = UUI[J + 1];
	      FFJ0[J] = FFJ0[J + 1];
	      KKZ[J] = KKZ[J + 1];
	      KKS[J] = KKS[J + 1];
	    }
	  NOS = NOS - 1;
	}
      else
	{
	  //  ****  Conductor. Outer shells are 'moved' to the c.b.
	  IFCB = 1;
	  int IDEAD = 0;
	  double FPP = FP;
	  int I = 0;
	  for(;;)
	    {
	      I = I + 1;
	      if (FF[I] < FPP)
		{
		  FPP = FPP - FF[I];
		  FF[I] = 0.0;
		  IDEAD = IDEAD + 1;
		  continue;
		}
	      else
		{
		  FF[I] = FF[I] - FPP;
		  if (fabs (FF[I]) < 1.0E-12)
		    {
		      FP = FP + FF[I];
		      FF[I] = 0.0;
		      IDEAD = IDEAD + 1;
		    }
		}
	      break;
	    }
	  FF[0] = FP;
	  UUI[0] = 0.0;
	  WWRI[0] = EP;
	  FFJ0[0] = 0.75 / sqrt (3.0 * PI * PI * VMOL * pow (A0B, 3) * FP);
	  KKZ[0] = 0;
	  KKS[0] = 30;
	  if (IDEAD > 0)
	    {
	      for (int J = 1; J < NOS - IDEAD; J++)
		{
		  FF[J] = FF[J + IDEAD];
		  UUI[J] = UUI[J + IDEAD];
		  FFJ0[J] = FFJ0[J + IDEAD];
		  KKZ[J] = KKZ[J + IDEAD];
		  KKS[J] = KKS[J + IDEAD];
		}
	      NOS = NOS - IDEAD;
	    }
	}
      //  ****  Check f-sum rule.
      double SUM = 0.0;
      double FACT;
      for (int J = 0; J < NOS; J++)
	{
	  SUM = SUM + FF[J];
	}
      if (fabs (SUM - ZT) > 1.0E-6 * ZT)
	{
	  ErrorFunction (1118);
	  return;
	}
      if (fabs (SUM - ZT) > 1.0E-12 * ZT)
	{
	  FACT = ZT / SUM;
	  for (int J = 0; J < NOS; J++)
	    {
	      FF[J] = FACT * FF[J];
	    }
	}

      //  ****  Initial parameters for Compton scattering (before grouping).

      int NOSTC = NOS;
      double CSUMT = 0.0;
      for (int I = 0; I < NOSTC; I++)
	{
	  FC[I] = FF[I];
	  UIC[I] = UUI[I];
	  FJ0C[I] = FFJ0[I];
	  KZC[I] = KKZ[I];
	  KSC[I] = KKS[I];
	  CSUMT = CSUMT + FC[I] * FJ0C[I];
	}

      //  ************  Sternheimer's adjustment factor.

      double TST, AAL, AAU, AA = 0.0;
      if (NOS > 1)
	{
	  TST = ZT * log (EXPOT);
	  AAL = 0.5;
	  AAU = 10.0;
	  for(;;)
	    {
	      AA = 0.5 * (AAL + AAU);
	      SUM = 0.0;
	      for (int I = 0; I < NOS; I++)
		{
		  if (I == 0 && IFCB == 1)
		    {
		      SUM = SUM + FF[0] * log (WWRI[0]);
		    }
		  else
		    {
		      double WI2 =
			pow (AA * UUI[I],
			     2) +
			0.666666666666666 * (FF[I] / ZT) * pow (OMEGA, 2);
		      WWRI[I] = sqrt (WI2);
		      SUM = SUM + FF[I] * log (WWRI[I]);
		    }
		}
	      if (SUM < TST)
		{
		  AAL = AA;
		}
	      else
		{
		  AAU = AA;
		}
	      if (AAU - AAL > 1.0E-14 * AA)
		{
		  continue;
		}
	      break;
	    }
	}
      else
	{
	  UUI[0] = fabs (UUI[0]);
	  WWRI[0] = EXPOT;
	}

      if(!disableOutput){
	printf ("\n  Sternheimer adjustment factor = %12.5E\n", AA);
      }
      //  ****  Verification.
      double EXPT;
      EXPT = FF[0] * log (WWRI[0]);
      TST = FF[0];
      if (NOS > 1)
	{
	  for (int I = 1; I < NOS; I++)
	    {
	      EXPT = EXPT + FF[I] * log (WWRI[I]);
	      TST = TST + FF[I];
	    }
	}

      if (fabs (TST - ZT) > 1.0E-8 * ZT)
	{
	  printf ("Error: TST-ZT = %12.5E\n", TST - ZT);
	  ErrorFunction (1119);
	  return;
	}
      EXPT = exp (EXPT / ZT);
      if (fabs (EXPT - EXPOT) > 1.0E-8 * EXPOT)
	{
	  printf ("EXPT-EXPOT(M) =%12.5E\n", EXPT - EXPOT);
	  printf ("Error in the calculation of the Sternheimer factor.\n");
	  printf ("\n  Number of oscillators  = %3d\n", NOS);
	  for (int I = 0; I < NOS; I++)
	    {
	      printf ("%4d %13.5E %13.5E %13.5E %13.5E %4d %4d", I, FF[I], UUI[I],
		      WWRI[I], FFJ0[I], KKZ[I], KKS[I]);
	    }
	  ErrorFunction (1120);
	  return;
	}

      //  ****  Selection of the lowest ionisation energy for inner shells.
      //  Only the K, L, M and N shells with ionisation energies greater than
      //  that of the N7 shell of the heaviest element in the material are
      //  considered as inner shells. As a result, the inner/outer character
      //  of an atomic shell depends on the composition of the material.

      int IZMAX = 0;
      for (int I = 0; I < NELEM; I++)
	{
	  if (IZMAX < IZ[I])
	    {
	      IZMAX = IZ[I];
	    }
	}
      int JBM = 0;
      for (int J = 0; J < 16; J++)
	{
	  if (EB[IZMAX - 1][J] > 40.0)
	    {
	      JBM = J;
	    }
	}
      double WISCUT;
      if (50.0 > EB[IZMAX - 1][JBM] - 0.1)
	{
	  WISCUT = 50.0;
	}
      else
	{
	  WISCUT = EB[IZMAX - 1][JBM] - 0.1;
	}

      if(!disableOutput){
	printf ("\n  Inner-shell lowest energy = %12.5E eV\n", WISCUT);
      }
    
      int NOST;
      bool Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  NOST = NOS;
	  for (int I = 0; I < NOST; I++)
	    {
	      FFT[I] = FF[I];
	      UIT[I] = UUI[I];
	      WRIT[I] = WWRI[I];
	      KZT[I] = KKZ[I];
	      KST[I] = KKS[I];
	    }
	  //  ****  Oscillators are sorted by increasing resonance energies.
	  if (NOST > IFCB + 1)
	    {
	      for (int I = IFCB; I < NOST - 1; I++)
		{
		  for (int J = I + 1; J < NOST; J++)
		    {
		      if (WRIT[I] > WRIT[J])
			{
			  double SAVE;
			  SAVE = FFT[I];
			  FFT[I] = FFT[J];
			  FFT[J] = SAVE;
			  SAVE = UIT[I];
			  UIT[I] = UIT[J];
			  UIT[J] = SAVE;
			  SAVE = WRIT[I];
			  WRIT[I] = WRIT[J];
			  WRIT[J] = SAVE;
			  int ISAVE = KZT[I];
			  KZT[I] = KZT[J];
			  KZT[J] = ISAVE;
			  ISAVE = KST[I];
			  KST[I] = KST[J];
			  KST[J] = ISAVE;
			}
		    }
		}
	    }

	  //  ****  Oscillators of outer shells with resonance energies differing
	  //  by a factor less than RGROUP are grouped as a single oscillator.

	  RGROUP = 1.05;
	  bool Eixir2 = false;
	  while (!Eixir2)
	    {
	      Eixir2 = true;
	      int NINSH = 0;
	      for (int J = 0; J < NOST; J++)
		{
		  if (KST[J] < 17 && UIT[J] > WISCUT)
		    {
		      NINSH = NINSH + 1;
		    }
		}
	      int IELIM = 0;
	      if (NOST > IFCB + 1)
		{
		  for (int I = IFCB; I < NOST - 1; I++)
		    {
		      // Keep K shells of low-Z atoms as inner shells.
		      if (KST[I] < 2 && KZT[I] > 3)
			{
			  continue;
			}
		      if (KST[I + 1] < 2 && KZT[I + 1] > 3)
			{
			  continue;
			}

		      if (KST[I] < 17 && UIT[I] > WISCUT)
			{
			  continue;
			}
		      if (KST[I + 1] < 17 && UIT[I + 1] > WISCUT)
			{
			  continue;
			}
		      if (WRIT[I] < 1.0 || WRIT[I + 1] < 1.0)
			{
			  continue;
			}
		      if (WRIT[I + 1] > RGROUP * WRIT[I])
			{
			  continue;
			}
		      WRIT[I] =
			exp ((FFT[I] * log (WRIT[I]) +
			      FFT[I + 1] * log (WRIT[I + 1])) / (FFT[I] + FFT[I +
									      1]));
		      UIT[I] =
			(FFT[I] * UIT[I] + FFT[I + 1] * UIT[I + 1]) / (FFT[I] +
								       FFT[I +
									   1]);
		      FFT[I] = FFT[I] + FFT[I + 1];
		      if (KZT[I] != KZT[I + 1])
			{
			  KZT[I] = 0;
			}
		      KST[I] = 30;
		      if (I + 1 < NOST - 1)
			{
			  for (int J = I + 1; J < NOST - 1; J++)
			    {
			      FFT[J] = FFT[J + 1];
			      UIT[J] = UIT[J + 1];
			      WRIT[J] = WRIT[J + 1];
			      KZT[J] = KZT[J + 1];
			      KST[J] = KST[J + 1];
			    }
			}
		      IELIM = IELIM + 1;
		      FFT[NOST - 1] = 0.0;
		      UIT[NOST - 1] = 0.0;
		      WRIT[NOST - 1] = 0.0;
		      KZT[NOST - 1] = 0;
		      KST[NOST - 1] = 0;
		    }
		}
	      if (IELIM > 0)
		{
		  NOST = NOST - IELIM;
		  if (NOST > IFCB + NINSH + 1)
		    {
		      Eixir2 = false;
		      continue;
		    }
		}
	      //  ****  E/P inelastic model parameters transferred to the final
	      //        arrays.
	      if (NOST < NO)
		{
		  if (RGROUP < 1.25)
		    {
		      RGROUP = pow (RGROUP, 2);
		      if (NOST > IFCB + NINSH + 5)
			{
			  Eixir2 = false;
			  continue;
			}
		    }
		  NOSC = NOST;
		  for (int I = 0; I < NOSC; I++)
		    {
		      F[I] = FFT[I];
		      UI[I] = UIT[I];
		      WRI[I] = WRIT[I];
		      if (UI[I] < 1.0E-3)
			{
			  UI[I] = 0.0;
			}
		      KZ[I] = KZT[I];
		      if (KST[I] < 2 && KZT[I] > 3)
			{
			  KS[I] = KST[I];
			}
		      else
			{
			  if (UI[I] > WISCUT)
			    {
			      KS[I] = KST[I];
			    }
			  else
			    {
			      KS[I] = 30;
			    }
			}
		    }
		}
	      else
		{
		  RGROUP = pow (RGROUP, 2);
		  if (RGROUP > 2.0)
		    {
		      WISCUT = 1.25 * WISCUT;
		      if(!disableOutput){
			printf ("  Inner-shell lowest energy = %12.5E eV\n",
				WISCUT);
		      }
		      Eixir = false;
		      break;
		    }
		  Eixir2 = false;
		  continue;
		}
	    }
	}

      if(!disableOutput){
	printf ("\n  E/P inel. grouping factor = %12.5E\n", RGROUP);
      }

      //  ************  Compton (impulse approximation) parameters.

      //  ****  Shells are sorted by increasing ionisation energies.
      if (NOSTC > 1)
	{
	  for (int I = 0; I < NOSTC - 1; I++)
	    {
	      for (int J = I + 1; J < NOSTC; J++)
		{
		  if (UIC[I] > UIC[J])
		    {
		      double SAVE = FC[I];
		      FC[I] = FC[J];
		      FC[J] = SAVE;
		      SAVE = UIC[I];
		      UIC[I] = UIC[J];
		      UIC[J] = SAVE;
		      SAVE = FJ0C[I];
		      FJ0C[I] = FJ0C[J];
		      FJ0C[J] = SAVE;
		      int ISAVE = KZC[I];
		      KZC[I] = KZC[J];
		      KZC[J] = ISAVE;
		      ISAVE = KSC[I];
		      KSC[I] = KSC[J];
		      KSC[J] = ISAVE;
		    }
		}
	    }
	}

      //  ****  Outer shells with ionisation energies differing by a factor
      //  less than RGROUP are grouped as a single shell.

      RGROUP = 1.05;
      for(;;)
	{
	  int NINSH = 0;
	  for (int J = 0; J < NOST; J++)
	    {
	      if (KSC[J] < 17 && UIC[J] > WISCUT)
		{
		  NINSH = NINSH + 1;
		}
	    }
	  int IELIM = 0;
	  if (NOSTC > IFCB + 1)
	    {
	      for (int I = IFCB; I < NOSTC - 1; I++)
		{
		  // Keep K shells of low-Z atoms as inner shells.
		  if (KSC[I] < 2 && KZC[I] > 3)
		    {
		      continue;
		    }
		  if (KSC[I + 1] < 2 && KZC[I + 1] > 3)
		    {
		      continue;
		    }

		  if (KSC[I] < 17 && UIC[I] > WISCUT)
		    {
		      continue;
		    }
		  if (KSC[I + 1] < 17 && UIC[I + 1] > WISCUT)
		    {
		      continue;
		    }
		  if (UIC[I] < 1.0 || UIC[I + 1] < 1.0)
		    {
		      continue;
		    }
		  if (UIC[I + 1] > RGROUP * UIC[I])
		    {
		      continue;
		    }
		  UIC[I] =
		    (FC[I] * UIC[I] + FC[I + 1] * UIC[I + 1]) / (FC[I] +
								 FC[I + 1]);
		  FJ0C[I] =
		    (FC[I] * FJ0C[I] + FC[I + 1] * FJ0C[I + 1]) / (FC[I] +
								   FC[I + 1]);
		  FC[I] = FC[I] + FC[I + 1];
		  if (KZC[I] != KZC[I + 1])
		    {
		      KZC[I] = 0;
		    }
		  KSC[I] = 30;
		  if (I + 1 < NOSTC - 1)
		    {
		      for (int J = I + 1; J < NOSTC - 1; J++)
			{
			  FC[J] = FC[J + 1];
			  UIC[J] = UIC[J + 1];
			  FJ0C[J] = FJ0C[J + 1];
			  KZC[J] = KZC[J + 1];
			  KSC[J] = KSC[J + 1];
			}
		    }
		  IELIM = IELIM + 1;
		  FC[NOSTC - 1] = 0.0;
		  UIC[NOSTC - 1] = 0.0;
		  FJ0C[NOSTC - 1] = 0.0;
		  KZC[NOSTC - 1] = 0;
		  KSC[NOSTC - 1] = 0;
		}
	    }
	  if (IELIM > 0)
	    {
	      NOSTC = NOSTC - IELIM;
	      if (NOSTC > IFCB + NINSH + 1)
		{
		  continue;
		}
	    }
	  //  ****  Compton scattering model parameters transferred to the final
	  //        arrays.
	  if (NOSTC < NOCO)
	    {
	      if (RGROUP < 1.25)
		{
		  RGROUP = pow (RGROUP, 2);
		  if (NOSTC > IFCB + NINSH + 5)
		    {
		      continue;
		    }
		}
	      NOSCCO = NOSTC;
	      for (int I = 0; I < NOSCCO; I++)
		{
		  FCO[I] = FC[I];
		  UICO[I] = UIC[I];
		  FJ0[I] = FJ0C[I];
		  KZCO[I] = KZC[I];
		  if (KSC[I] < 2 && KZC[I] > 3)
		    {
		      KSCO[I] = KSC[I];
		    }
		  else if (UICO[I] > WISCUT)
		    {
		      KSCO[I] = KSC[I];
		    }
		  else
		    {
		      KSCO[I] = 30;
		    }
		  CSUMT = CSUMT - FCO[I] * FJ0[I];
		}
	      if (fabs (CSUMT) > 1.0E-9)
		{
		  printf ("  Residual sum = %12.5e\n", fabs (CSUMT));
		  ErrorFunction (1121);
		  return;
		}
	    }
	  else
	    {
	      RGROUP = pow (RGROUP, 2);
	      continue;
	    }
	  break;
	}

      if(!disableOutput){
	printf ("    Compton grouping factor = %12.5E\n", RGROUP);
      }

      //  ************  PENELOPE's input file.

      if(!disableOutput){
	printf ("\n PENELOPE''s material data file is being created.\n");
      }
      FILE *AuxFile;
      if (!filename.empty())
	{
	  AuxFile = fopen (filename.c_str(), "w");
	}
      else
	{
	  if(!disableOutput){
	    printf (" Enter path+name for this file (up to 80 characters) ...\n");
	  }
	  //Ignore previous line
	  in.ignore(std::numeric_limits<std::streamsize>::max(),'\n');	  
	  std::getline(in,line);
	  sscanf(line.c_str(), "%80s", PFILE);
	  AuxFile = fopen (PFILE, "w");
	}
      fprintf (AuxFile,
	       " PENELOPE (v. 2018)  Material data file ...............\n");
      fprintf (AuxFile, " Material: %-62s\n", NAME);
      fprintf (AuxFile, " Mass density =%15.8E g/cm**3\n", RHO);
      fprintf (AuxFile, " Number of elements in the molecule = %2d\n", NELEM);
      for (int I = 0; I < NELEM; I++)
	{
	  fprintf (AuxFile, "   atomic number =%3d,  atoms/molecule =%15.8E\n",
		   IZ[I], STF[I]);
	}
      fprintf (AuxFile, " Mean excitation energy =%15.8E eV\n", EXPOT);
      fprintf (AuxFile, " Number of oscillators =%3d (E/P inelastic model)\n",
	       NOSC);
      for (int I = 0; I < NOSC; I++)
	{
	  fprintf (AuxFile, "%4d%16.8E%16.8E%16.8E%4d%4d\n", I + 1, F[I],
		   UI[I], WRI[I], KZ[I], KS[I]);
	}

      fprintf (AuxFile, " Number of shells =%3d (Compton IA model)\n", NOSCCO);
      for (int I = 0; I < NOSCCO; I++)
	{
	  fprintf (AuxFile, "%4d%16.8E%16.8E%16.8E%4d%4d\n", I + 1, FCO[I],
		   UICO[I], FJ0[I], KZCO[I], KSCO[I]);
	  FJ0[I] = FJ0[I] * SL;
	}

      //  ****  Atomic relaxation data.

      for (int I = 0; I < NELEM; I++)
	{
	  IZZ = IZ[I];
	  RELAXW (IZZ, AuxFile);
	  if (IRETRN != 0)
	    {
	      return;
	    }
	}
      //  ****  Energy grid (standard).

      int NES = 0;
      int IGRID = 0;
      double FGRID = 1.0;
      for(;;)
	{
	  IGRID = IGRID + 1;
	  double EV = EGRT[IGRID - 1] * FGRID;
	  if (IGRID == 17)
	    {
	      IGRID = 1;
	      FGRID = 10.0 * FGRID;
	    }
	  if (EV < 49.0)
	    {
	      continue;
	    }
	  NES = NES + 1;
	  ES[NES - 1] = EV;
	  if (EV < 1.0E9)
	    {
	      continue;
	    }
	  break;
	}
      EMIN = 50.0;
      double EMAX = 1.0E9;
      EGRID (EMIN, EMAX);

      double WCRM = 10.0;
      double WCCM = 0.0;

      //  **** Electron and positron inner-shell ionisation x-sections.

      ESIaW (AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}
      PSIaW (AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}

      //  ****  Bremsstrahlung emission,

      EBRaW (AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}
      double ZEQ = sqrt (ZBR2);
      BRaAW (ZEQ, AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}

      fprintf (AuxFile,
	       " *** Stopping powers for electrons and positrons,  NDATA =%4d\n",
	       NES);
      fflush (AuxFile);
      double EE, ESTP, ERSTP, PSTP, PRSTP;
      double XH0, XH1, XH2, XS0, XS1, XS2, XT1, XT2, DELTA;
      for (int IE = 0; IE < NES; IE++)
	{
	  EE = ES[IE];
	  EINaT (EE, WCCM, XH0, XH1, XH2, XS0, XS1, XS2, XT1, XT2, DELTA);
	  ESTP = (XS1 + XH1) * VMOL * 1.0E-6 / RHO;
	  EBRaT (EE, WCRM, XH0, XH1, XH2, XS1, XS2);
	  if (IRETRN != 0)
	    {
	      return;
	    }
	  ERSTP = (XS1 + XH1) * VMOL * 1.0E-6 / RHO;
	  PINaT (EE, WCCM, XH0, XH1, XH2, XS0, XS1, XS2, XT1, XT2, DELTA);
	  PSTP = (XS1 + XH1) * VMOL * 1.0E-6 / RHO;
	  PBRaT (EE, WCRM, XH0, XH1, XH2, XS1, XS2);
	  if (IRETRN != 0)
	    {
	      return;
	    }
	  PRSTP = (XS1 + XH1) * VMOL * 1.0E-6 / RHO;
	  fprintf (AuxFile, "%10.3E%12.5E%12.5E%12.5E%12.5E\n", EE, ESTP, ERSTP,
		   PSTP, PRSTP);
	}

      //  **** Electron and positron elastic x-sections.
      EELaW (AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}
      EELdW (AuxFile);		// Uses the ELSEPA database.
      if (IRETRN != 0)
	{
	  return;
	}

      //  ****  Photon x-sections.

      GRAaW (AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}

      int NPTAB;
      GPPaW (EIT.data(), XGP0.data(), XGT0.data(), NPTAB);
      if (IRETRN != 0)
	{
	  return;
	}
      for (int I = 0; I < NES; I++)
	{
	  PPE[I] = 0.0;
	}
      int NESS;
      MERGE2 (ES.data(), PPE.data(), EIT.data(), XGP0.data(),
	      ESS.data(), PPT.data(), NES, NPTAB, NESS);
      if (IRETRN != 0)
	{
	  return;
	}
      for (int I = 0; I < NESS; I++)
	{
	  XGP0[I] = PPT[I];
	}
      for (int I = 0; I < NES; I++)
	{
	  PPE[I] = 0.0;
	}
      MERGE2 (ES.data(), PPE.data(), EIT.data(), XGT0.data(),
	      ESS.data(), PPT.data(), NES, NPTAB, NESS);
      if (IRETRN != 0)
	{
	  return;
	}
      for (int I = 0; I < NESS; I++)
	{
	  XGT0[I] = PPT[I];
	}

      fprintf (AuxFile,
	       " *** Compton and pair-production cross sections,  NDATA =%4d\n",
	       NESS);
      for (int IE = 0; IE < NESS; IE++)
	{
	  EE = ESS[IE];
	  double CSC;
	  GCOaT (EE, CSC);
	  if (CSC < 1.0E-35)
	    {
	      CSC = 0.0;
	    }
	  if (EE < TREV + 5.0)
	    {
	      XGP0[IE] = 0.0;
	    }
	  if (EE < 2.0 * TREV + 10.0)
	    {
	      XGT0[IE] = 0.0;
	    }
	  fprintf (AuxFile, "%10.3E%12.5E%12.5E%12.5E\n", EE, CSC, XGP0[IE],
		   XGT0[IE]);
	}

      GPHaW (AuxFile);
      if (IRETRN != 0)
	{
	  return;
	}

      fprintf (AuxFile,
	       " PENELOPE (v. 2018)  End of material data file ........\n");
      fclose (AuxFile);
    }

    //  *********************************************************************
    //                       SUBROUTINE EGRID
    //  *********************************************************************
    void materialCreator::EGRID (double EMINu, double EMAXu)
    {

      //This subroutine sets the energy grid where transport functions are
      //tabulated. The grid is logarithmically spaced and we assume that it
      //is dense enough to permit accurate linear log-log interpolation of
      //he tabulated functions.

      //  ****  Consistency of the interval end-points.

      if (EMINu < MINEGRID)
	{
	  EMINu = MINEGRID;
	}
      if (EMINu > EMAXu - 1.0)	//Mirem si la distancia entre EMINu i EMAXu, es d'1 eV com a minim
	{
	  printf ("   EMIN =%11.4E eV, EMAX =%11.4E eV\n", EMINu, EMAXu);
	  ErrorFunction (1007);
	  return;
	}

      //  ****  Energy grid points.

      EMIN = EMINu;
      EL = 0.99999 * EMINu;
      EU = 1.00001 * EMAXu;
      DLFC = log (EU / EL) / double (NEGP - 1);
      DLEMP1 = log (EL);
      DLEMP[0] = DLEMP1;
      ET[0] = EL;
      for (int I = 1; I < NEGP; I++)
	{
	  DLEMP[I] = DLEMP[I - 1] + DLFC;
	  ET[I] = exp (DLEMP[I]);
	}
      DLFC = (double) 1.0 / DLFC;

      //  NOTE: To determine the interval KE where the energy E is located, we
      //  do the following,
      //     XEL=LOG(E)
      //     XE=1.0D0+(XEL-DLEMP1)*DLFC
      //     KE=XE
      //     XEK=XE-KE  ! 'fractional' part of XE (used for interpolation).
      //
    }
    
    //  *********************************************************************
    //                       FUNCTION RLMOM
    //  *********************************************************************
    double materialCreator::RLMOM (double *X, double *FCT, double XC, int NPpar, int MOM)
    {
      //  Calculation of the integral of (X**MOM)*FCT(X) over the interval from
      //  X(1) to XC, obtained by linear interpolation on a table of FCT.
      //  The independent variable X is assumed to take only positive values.

      //    X ....... array of values of the variable (in increasing order).
      //    FCT ..... corresponding FCT values.
      //    NPpar ...... number of points in the table.
      //    XC ...... upper limit of the integral, X(1).LE.XC.LE.X(NP).
      //    MOM ..... moment order (GE.-1).
      //    RLMOM ... integral of (X**MOM)*FCT(X) over the interval from X(1)
      //              to XC.

      const double EPS = 1.0E-35;

      double RLMOM_RETURN = 0.0;
      if (MOM < -1)
	{
	  ErrorFunction (1319);
	  return RLMOM_RETURN;
	}
      if (NPpar < 2)
	{
	  ErrorFunction (1320);
	  return RLMOM_RETURN;
	}
      if (X[0] < 0.0)
	{
	  ErrorFunction (1321);
	  return RLMOM_RETURN;
	}
      for (int I = 1; I < NPpar; I++)
	{
	  if (X[I] < 0.0)
	    {
	      ErrorFunction (1322);
	      return RLMOM_RETURN;
	    }
	  if (X[I] < X[I - 1])
	    {
	      ErrorFunction (1323);
	      return RLMOM_RETURN;
	    }
	}

      RLMOM_RETURN = 0.0;
      if (XC < X[0])
	{
	  return RLMOM_RETURN;
	}
      int IEND = 0;

      double XT;
      if (XC < X[NPpar - 1])
	{
	  XT = XC;
	}
      else
	{
	  XT = X[NPpar - 1];
	}

      double X1, Y1, X2, Y2, XTC, DX, DY, A, B, DS;
      for (int I = 0; I < NPpar - 1; I++)
	{
	  if (X[I] < EPS)
	    {
	      X1 = EPS;
	    }
	  else
	    {
	      X1 = X[I];
	    }

	  Y1 = FCT[I];

	  if (X[I + 1] < EPS)
	    {
	      X2 = EPS;
	    }
	  else
	    {
	      X2 = X[I + 1];
	    }

	  Y2 = FCT[I + 1];
	  if (XT < X2)
	    {
	      XTC = XT;
	      IEND = 1;
	    }
	  else
	    {
	      XTC = X2;
	    }
	  DX = X2 - X1;
	  DY = Y2 - Y1;
	  if (fabs (DX) > 1.0E-14 * fabs (DY))
	    {
	      B = DY / DX;
	      A = Y1 - B * X1;
	      if (MOM == -1)
		{
		  DS = A * log (XTC / X1) + B * (XTC - X1);
		}
	      else
		{
		  DS =
		    A * (pow (XTC, (MOM + 1)) -
			 pow (X1, (MOM + 1))) / double (MOM + 1) + B * (pow (XTC,
									     (MOM
									      +
									      2))
									- pow (X1,
									       (MOM
										+
										2)))
		    / double (MOM + 2);
		}
	    }
	  else
	    {
	      DS = 0.5 * (Y1 + Y2) * (XTC - X1) * pow (XTC, MOM);
	    }
	  RLMOM_RETURN = RLMOM_RETURN + DS;
	  if (IEND != 0)
	    {
	      return RLMOM_RETURN;
	    }
	}
      return RLMOM_RETURN;
    }

    //  *********************************************************************
    //                       SUBROUTINE SPLINE
    //  *********************************************************************
    void materialCreator::SPLINE (double *X, double *Y, double *A, double *B,
				  double *C, double *D, double S1, double SN, int N)
    {
      //     Cubic spline interpolation of tabulated data.
      //
      //  Input:
      //     X(I) (I=1:N) ... grid points (the X values must be in increasing
      //                      order).
      //     Y(I) (I=1:N) ... corresponding function values.
      //     S1,SN .......... second derivatives at X(1) and X(N). The natural
      //                      spline corresponds to taking S1=SN=0.
      //     N .............. number of grid points.
      //  Output:
      //     A(I),B(I),C(I),D(I) (I=1:N) ... spline coefficients.
      //
      //  The interpolating cubic polynomial in the I-th interval, from X(I) to
      //  X(I+1), is
      //               P(x) = A(I)+x*(B(I)+x*(C(I)+x*D(I)))

      //  Reference: M.J. Maron, 'Numerical Analysis: a Practical Approach',
      //             MacMillan Publ. Co., New York, 1982.

      if (N < 4)
	{
	  printf
	    (" *** Error in SPLINE: interpolation cannot be performed with %4d points.\n",
	     N);
	  ErrorFunction (1904);
	  return;
	}
      int N1 = N - 1;
      int N2 = N - 2;
      int K;
      //  ****  Auxiliary arrays H(=A) and DELTA(=D).
      for (int I = 0; I < N1; I++)
	{
	  A[I] = X[I + 1] - X[I];
	  if (A[I] <
	      1.0E-12 *
	      ((fabs (X[I]) > fabs (X[I + 1])) ? fabs (X[I]) : fabs (X[I + 1])))
	    {
	      printf
		(" *** Error in SPLINE: X values not in increasing order.\n");
	      ErrorFunction (1905);
	      return;
	    }
	  D[I] = (Y[I + 1] - Y[I]) / A[I];
	}
      //  ****  Symmetric coefficient matrix (augmented).
      for (int I = 0; I < N2; I++)
	{
	  B[I] = 2.0 * (A[I] + A[I + 1]);
	  K = N1 - (I + 1) + 1;
	  D[K - 1] = 6.0 * (D[K - 1] - D[K - 2]);
	}
      D[1] = D[1] - A[0] * S1;
      D[N1 - 1] = D[N1 - 1] - A[N1 - 1] * SN;
      //  ****  Gauss solution of the tridiagonal system.
      for (int I = 1; I < N2; I++)
	{
	  double R = A[I] / B[I - 1];
	  B[I] = B[I] - R * A[I];
	  D[I + 1] = D[I + 1] - R * D[I];
	}
      //  ****  The SIGMA coefficients are stored in array D.
      D[N1 - 1] = D[N1 - 1] / B[N2 - 1];
      for (int I = 1; I < N2; I++)
	{
	  K = N1 - (I + 1) + 1;
	  D[K - 1] = (D[K - 1] - A[K - 1] * D[K + 1 - 1]) / B[K - 2];
	}
      D[N - 1] = SN;
      //  ****  Spline coefficients.
      double SI1 = S1;
      for (int I = 0; I < N1; I++)
	{
	  double SI = SI1;
	  SI1 = D[I + 1];
	  double H = A[I];
	  double HI = 1.0 / H;
	  A[I] =
	    (HI / 6.0) * (SI * pow (X[I + 1], 3) - SI1 * pow (X[I], 3)) +
	    HI * (Y[I] * X[I + 1] - Y[I + 1] * X[I]) + (H / 6.0) * (SI1 * X[I] -
								    SI * X[I +
									   1]);
	  B[I] =
	    (HI / 2.0) * (SI1 * pow (X[I], 2) - SI * pow (X[I + 1], 2)) +
	    HI * (Y[I + 1] - Y[I]) + (H / 6.0) * (SI - SI1);
	  C[I] = (HI / 2.0) * (SI * X[I + 1] - SI1 * X[I]);
	  D[I] = (HI / 6.0) * (SI1 - SI);
	}
      //  ****  Natural cubic spline for X.GT.X(N).
      double FNP =
	B[N1 - 1] + X[N - 1] * (2.0 * C[N1 - 1] + X[N - 1] * 3.0 * D[N1 - 1]);
      A[N - 1] = Y[N - 1] - X[N - 1] * FNP;
      B[N - 1] = FNP;
      C[N - 1] = 0.0;
      D[N - 1] = 0.0;

    }

    //  *********************************************************************
    //                       SUBROUTINE FINDI
    //  *********************************************************************
    void materialCreator::FINDI (double *X, double XC, int N, int &I)
    {
      //     This subroutine finds the interval (X(I),X(I+1)) that contains the
      //  value XC using binary search.

      //  Input:
      //     X(I) (I=1:N) ... grid points (the X values must be in increasing
      //                      order).
      //     XC ............. point to be located.
      //     N  ............. number of grid points.
      //  Output:
      //     I .............. interval index.

      if (XC > X[N - 1])
	{
	  I = N;
	  return;
	}
      if (XC < X[0])
	{
	  I = 1;
	  return;
	}
      I = 1;
      int I1 = N;
      bool Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  int IT = (I + I1) / 2;
	  if (XC > X[IT - 1])
	    {
	      I = IT;
	    }
	  else
	    {
	      I1 = IT;
	    }
	  if (I1 - I > 1)
	    {
	      Eixir = false;
	      continue;
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE ELINIT
    //  *********************************************************************
    void materialCreator::ELINIT (int *IZ, double *STF, int &NELEM)
    {
      //  This subroutine reads atomic elastic cross sections for electrons and
      //  positrons from the database files and determines the molecular cross
      //  section as the incoherent sum of atomic cross sections.

      //  Input arguments:
      //    IZ (1:NELEM) .... atomic numbers of the elements in the compound.
      //    STF (1:NELEM) ... stoichiometric indexes.
      //    NELEM ........... number of different elements.
      //

      const int NE = 96;

      double EGRD[16] =
	{ 1.0, 1.25, 1.50, 1.75, 2.00, 2.50, 3.00, 3.50, 4.00, 4.50, 5.00, 6.00,
	  7.00, 8.00, 9.00, 1.00E1 };

      const char LIT10[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

      //  ****  Energy mesh points (in eV).

      int IE = 0;
      int IGRID = 10;
      double FGRID = 10.0;
      double EV;
      bool Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  IGRID = IGRID + 1;
	  EV = EGRD[IGRID - 1] * FGRID;
	  if (IGRID == 16)
	    {
	      IGRID = 1;
	      FGRID = 10.0 * FGRID;
	    }
	  IE = IE + 1;
	  ETS[IE - 1] = EV;
	  ETL[IE - 1] = log (ETS[IE - 1]);
	  if (IE < NE)
	    {
	      Eixir = false;
	      continue;
	    }
	}

      //  ****  Angular grid (TH in deg, XMU=(1.0D0-COS(TH))/2).

      int I = 1;
      TH[I - 1] = 0.0;
      THR[I - 1] = TH[I - 1] * PI / 180.0;
      XMU[I - 1] = (1.0 - cos (THR[I - 1])) / 2.0;
      XMUL[I - 1] = log (1.0E-35);
      I = 2;
      TH[I - 1] = 1.0E-4;
      THR[I - 1] = TH[I - 1] * PI / 180.0;
      XMU[I - 1] = (1.0 - cos (THR[I - 1])) / 2.0;

      if (XMU[I - 1] < 1.0E-35)
	{
	  XMUL[I - 1] = log (1.0E-35);
	}
      else
	{
	  XMUL[I - 1] = log (XMU[I - 1]);
	}

      Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  I = I + 1;
	  if (TH[I - 1 - 1] < 0.9999E-3)
	    {
	      TH[I - 1] = TH[I - 1 - 1] + 2.5E-5;
	    }
	  else if (TH[I - 1 - 1] < 0.9999E-2)
	    {
	      TH[I - 1] = TH[I - 1 - 1] + 2.5E-4;
	    }
	  else if (TH[I - 1 - 1] < 0.9999E-1)
	    {
	      TH[I - 1] = TH[I - 1 - 1] + 2.5E-3;
	    }
	  else if (TH[I - 1 - 1] < 0.9999)
	    {
	      TH[I - 1] = TH[I - 1 - 1] + 2.5E-2;
	    }
	  else if (TH[I - 1 - 1] < 0.9999E+1)
	    {
	      TH[I - 1] = TH[I - 1 - 1] + 1.0E-1;
	    }
	  else if (TH[I - 1 - 1] < 2.4999E+1)
	    {
	      TH[I - 1] = TH[I - 1 - 1] + 2.5E-1;
	    }
	  else
	    {
	      TH[I - 1] = TH[I - 1 - 1] + 5.0E-1;
	    }
	  THR[I - 1] = TH[I - 1] * PI / 180.0;

	  XMU[I - 1] = (1.0 - cos (THR[I - 1])) / 2.0;
	  if (XMU[I - 1] < 1.0E-35)
	    {
	      XMU[I - 1] = 1.0E-35;
	    }

	  if (XMU[I - 1] < 1.0E-35)
	    {
	      XMUL[I - 1] = log (1.0E-35);
	    }
	  else
	    {
	      XMUL[I - 1] = log (XMU[I - 1]);
	    }

	  if (I < NA)
	    {
	      Eixir = false;
	      continue;
	    }
	}

      for (IE = 0; IE < NE; IE++)
	{
	  ECS[IE] = 0.0;
	  ETCS1[IE] = 0.0;
	  ETCS2[IE] = 0.0;
	  PCS[IE] = 0.0;
	  PTCS1[IE] = 0.0;
	  PTCS2[IE] = 0.0;
	  for (int IA = 0; IA < NA; IA++)
	    {
	      EDCS[IE][IA] = 0.0;
	      PDCS[IE][IA] = 0.0;
	    }
	}

      //  ****  Read atomic DCS tables and compute the molecular DCS as the
      //        incoherent sum of atomic DCSs.

      for (int IEL = 0; IEL < NELEM; IEL++)
	{
	  int IZZ = IZ[IEL];
	  double STFF = STF[IEL];
	  int NS = IZ[IEL];
	  if (NS > 999)
	    {
	      NS = 999;
	    }
	  int NS1 = NS - 10 * (NS / 10);
	  NS = (NS - NS1) / 10;
	  int NS2 = NS - 10 * (NS / 10);
	  NS = (NS - NS2) / 10;
	  int NS3 = NS - 10 * (NS / 10);

	  //Construct database filename
	  std::string pdfFile("eeldx");
	  pdfFile.append(1, LIT10[NS3]);
	  pdfFile.append(1, LIT10[NS2]);
	  pdfFile.append(1, LIT10[NS1]);
	  pdfFile.append(".p08");
      
	  //Ensure data base existence and get it
	  const char* const pdata = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(pdata == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction (901);
	    return;
	  }

	  //Create a stream to read it
	  penred::dataBases::literalArrayStream iss([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n", pdfFile.c_str());	    
	    ErrorFunction (901);
	    return;
	  }
	  std::string line;

      
	  int IELEC, IZR;
	  double ENR, CSE, TCS1E, TCS2E, CSP, TCS1P, TCS2P;
	  for (IE = 0; IE < NE; IE++)
	    {
	      iss.getline(line);
	      sscanf(line.c_str(), "%d %d %lf %lf %lf %lf",
		     &IELEC, &IZR, &ENR, &CSE, &TCS1E, &TCS2E);

	      if (IELEC != -1 || IZR != IZZ || fabs (ENR - ETS[IE]) > 1.0E-3)
		{
		  printf("Fatal Error in ELINIT. Corrupt data file '%s' part %u.\n"
			 "line: %s\n"
			 "    IELEC   : %d\n"
			 "    IZR     : %d\n"
			 "    ENR     : %15.5E\n"
			 "    ETS[IE] : %15.5E\n"
			 "    CSE     : %15.5E\n"
			 "    TCS1E   : %15.5E\n"
			 "    TCS2E   : %15.5E\n",
			 pdfFile.c_str(), iss.partition(), line.c_str(),
			 IELEC, IZR, ENR, ETS[IE], CSE, TCS1E, TCS2E);
		  ErrorFunction (1355);
		  return;
		}
	      for (int IA = 0; IA < NA; IA++)
		{
		  iss >> DCSI[IA];
		}
	      //Ignore remaining line
	      iss.ignoreLine();
	      
	      ECS[IE] = ECS[IE] + STFF * CSE;
	      ETCS1[IE] = ETCS1[IE] + STFF * TCS1E;
	      ETCS2[IE] = ETCS2[IE] + STFF * TCS2E;
	      for (int IA = 0; IA < NA; IA++)
		{
		  EDCS[IE][IA] = EDCS[IE][IA] + STFF * DCSI[IA];
		}
	    }

	  //Construct database filename
	  pdfFile.assign("peldx");
	  pdfFile.append(1, LIT10[NS3]);
	  pdfFile.append(1, LIT10[NS2]);
	  pdfFile.append(1, LIT10[NS1]);
	  pdfFile.append(".p08");
      
	  //Ensure data base existence and get it
	  const char* const peldx = penred::penMatDB::readDataBaseFile(pdfFile,0);
	  if(peldx == nullptr){
	    printf("Error: Data base file not found: '%s'\n",pdfFile.c_str());	    
	    ErrorFunction(901);
	    return;
	  }

	  //Assign the new data to the stream
	  iss.str([pdfFile](unsigned i){
	    return penred::penMatDB::readDataBaseFile(pdfFile,i);
	  });
	  if(!iss){
	    printf("Error: Unable to create stream from "
		   "data base file: '%s'\n",pdfFile.c_str());
	    ErrorFunction(901);
	    return;
	  }
      
	  for (IE = 0; IE < NE; IE++)
	    {
	      iss.getline(line);
	      sscanf(line.c_str(), "%d %d %lf %lf %lf %lf",
		     &IELEC, &IZR, &ENR, &CSP, &TCS1P, &TCS2P);
	      if (IELEC != +1 || IZR != IZZ || fabs (ENR - ETS[IE]) > 1.0E-3)
		{
		  ErrorFunction (1356);
		  return;
		}
	      for (int IA = 0; IA < NA; IA++)
		{
		  iss >> DCSI[IA];
		}
	      //Ignore remaining line
	      iss.ignoreLine();
	      PCS[IE] = PCS[IE] + STFF * CSP;
	      PTCS1[IE] = PTCS1[IE] + STFF * TCS1P;
	      PTCS2[IE] = PTCS2[IE] + STFF * TCS2P;
	      for (int IA = 0; IA < NA; IA++)
		{
		  PDCS[IE][IA] = PDCS[IE][IA] + STFF * DCSI[IA];
		}
	    }
	}
    }

    //  *********************************************************************
    //                       FUNCTION RMOMX
    //  *********************************************************************
    double materialCreator::RMOMX (double *X, double *PDF, double XD, double XU, int NPpar, int MOM)
    {
      //  Calculation of momenta of a pdf, PDF(X), obtained from linear log-log
      //  interpolation of the input table. The independent variable X is
      //  assumed to take only positive values.

      //     X ........ array of variable values (in increasing order).
      //     PDF ...... corresponding PDF values (must be non-negative).
      //     NP ....... number of points in the table.
      //     XD, XU ... limits of the integration interval.
      //     MOM ...... moment order.
      //     RMOM = INTEGRAL (X**N)*PDF(X) dX over the interval (XD,XU).

      const double EPS = 1.0E-12;
      const double ZERO = 1.0E-35;

      double RMOMX_RETURN = 0.0;	//Valor que torna la funcio

      if (NPpar < 2)
	{
	  ErrorFunction (1908);
	  return RMOMX_RETURN;
	}
      if (X[0] < 0.0 || PDF[0] < 0.0)
	{
	  printf ("X(1),PDF(1) = %E %E\n", X[0], PDF[0]);
	  ErrorFunction (1909);
	  return RMOMX_RETURN;
	}
      for (int I = 1; I < NPpar; I++)
	{
	  if (X[I] < 0.0 || PDF[I] < 0.0)
	    {
	      printf ("I,X(I),PDF(I) = %d %E %E\n", I + 1, X[I], PDF[I]);
	      ErrorFunction (1910);
	      return RMOMX_RETURN;
	    }
	  if (X[I] < X[I - 1])
	    {
	      ErrorFunction (1911);
	      return RMOMX_RETURN;
	    }
	}

      double XLOW = (X[0] > XD ? X[0] : XD);
      if (XLOW < ZERO)
	{
	  XLOW = ZERO;
	}
      double XUP = (X[NPpar - 1] < XU ? X[NPpar - 1] : XU);

      if (XLOW > XUP)
	{
	  printf ("\n WARNING: XLOW is greater than XUP in RMOMX.");
	  printf ("\n XLOW =%E,   XUP =%E", XLOW, XUP);
	  RMOMX_RETURN = 0.0;
	  return RMOMX_RETURN;
	}

      int IL = 1;
      int IU = NPpar - 1;
      for (int I = 0; I < NPpar - 1; I++)
	{
	  if (X[I] < XLOW)
	    {
	      IL = I + 1;
	    }
	  if (X[I] < XUP)
	    {
	      IU = I + 1;
	    }
	}

      //  ****  A single interval.

      double XIL, XFL, YIL, YFL, X1, X2, DENOM, Y1, Y2, DXL, DYL, DSUM, AP1;
      if (IU == IL)
	{
	  XIL = log ((X[IL - 1] > ZERO ? X[IL - 1] : ZERO));
	  XFL = log (X[IL + 1 - 1]);
	  YIL = log ((PDF[IL - 1] > ZERO ? PDF[IL - 1] : ZERO));
	  YFL = log ((PDF[IL + 1 - 1] > ZERO ? PDF[IL + 1 - 1] : ZERO));
	  X1 = XLOW;
	  X2 = XUP;
	  DENOM = XFL - XIL;
	  if (fabs (DENOM) > ZERO)
	    {
	      Y1 =
		exp (YIL + (YFL - YIL) * (log (X1) - XIL) / DENOM) * pow (X1,
									  MOM);
	      Y2 =
		exp (YIL + (YFL - YIL) * (log (X2) - XIL) / DENOM) * pow (X2,
									  MOM);
	    }
	  else
	    {
	      Y1 = exp (YIL) * pow (X1, MOM);
	      Y2 = exp (YIL) * pow (X2, MOM);
	    }
	  DXL = log (X2) - log (X1);
	  DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
	  if (fabs (DXL) > EPS * fabs (DYL))
	    {
	      AP1 = 1.0 + (DYL / DXL);
	      if (fabs (AP1) > EPS)
		{
		  DSUM = (Y2 * X2 - Y1 * X1) / AP1;
		}
	      else
		{
		  DSUM = Y1 * X1 * DXL;
		}
	    }
	  else
	    {
	      DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
	    }
	  RMOMX_RETURN = DSUM;
	  return RMOMX_RETURN;
	}

      //  ****  Multiple intervals.

      XIL = log ((X[IL - 1] > ZERO ? X[IL - 1] : ZERO));
      XFL = log (X[IL + 1 - 1]);
      YIL = log ((PDF[IL - 1] > ZERO ? PDF[IL - 1] : ZERO));
      YFL = log ((PDF[IL + 1 - 1] > ZERO ? PDF[IL + 1 - 1] : ZERO));
      X1 = XLOW;
      DENOM = XFL - XIL;
      if (fabs (DENOM) > ZERO)
	{
	  Y1 = exp (YIL + (YFL - YIL) * (log (X1) - XIL) / DENOM) * pow (X1, MOM);
	}
      else
	{
	  Y1 = exp (YIL) * pow (X1, MOM);
	}
      X2 = X[IL + 1 - 1];
      Y2 = (PDF[IL + 1 - 1] > ZERO ? PDF[IL + 1 - 1] : ZERO) * pow (X2, MOM);
      DXL = log (X2) - log (X1);
      DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
      if (fabs (DXL) > EPS * fabs (DYL))
	{
	  AP1 = 1.0 + (DYL / DXL);
	  if (fabs (AP1) > EPS)
	    {
	      DSUM = (Y2 * X2 - Y1 * X1) / AP1;
	    }
	  else
	    {
	      DSUM = Y1 * X1 * DXL;
	    }
	}
      else
	{
	  DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
	}
      RMOMX_RETURN = DSUM;

      if (IU > IL + 1)
	{
	  for (int I = IL; I < IU - 1; I++)
	    {
	      X1 = X[I];
	      Y1 = (PDF[I] > ZERO ? PDF[I] : ZERO) * pow (X1, MOM);
	      X2 = X[I + 1];
	      Y2 = (PDF[I + 1] > ZERO ? PDF[I + 1] : ZERO) * pow (X2, MOM);
	      DXL = log (X2) - log (X1);
	      DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
	      if (fabs (DXL) > EPS * fabs (DYL))
		{
		  AP1 = 1.0 + (DYL / DXL);
		  if (fabs (AP1) > EPS)
		    {
		      DSUM = (Y2 * X2 - Y1 * X1) / AP1;
		    }
		  else
		    {
		      DSUM = Y1 * X1 * DXL;
		    }
		}
	      else
		{
		  DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
		}
	      RMOMX_RETURN = RMOMX_RETURN + DSUM;
	    }
	}

      X1 = X[IU - 1];
      Y1 = (PDF[IU - 1] > ZERO ? PDF[IU - 1] : ZERO) * pow (X1, MOM);
      XIL = log (X[IU - 1]);
      XFL = log (X[IU + 1 - 1]);
      YIL = log ((PDF[IU - 1] > ZERO ? PDF[IU - 1] : ZERO));
      YFL = log ((PDF[IU + 1 - 1] > ZERO ? PDF[IU + 1 - 1] : ZERO));
      X2 = XUP;
      DENOM = XFL - XIL;
      if (fabs (DENOM) > ZERO)
	{
	  Y2 = exp (YIL + (YFL - YIL) * (log (X2) - XIL) / DENOM) * pow (X2, MOM);
	}
      else
	{
	  Y2 = exp (YIL) * pow (X2, MOM);
	}
      DXL = log (X2) - log (X1);
      DYL = log ((Y2 > ZERO ? Y2 : ZERO)) - log ((Y1 > ZERO ? Y1 : ZERO));
      if (fabs (DXL) > EPS * fabs (DYL))
	{
	  AP1 = 1.0 + (DYL / DXL);
	  if (fabs (AP1) > EPS)
	    {
	      DSUM = (Y2 * X2 - Y1 * X1) / AP1;
	    }
	  else
	    {
	      DSUM = Y1 * X1 * DXL;
	    }
	}
      else
	{
	  DSUM = 0.5 * (Y1 + Y2) * (X2 - X1);
	}
      RMOMX_RETURN = RMOMX_RETURN + DSUM;

      return RMOMX_RETURN;
    }

    //  *********************************************************************
    //                       SUBROUTINE EINaT
    //  *********************************************************************
    void materialCreator::EINaT (double &E, double &WCCM, double &XH0, double &XH1, double &XH2,
				 double &XS0, double &XS1, double &XS2, double &XT1, double &XT2,
				 double &DELTA)
    {
      //  Integrated cross sections for inelastic collisions of electrons of
      //  energy E in material M, restricted to energy losses larger than and
      //  less than the cutoff energy WCCM.
      //
      //  Sternheimer-Liljequist GOS model.
      //
      //  Output arguments:
      //    XH0 ... total cross section for hard colls. (cm**2).
      //    XH1 ... stopping cross section for hard colls. (eV*cm**2).
      //    XH2 ... straggling cross section for hard colls. (eV**2*cm**2).
      //    XS0 ... total cross section for soft colls. (cm**2).
      //    XS1 ... stopping cross section for soft colls. (eV*cm**2)
      //    XS2 ... straggling cross section for soft colls. (eV**2*cm**2).
      //    XT1 ... 1st transport cross section for soft colls. (cm**2).
      //    XT2 ... 2nd transport cross section for soft colls. (cm**2).
      //    DELTA ... Fermi's density effect correction.

      //  ****  Constants.

      const double GAM = 1.0 + E / REV;
      const double GAM2 = GAM * GAM;

      //Get required compos variables
      double& ZT = COMPOS.ZT;

      //  ************  Density effect.

      //  ****  Sternheimer's resonance energy (WL2=L**2).
      double TST = ZT / (GAM2 * OP2);
      double WL2 = 0.0;
      double WL2U, WL2L;
      double FDEL = 0.0;
      bool Eixir = false;
      for (int I = 0; I < NOSC; I++)
	{
	  FDEL = FDEL + F[I] / (pow (WRI[I], 2) + WL2);
	}
      if (FDEL < TST)
	{
	  DELTA = 0.0;
	}
      else
	{
	  WL2 = pow (WRI[NOSC - 1], 2);
	  Eixir = false;
	  while (!Eixir)
	    {
	      Eixir = true;
	      WL2 = WL2 + WL2;
	      FDEL = 0.0;
	      for (int I = 0; I < NOSC; I++)
		{
		  FDEL = FDEL + F[I] / (pow (WRI[I], 2) + WL2);
		}
	      if (FDEL > TST)
		{
		  Eixir = false;
		  continue;
		}
	    }
	  WL2L = 0.0;
	  WL2U = WL2;
	  Eixir = false;
	  while (!Eixir)
	    {
	      Eixir = true;
	      WL2 = 0.5 * (WL2L + WL2U);
	      FDEL = 0.0;
	      for (int I = 0; I < NOSC; I++)
		{
		  FDEL = FDEL + F[I] / (pow (WRI[I], 2) + WL2);
		}
	      if (FDEL > TST)
		{
		  WL2L = WL2;
		}
	      else
		{
		  WL2U = WL2;
		}
	      if (WL2U - WL2L > 1.0E-12 * WL2)
		{
		  Eixir = false;
		  continue;
		}
	    }
	  //  ****  Density effect correction (delta).
	  DELTA = 0.0;
	  for (int I = 0; I < NOSC; I++)
	    {
	      DELTA =
		DELTA + F[I] * log (1.0 + WL2 / pow (WRI[I], 2));
	    }
	  DELTA = (DELTA / ZT) - WL2 / (GAM2 * OP2);
	}

      //  ****  Shell-oscillator cross sections.

      for (int I = 0; I < NOSC; I++)
	{
	  SEH0[I] = 0.0;
	  SEH1[I] = 0.0;
	  SEH2[I] = 0.0;
	  SES0[I] = 0.0;
	  SES1[I] = 0.0;
	  SES2[I] = 0.0;
	  SET0[I] = 0.0;
	  SET1[I] = 0.0;
	  SET2[I] = 0.0;
	}
      XH0 = 0.0;
      XH1 = 0.0;
      XH2 = 0.0;
      XS0 = 0.0;
      XS1 = 0.0;
      XS2 = 0.0;
      double XT0 = 0.0;
      XT1 = 0.0;
      XT2 = 0.0;

      double UK, WK;
      double H0, H1, H2, S0, S1, S2, R0, R1, R2;
      for (int K = 0; K < NOSC; K++)
	{
	  UK = UI[K];
	  WK = WRI[K];
	  EINaT1 (E, UK, WK, DELTA, WCCM, H0, H1, H2, S0, S1, S2, R0, R1, R2);
	  SEH0[K] = F[K] * H0;
	  SEH1[K] = F[K] * H1;
	  SEH2[K] = F[K] * H2;
	  SES0[K] = F[K] * S0;
	  SES1[K] = F[K] * S1;
	  SES2[K] = F[K] * S2;
	  SET0[K] = F[K] * R0;
	  SET1[K] = F[K] * 2.0 * R1;
	  SET2[K] = F[K] * 6.0 * (R1 - R2);
	  XH0 = XH0 + SEH0[K];
	  XH1 = XH1 + SEH1[K];
	  XH2 = XH2 + SEH2[K];
	  XS0 = XS0 + SES0[K];
	  XS1 = XS1 + SES1[K];
	  XS2 = XS2 + SES2[K];
	  XT0 = XT0 + SET0[K];
	  XT1 = XT1 + SET1[K];
	  XT2 = XT2 + SET2[K];
	}

    }

    //  *********************************************************************
    //                       SUBROUTINE EBRaT
    //  *********************************************************************
    void materialCreator::EBRaT (double &E, double &WCRM, double &XH0, double &XH1, double &XH2,
				 double &XS1, double &XS2)
    {
      //  Integrated cross sections for bremss emission by electrons of energy
      //  E in material M, restricted to energy losses larger than and less
      //  than the cutoff energy WCRM.

      //  Output arguments:
      //    XH0 ... total cross section for hard emission (cm**2).
      //    XH1 ... stopping cross section for hard emission (eV*cm**2).
      //    XH2 ... straggling cross section for hard emission (eV**2*cm**2).
      //    XS1 ... stopping cross section for soft emission (eV*cm**2).
      //    XS2 ... straggling cross section for soft emission (eV**2*cm**2).

      const double TREV = 2.0 * REV;

      //Get required CEBR01 variables
      double (&X)[NBE] = CEBR01.X;
      double (&Y)[NBE] = CEBR01.Y;
      
      XEL = log (E);
      if (XEL < DLEMP1)
	{
	  XEL = DLEMP1;
	}

      XE = 1.0 + (XEL - DLEMP1) * DLFC;
      KE = (int) XE;
      XEK = XE - (double) KE;
      //  ****  Global x-section factor.
      double FACT = ZBR2 * (pow (E + REV, 2) / (E * (E + TREV))) * 1.0E-27;

      //  ****  Moments of the scaled bremss x-section.

      double WCRE = WCRM / E;
      for (int IW = 0; IW < NBW; IW++)
	{
	  X[IW] = WB[IW];
	  Y[IW] = P0[KE - 1][IW];
	}
      double XH0A =
	RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS1A = RLMOM (X, Y, WCRE, NBW, 0);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS2A = RLMOM (X, Y, WCRE, NBW, 1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XH1A = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1A;
      if (IRETRN != 0)
	{
	  return;
	}
      double XH2A = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2A;
      if (IRETRN != 0)
	{
	  return;
	}
      for (int IW = 0; IW < NBW; IW++)
	{
	  if (KE + 1 < NEGP)
	    {
	      Y[IW] = P0[KE + 1 - 1][IW];
	    }
	  else
	    {
	      Y[IW] = P0[NEGP - 1][IW];
	    }
	}
      double XH0B =
	RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS1B = RLMOM (X, Y, WCRE, NBW, 0);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS2B = RLMOM (X, Y, WCRE, NBW, 1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XH1B = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1B;
      if (IRETRN != 0)
	{
	  return;
	}
      double XH2B = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2B;
      if (IRETRN != 0)
	{
	  return;
	}

      XH0 = ((1.0 - XEK) * XH0A + XEK * XH0B) * FACT;
      XS1 = ((1.0 - XEK) * XS1A + XEK * XS1B) * FACT * E;
      XH1 = ((1.0 - XEK) * XH1A + XEK * XH1B) * FACT * E;
      XS2 = ((1.0 - XEK) * XS2A + XEK * XS2B) * FACT * E * E;
      XH2 = ((1.0 - XEK) * XH2A + XEK * XH2B) * FACT * E * E;
    }

    //  *********************************************************************
    //                       SUBROUTINE PINaT
    //  *********************************************************************
    void materialCreator::PINaT (double &E, double &WCCM, double &XH0, double &XH1, double &XH2,
				 double &XS0, double &XS1, double &XS2, double &XT1, double &XT2,
				 double &DELTA)
    {
      //  Integrated cross sections for inelastic collisions of positrons of
      //  energy E in material M, restricted to energy losses larger than and
      //  less than the cutoff energy WCCM.
      //
      //  Sternheimer-Liljequist GOS model.
      //
      //  Output arguments:
      //    XH0 ... total cross section for hard colls. (cm**2).
      //    XH1 ... stopping cross section for hard colls. (eV*cm**2).
      //    XH2 ... straggling cross section for hard colls. (eV**2*cm**2).
      //    XS0 ... total cross section for soft colls. (cm**2).
      //    XS1 ... stopping cross section for soft colls. (eV*cm**2)
      //    XS2 ... straggling cross section for soft colls. (eV**2*cm**2).
      //    XT1 ... 1st transport cross section for soft colls. (cm**2).
      //    XT2 ... 2nd transport cross section for soft colls. (cm**2).
      //    DELTA ... Fermi's density effect correction.

      //  ****  Constants.

      const double GAM = 1.0 + E / REV;
      const double GAM2 = GAM * GAM;

      //Get required compos variables
      double& ZT = COMPOS.ZT;

      //  ************  Density effect.

      //  ****  Sternheimer's resonance energy (WL2=L**2).
      bool Eixir = false;
      double TST, WL2, FDEL, WL2L, WL2U;
      TST = ZT / (GAM2 * OP2);
      WL2 = 0.0;
      FDEL = 0.0;
      for (int I = 0; I < NOSC; I++)
	{
	  FDEL = FDEL + F[I] / (pow (WRI[I], 2) + WL2);
	}
      if (FDEL < TST)
	{
	  DELTA = 0.0;
	}
      else
	{
	  WL2 = pow (WRI[NOSC - 1], 2);
	  Eixir = false;
	  while (!Eixir)
	    {
	      Eixir = true;
	      WL2 = WL2 + WL2;
	      FDEL = 0.0;
	      for (int I = 0; I < NOSC; I++)
		{
		  FDEL = FDEL + F[I] / (pow (WRI[I], 2) + WL2);
		}
	      if (FDEL > TST)
		{
		  Eixir = false;
		  continue;
		}
	    }
	  WL2L = 0.0;
	  WL2U = WL2;
	  Eixir = false;
	  while (!Eixir)
	    {
	      Eixir = true;
	      WL2 = 0.5 * (WL2L + WL2U);
	      FDEL = 0.0;
	      for (int I = 0; I < NOSC; I++)
		{
		  FDEL = FDEL + F[I] / (pow (WRI[I], 2) + WL2);
		}
	      if (FDEL > TST)
		{
		  WL2L = WL2;
		}
	      else
		{
		  WL2U = WL2;
		}
	      if (WL2U - WL2L > 1.0E-12 * WL2)
		{
		  Eixir = false;
		  continue;
		}
	    }
	  //  ****  Density effect correction (delta).
	  DELTA = 0.0;
	  for (int I = 0; I < NOSC; I++)
	    {
	      DELTA =
		DELTA + F[I] * log (1.0 + WL2 / pow (WRI[I], 2));
	    }
	  DELTA = (DELTA / ZT) - WL2 / (GAM2 * OP2);
	}

      //  ****  Shell-oscillator cross sections.

      for (int I = 0; I < NOSC; I++)
	{
	  SPH0[I] = 0.0;
	  SPH1[I] = 0.0;
	  SPH2[I] = 0.0;
	  SPS0[I] = 0.0;
	  SPS1[I] = 0.0;
	  SPS2[I] = 0.0;
	  SPT0[I] = 0.0;
	  SPT1[I] = 0.0;
	  SPT2[I] = 0.0;
	}
      XH0 = 0.0;
      XH1 = 0.0;
      XH2 = 0.0;
      XS0 = 0.0;
      XS1 = 0.0;
      XS2 = 0.0;
      double XT0 = 0.0;
      XT1 = 0.0;
      XT2 = 0.0;

      double UK, WK, H0, H1, H2, S0, S1, S2, R0, R1, R2;
      for (int K = 0; K < NOSC; K++)
	{
	  UK = UI[K];
	  WK = WRI[K];
	  PINaT1 (E, UK, WK, DELTA, WCCM, H0, H1, H2, S0, S1, S2, R0, R1, R2);
	  SPH0[K] = F[K] * H0;
	  SPH1[K] = F[K] * H1;
	  SPH2[K] = F[K] * H2;
	  SPS0[K] = F[K] * S0;
	  SPS1[K] = F[K] * S1;
	  SPS2[K] = F[K] * S2;
	  SPT0[K] = F[K] * R0;
	  SPT1[K] = F[K] * 2.0 * R1;
	  SPT2[K] = F[K] * 6.0 * (R1 - R2);
	  XH0 = XH0 + SPH0[K];
	  XH1 = XH1 + SPH1[K];
	  XH2 = XH2 + SPH2[K];
	  XS0 = XS0 + SPS0[K];
	  XS1 = XS1 + SPS1[K];
	  XS2 = XS2 + SPS2[K];
	  XT0 = XT0 + SPT0[K];
	  XT1 = XT1 + SPT1[K];
	  XT2 = XT2 + SPT2[K];
	}

    }

    //  *********************************************************************
    //                       SUBROUTINE PBRaT
    //  *********************************************************************
    void materialCreator::PBRaT (double &E, double &WCRM, double &XH0, double &XH1, double &XH2,
				 double &XS1, double &XS2)
    {
      //  Integrated cross sections for bremss emission by positrons of energy
      //  E in material M, restricted to energy losses larger than and less
      //  than the cutoff energy WCRM.

      //  Output arguments:
      //    XH0 ... total cross section for hard emission (cm**2).
      //    XH1 ... stopping cross section for hard emission (eV*cm**2).
      //    XH2 ... straggling cross section for hard emission (eV**2*cm**2).
      //    XS1 ... stopping cross section for soft emission (eV*cm**2).
      //    XS2 ... straggling cross section for soft emission (eV**2*cm**2).

      const double TREV = 2.0 * REV;

      //Get required CEBR01 variables
      double (&X)[NBE] = CEBR01.X;
      double (&Y)[NBE] = CEBR01.Y;      

      XEL = log (E);
      if (XEL < DLEMP1)
	{
	  XEL = DLEMP1;
	}

      XE = 1.0 + (XEL - DLEMP1) * DLFC;
      KE = (int) XE;
      XEK = XE - (double) KE;
      //  ****  Global x-section factor.
      double FACT = ZBR2 * (pow (E + REV, 2) / (E * (E + TREV))) * 1.0E-27;
      //  ****  Positron correction factor.
      double T = log (1.0 + 1.0E6 * E / (REV * ZBR2));
      double FPOS =
	1.0 -
	exp (-T *
	     (1.2359E-1 -
	      T * (6.1274E-2 -
		   T * (3.1516E-2 -
			T * (7.7446E-3 -
			     T * (1.0595E-3 -
				  T * (7.0568E-5 - T * 1.8080E-6)))))));
      FACT = FACT * FPOS;

      //  ****  Moments of the scaled bremss x-section.

      double WCRE = WCRM / E;
      for (int IW = 0; IW < NBW; IW++)
	{
	  X[IW] = WB[IW];
	  Y[IW] = P0[KE - 1][IW];
	}
      double XH0A =
	RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS1A = RLMOM (X, Y, WCRE, NBW, 0);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS2A = RLMOM (X, Y, WCRE, NBW, 1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XH1A = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1A;
      if (IRETRN != 0)
	{
	  return;
	}
      double XH2A = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2A;
      if (IRETRN != 0)
	{
	  return;
	}
      for (int IW = 0; IW < NBW; IW++)
	{
	  if (KE + 1 < NEGP)
	    {
	      Y[IW] = P0[KE + 1 - 1][IW];
	    }
	  else
	    {
	      Y[IW] = P0[NEGP - 1][IW];
	    }
	}
      double XH0B =
	RLMOM (X, Y, X[NBW - 1], NBW, -1) - RLMOM (X, Y, WCRE, NBW, -1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS1B = RLMOM (X, Y, WCRE, NBW, 0);
      if (IRETRN != 0)
	{
	  return;
	}
      double XS2B = RLMOM (X, Y, WCRE, NBW, 1);
      if (IRETRN != 0)
	{
	  return;
	}
      double XH1B = RLMOM (X, Y, X[NBW - 1], NBW, 0) - XS1B;
      if (IRETRN != 0)
	{
	  return;
	}
      double XH2B = RLMOM (X, Y, X[NBW - 1], NBW, 1) - XS2B;
      if (IRETRN != 0)
	{
	  return;
	}

      XH0 = ((1.0 - XEK) * XH0A + XEK * XH0B) * FACT;
      XS1 = ((1.0 - XEK) * XS1A + XEK * XS1B) * FACT * E;
      XH1 = ((1.0 - XEK) * XH1A + XEK * XH1B) * FACT * E;
      XS2 = ((1.0 - XEK) * XS2A + XEK * XS2B) * FACT * E * E;
      XH2 = ((1.0 - XEK) * XH2A + XEK * XH2B) * FACT * E * E;
    }
    //  *********************************************************************
    //                       SUBROUTINE MERGE2
    //  *********************************************************************
    void materialCreator::MERGE2 (double *X1, double *Y1, double *X2, double *Y2, double *XM,
				  double *YM, int &N1, int &N2, int &N)
    {
      //  This subroutine merges two tables (X1,Y1), (X2,Y2) of two functions
      //  to produce a table (XM,YM) of the sum of these functions, with abs-
      //  cissas in increasing order. The abscissas and function values are
      //  assumed to be positive. N1, N2 and N are the numbers of grid points
      //  in the input and merged tables. A discontinuity in the function is
      //  described by giving twice the abscissa. Log-log linear interpolation
      //  is used to interpolate the input tables.

      const double EPS = 1.0E-10;
      const int NP_S = 12000;
      const int NP2_S = NP_S + NP_S;
      std::vector<double> X(NP2_S);
      std::vector<double> Y12(NP2_S);

      if (N1 > NP_S || N2 > NP_S)
	{
	  printf ("NP =%7d\n", N1 > N2 ? N1 : N2);
	  ErrorFunction (1901);
	  return;
	}

      SORT2 (X1, Y1, N1);
      if (IRETRN != 0)
	{
	  return;
	}
      SORT2 (X2, Y2, N2);
      if (IRETRN != 0)
	{
	  return;
	}

      for (int I1 = 0; I1 < N1; I1++)
	{
	  X[I1] = X1[I1];
	}
      double XC, TST1, TST2, TST3, TST4, TST12, TST34, TST;
      N = N1;
      for (int I2 = 0; I2 < N2; I2++)
	{
	  int I1;
	  XC = X2[I2];
	  FINDI (X1, XC, N1, I1);
	  if (I1 == N1)
	    {
	      I1 = N1 - 1;
	    }
	  TST1 = fabs (XC - X1[I1 - 1]);
	  TST2 = fabs (XC - X1[I1 + 1 - 1]);
	  TST12 = (TST1 < TST2 ? TST1 : TST2);
	  if (I2 + 1 > 1)
	    {
	      TST3 = fabs (XC - X2[I2 - 1]);
	    }
	  else
	    {
	      TST3 = 1.0;
	    }
	  if (I2 + 1 < N2)
	    {
	      TST4 = fabs (XC - X2[I2 + 1]);
	    }
	  else
	    {
	      TST4 = 1.0;
	    }
	  TST34 = (TST3 < TST4 ? TST3 : TST4);
	  TST = EPS * XC;
	  if (TST34 > TST)
	    {
	      if (TST12 > TST)
		{
		  N = N + 1;
		  X[N - 1] = XC;
		}
	    }
	  else
	    {
	      N = N + 1;
	      X[N - 1] = XC;
	    }
	}

      //  ****  Sort and clean the merged grid.

      bool Eixir = false;
      while (!Eixir)
	{
	  Eixir = true;
	  for (int I = 0; I < N - 1; I++)
	    {
	      int IMIN = I + 1;
	      double XMIN = X[I];
	      for (int J = I + 1; J < N; J++)
		{
		  if (X[J] < XMIN)
		    {
		      IMIN = J + 1;
		      XMIN = X[J];
		    }
		}
	      double SAVE = X[I];
	      X[I] = X[IMIN - 1];
	      X[IMIN - 1] = SAVE;
	    }

	  for (int I = 0; I < N - 2; I++)
	    {
	      if (X[I] > X[I + 2] * (1.0E0 - EPS))
		{
		  X[I + 1] = X[N - 1];
		  N = N - 1;
		  Eixir = false;
		  break;
		}
	    }
	}

      for (int I = 0; I < N; I++)
	{
	  XC = X[I];
	  if (I + 1 < N)
	    {
	      if (X[I] > X[I + 1] * (1.0 - EPS))
		{
		  XC = X[I] * (1.0 - EPS);
		}
	    }
	  if (I + 1 > 1)
	    {
	      if (X[I] < X[I - 1] * (1.0 + EPS))
		{
		  XC = X[I] * (1.0 + EPS);
		}
	    }
	  int J;
	  double YI1, YI2;
	  FINDI (X1, XC, N1, J);
	  if (J == N1)
	    {
	      J = N1 - 1;
	    }
	  if (X1[J + 1 - 1] > X1[J - 1] + EPS)
	    {
	      YI1 =
		exp (log (Y1[J - 1]) +
		     log (XC / X1[J - 1]) * log (Y1[J + 1 - 1] / Y1[J - 1]) /
		     log (X1[J + 1 - 1] / X1[J - 1]));
	    }
	  else
	    {
	      YI1 = Y1[J - 1];
	    }
	  FINDI (X2, XC, N2, J);
	  if (J == N2)
	    {
	      J = N2 - 1;
	    }
	  if (X2[J + 1 - 1] > X2[J - 1] + EPS)
	    {
	      YI2 =
		exp (log (Y2[J - 1]) +
		     log (XC / X2[J - 1]) * log (Y2[J + 1 - 1] / Y2[J - 1]) /
		     log (X2[J + 1 - 1] / X2[J - 1]));
	    }
	  else
	    {
	      YI2 = Y2[J - 1];
	    }
	  Y12[I] = YI1 + YI2;
	  if (Y12[I] < 1.0E-75)
	    {
	      Y12[I] = 1.0E-75;
	    }
	}

      if (N > NP_S)
	{
	  printf ("NP = %7d\n", N);
	  ErrorFunction (1902);
	  return;
	}
      for (int I = 0; I < N; I++)
	{
	  XM[I] = X[I];
	  YM[I] = Y12[I];
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE GCOaT
    //  *********************************************************************
    void materialCreator::GCOaT (double &E, double &CS)
    {
      //  Total cross section for incoherent (Compton) scattering. Relativistic
      //  Impulse approximation with analytical Compton profiles.

      //  Input arguments:
      //    E ........ photon energy (eV).
      //    M ........ material where photons propagate.
      //  Output argument:
      //    CS ....... incoherent total cross section (cm**2/molecule).

      const double RREV = 1.0 / REV;
      const double PIELR2 = PI * ELRAD * ELRAD;

      //Get CGCO00 variables
      double& EE = CGCO00.EE;
      int& IOSC = CGCO00.IOSC;
      
      std::vector<double> SXCO(NOCO);

      EE = E;
      double EK, EKS, EK2, EK1, T0, CSL, TAU, CSKN, CSU;
      CS = 0.0;
      if (E < 5.0E6)
	{
	  for (int IO = 0; IO < NOSCCO; IO++)
	    {
	      IOSC = IO + 1;
	      SXCO[IO] = FCO[IO] * PIELR2 * SUMGA (&materialCreator::GCOaD, -1.0, 1.0, 1.0E-6);
	      CS = CS + SXCO[IO];
	    }
	}
      else
	{
	  //  ****  Klein-Nishina total cross section.
	  EK = E * RREV;
	  EKS = EK * EK;
	  EK2 = 1.0 + EK + EK;
	  EK1 = EKS - EK2 - 1.0;
	  T0 = 1.0 / (1.0 + EK + EK);
	  CSL = 0.5 * EKS * T0 * T0 + EK2 * T0 + EK1 * log (T0) - 1.0 / T0;
	  for (int IO = 0; IO < NOSCCO; IO++)
	    {
	      TAU = (E - UICO[IO]) / E;
	      if (TAU < T0)
		{
		  CSKN = 0.0;
		}
	      else
		{
		  CSU =
		    0.5 * EKS * TAU * TAU + EK2 * TAU + EK1 * log (TAU) -
		    1.0 / TAU;
		  CSKN = PIELR2 * (CSU - CSL) / (EK * EKS);
		}
	      SXCO[IO] = FCO[IO] * CSKN;
	      CS = CS + SXCO[IO];
	    }
	}
    }

    //  *********************************************************************
    //                       SUBROUTINE EINaT1
    //  *********************************************************************
    void materialCreator::EINaT1 (double &E, double &UK, double &WK, double DELTA, double &WCCM,
				  double &H0, double &H1, double &H2, double &S0, double &S1,
				  double &S2, double &R0, double &R1, double &R2)
    {
      //  Integrated cross sections for inelastic collisions of electrons with
      //  a single-shell oscillator, restricted to energy losses larger than,
      //  and smaller than, the cutoff energy loss WCCM.
      //
      //  Sternheimer-Liljequist oscillator model.
      //
      //  Input arguments:
      //    E ..... kinetic energy (eV).
      //    UK .... ionisation energy (eV).
      //    WK .... resonance energy (eV).
      //    DELTA ... Fermi's density effect correction.
      //    WCCM ... cutoff energy loss (eV).
      //
      //  Output arguments:
      //    H0 .... total cross section for hard colls. (cm**2).
      //    H1 .... stopping cross section for hard colls. (eV*cm**2).
      //    H2 .... straggling cross section for hard colls. (eV**2*cm**2).
      //    S0 .... total cross section for soft colls. (cm**2).
      //    S1 .... stopping cross section for soft colls. (eV*cm**2).
      //    S2 .... straggling cross section for soft colls. (eV**2*cm**2).
      //    R0 .... total cross section for soft colls. (cm**2).
      //    R1 .... 1st transport cross section for soft colls. (cm**2).
      //    R2 .... 2nd transport cross section for soft colls. (cm**2).

      //using namespace CEIN01;
      double& EI = CEIN01.EI;
      double& EE = CEIN01.EE;
      double& CPS = CEIN01.CPS;
      double& AMOL = CEIN01.AMOL;
      double& MOM = CEIN01.MOM;
    
      const double TREV = 2.0 * REV;
      const double RTREV = 1.0 / TREV;
      const double PIELR2 = PI * ELRAD * ELRAD;

      H0 = 0.0;
      H1 = 0.0;
      H2 = 0.0;
      S0 = 0.0;
      S1 = 0.0;
      S2 = 0.0;
      R0 = 0.0;
      R1 = 0.0;
      R2 = 0.0;

      double WTHR;
      if (UK > 1.0E-3)
	{
	  WTHR = UK;
	}
      else
	{
	  WTHR = WK;
	}
      if (E < WTHR + 1.0E-6)
	{
	  return;
	}

      //  ****  Constants.

      EI = E;
      const double GAM = 1.0 + E / REV;
      const double GAM2 = GAM * GAM;
      const double BETA2 = (GAM2 - 1.0) / GAM2;
      const double CONST = PIELR2 * TREV / BETA2;

      CPS = E * (E + TREV);
      double CP = sqrt (CPS);
      AMOL = pow (E / (E + REV), 2);

      //  ****  Trick: The resonance energy and the cutoff recoil energy of
      //        inner shells are varied to yield a smooth threshold.

      double WM, WKP, QKP, WCMAX, WDMAX;
      if (UK > 1.0E-3)
	{
	  WM = 3.0 * WK - 2.0 * UK;
	  if (E > WM)
	    {
	      WKP = WK;
	      QKP = UK;
	    }
	  else
	    {
	      WKP = (E + 2.0 * UK) / 3.0;
	      QKP = UK * (E / WM);
	      WM = E;
	    }
	  EE = E + UK;
	  WCMAX = 0.5 * EE;
	  if (WCMAX < WM)
	    {
	      WDMAX = WCMAX;
	    }
	  else
	    {
	      WDMAX = WM;
	    }
	}

      else
	{
	  WM = E;
	  WKP = WK;
	  QKP = WK;
	  EE = E;
	  WCMAX = 0.5 * EE;
	  WDMAX = WKP + 1.0;
	}

      //  ****  Distant interactions.

      double SDL1 = 0.0;
      double SDT1 = 0.0;
      double CPPS, CPP;
      double A, B, BA;
      double QM;
      double RMU1;
      if (WDMAX > WTHR + 1.0E-6)
	{
	  CPPS = (E - WKP) * (E - WKP + TREV);
	  CPP = sqrt (CPPS);
	  A = 4.0 * CP * CPP;
	  B = pow (CP - CPP, 2);

	  if (WKP > 1.0E-6 * E)
	    {
	      QM = sqrt (pow (CP - CPP, 2) + pow (REV, 2)) - REV;
	    }
	  else
	    {
	      QM = WKP * WKP / (BETA2 * TREV);
	      QM = QM * (1.0 - QM * RTREV);
	    }
	  if (QM < QKP)
	    {
	      SDL1 = log (QKP * (QM + TREV) / (QM * (QKP + TREV)));
	      SDT1 = log (GAM2) - BETA2 - DELTA;
	      if (SDT1 < 0.0)
		{
		  SDT1 = 0.0;
		}

	      //  ****  Soft distant transport moments of orders 0-2.
	      if (WCCM > WTHR)
		{
		  BA = B / A;
		  RMU1 = (QKP * (QKP + TREV) - B) / A;
		  R0 = log ((RMU1 + BA) / BA);
		  R1 = RMU1 - BA * R0;
		  R2 = pow (BA, 2) * R0 + 0.5 * RMU1 * (RMU1 - 2.0 * BA);
		  R0 = R0 / WKP;
		  R1 = R1 / WKP;
		  R2 = R2 / WKP;
		  R0 = R0 + SDT1 / WKP;
		}
	    }
	}

      double F0, F1, WL, WU;
      double SD1 = SDL1 + SDT1;
      if (SD1 > 0.0)
	{
	  if (UK > 1.0E-3)
	    {
	      //  ****  Inner-shell excitations (triangle distribution).
	      F0 = 1.0 / pow (WM - UK, 2);
	      F1 = 2.0 * F0 * SD1 / WKP;
	      if (WCCM < UK)
		{
		  WL = UK;
		  WU = WDMAX;
		  H0 = F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  H1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  H2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		}
	      else
		{
		  if (WCCM > WDMAX)
		    {
		      WL = UK;
		      WU = WDMAX;
		      S0 =
			F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		      S1 =
			F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			      (pow (WU, 3) - pow (WL, 3)) / 3.0);
		      S2 =
			F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			      (pow (WU, 4) - pow (WL, 4)) / 4.0);
		    }
		  else
		    {
		      WL = WCCM;
		      WU = WDMAX;
		      H0 =
			F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		      H1 =
			F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			      (pow (WU, 3) - pow (WL, 3)) / 3.0);
		      H2 =
			F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			      (pow (WU, 4) - pow (WL, 4)) / 4.0);
		      WL = UK;
		      WU = WCCM;
		      S0 =
			F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		      S1 =
			F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			      (pow (WU, 3) - pow (WL, 3)) / 3.0);
		      S2 =
			F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			      (pow (WU, 4) - pow (WL, 4)) / 4.0);
		    }
		  double F2 =
		    F0 * (2.0 * WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)));
		  R0 = F2 * R0;
		  R1 = F2 * R1;
		  R2 = F2 * R2;
		}
	    }
	  else
	    {
	      //  ****  Outer-shell excitations (delta oscillator).
	      if (WCCM < WKP)
		{
		  H1 = SD1;
		  H0 = SD1 / WKP;
		  H2 = SD1 * WKP;
		}
	      else
		{
		  S1 = SD1;
		  S0 = SD1 / WKP;
		  S2 = SD1 * WKP;
		}
	    }
	}

      //  ****  Close collisions (Moller's cross section).

      if (WCMAX < WTHR + 1.0E-6)
	{
	}
      else
	{
	  if (WCCM < WTHR)		// No soft interactions.
	    {
	      WL = WTHR;
	      WU = WCMAX;
	      H0 =
		H0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
		(1.0 / WL) + (1.0 -
			      AMOL) * log (((EE - WU) * WL) / ((EE - WL) * WU)) /
		EE + AMOL * (WU - WL) / pow (EE, 2);

	      H1 =
		H1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) + (2.0 -
									    AMOL)
		* log ((EE - WU) / (EE - WL)) + AMOL * (pow (WU, 2) -
							pow (WL,
							     2)) / (2.0 * pow (EE,
									       2));

	      H2 =
		H2 + (2.0 - AMOL) * (WU - WL) +
		(WU * (2.0 * EE - WU) / (EE - WU)) -
		(WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
						      AMOL) * EE * log ((EE -
									 WU) /
									(EE -
									 WL)) +
		AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
	    }
	  else
	    {
	      if (WCCM > WCMAX)
		{
		  WL = WTHR;
		  WU = WCMAX;
		  S0 =
		    S0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
		    (1.0 / WL) + (1.0 -
				  AMOL) * log (((EE - WU) * WL) / ((EE - WL) *
								   WU)) / EE +
		    AMOL * (WU - WL) / pow (EE, 2);

		  S1 =
		    S1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) +
		    (2.0 - AMOL) * log ((EE - WU) / (EE - WL)) +
		    AMOL * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (EE, 2));

		  S2 =
		    S2 + (2.0 - AMOL) * (WU - WL) +
		    (WU * (2.0 * EE - WU) / (EE - WU)) -
		    (WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
							  AMOL) * EE * log ((EE -
									     WU) /
									    (EE -
									     WL))
		    + AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
		}
	      else
		{
		  WL = WCCM;
		  WU = WCMAX;
		  H0 =
		    H0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
		    (1.0 / WL) + (1.0 -
				  AMOL) * log (((EE - WU) * WL) / ((EE - WL) *
								   WU)) / EE +
		    AMOL * (WU - WL) / pow (EE, 2);

		  H1 =
		    H1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) +
		    (2.0 - AMOL) * log ((EE - WU) / (EE - WL)) +
		    AMOL * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (EE, 2));

		  H2 =
		    H2 + (2.0 - AMOL) * (WU - WL) +
		    (WU * (2.0 * EE - WU) / (EE - WU)) -
		    (WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
							  AMOL) * EE * log ((EE -
									     WU) /
									    (EE -
									     WL))
		    + AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
		  WL = WTHR;
		  WU = WCCM;
		  S0 =
		    S0 + (1.0 / (EE - WU)) - (1.0 / (EE - WL)) - (1.0 / WU) +
		    (1.0 / WL) + (1.0 -
				  AMOL) * log (((EE - WU) * WL) / ((EE - WL) *
								   WU)) / EE +
		    AMOL * (WU - WL) / pow (EE, 2);

		  S1 =
		    S1 + log (WU / WL) + (EE / (EE - WU)) - (EE / (EE - WL)) +
		    (2.0 - AMOL) * log ((EE - WU) / (EE - WL)) +
		    AMOL * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (EE, 2));

		  S2 =
		    S2 + (2.0 - AMOL) * (WU - WL) +
		    (WU * (2.0 * EE - WU) / (EE - WU)) -
		    (WL * (2.0 * EE - WL) / (EE - WL)) + (3.0 -
							  AMOL) * EE * log ((EE -
									     WU) /
									    (EE -
									     WL))
		    + AMOL * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (EE, 2));
		}
	      //  ****  Soft close transport moments of orders 0-2.
	      double CP2S = (E - WL) * (E - WL + TREV);
	      double CP2 = sqrt (CP2S);
	      double RMU2 =
		(WL * (WL + TREV) - pow (CP - CP2, 2)) / (4.0 * CP * CP2);
	      double CP3S = (E - WU) * (E - WU + TREV);
	      double CP3 = sqrt (CP3S);
	      double RMU3 =
		(WU * (WU + TREV) - pow (CP - CP3, 2)) / (4.0 * CP * CP3);
	      MOM = 0;
	      R0 = R0 + SUMGA (&materialCreator::EINaDS, RMU2, RMU3, 1.0E-7);
	      MOM = 1;
	      R1 = R1 + SUMGA (&materialCreator::EINaDS, RMU2, RMU3, 1.0E-7);
	      MOM = 2;
	      R2 = R2 + SUMGA (&materialCreator::EINaDS, RMU2, RMU3, 1.0E-7);
	    }
	}

      H0 = CONST * H0;
      H1 = CONST * H1;
      H2 = CONST * H2;
      S0 = CONST * S0;
      S1 = CONST * S1;
      S2 = CONST * S2;
      R0 = CONST * R0;
      R1 = CONST * R1;
      R2 = CONST * R2;
    }

    //  *********************************************************************
    //                       SUBROUTINE PINaT1
    //  *********************************************************************
    void materialCreator::PINaT1 (double &E, double &UK, double &WK, double DELTA, double &WCCM,
				  double &H0, double &H1, double &H2, double &S0, double &S1,
				  double &S2, double &R0, double &R1, double &R2)
    {
      //  Integrated cross sections for inelastic collisions of positrons with
      //  a single-shell oscillator, restricted to energy losses larger than,
      //  and smaller than, the cutoff energy loss WCCM.
      //
      //  Sternheimer-Liljequist oscillator model.
      //
      //  Input arguments:
      //    E ..... kinetic energy (eV).
      //    UK .... ionisation energy (eV).
      //    WK .... resonance energy (eV).
      //    DELTA ... Fermi's density effect correction.
      //    WCCM ... cutoff energy loss (eV).
      //
      //  Output arguments:
      //    H0 .... total cross section for hard colls. (cm**2).
      //    H1 .... stopping cross section for hard colls. (eV*cm**2).
      //    H2 .... straggling cross section for hard colls. (eV**2*cm**2).
      //    S0 .... total cross section for soft colls. (cm**2).
      //    S1 .... stopping cross section for soft colls. (eV*cm**2).
      //    S2 .... straggling cross section for soft colls. (eV**2*cm**2).
      //    R0 .... total cross section for soft colls. (cm**2).
      //    R1 .... 1st transport cross section for soft colls. (cm**2).
      //    R2 .... 2nd transport cross section for soft colls. (cm**2).
      //

      //using namespace CPIN01;      
      double& EI = CPIN01.EI;
      double& CPS = CPIN01.CPS;
      double& BHA1 = CPIN01.BHA1;
      double& BHA2 = CPIN01.BHA2;
      double& BHA3 = CPIN01.BHA3;
      double& BHA4 = CPIN01.BHA4;
      int& MOM = CPIN01.MOM;
  
      const double TREV = 2.0 * REV;
      const double RTREV = 1.0 / TREV;
      const double PIELR2 = PI * ELRAD * ELRAD;


      H0 = 0.0;
      H1 = 0.0;
      H2 = 0.0;
      S0 = 0.0;
      S1 = 0.0;
      S2 = 0.0;
      R0 = 0.0;
      R1 = 0.0;
      R2 = 0.0;

      double WTHR;
      if (UK > 1.0E-3)
	{
	  WTHR = UK;
	}
      else
	{
	  WTHR = WK;
	}
      if (E < WTHR + 1.0E-6)
	{
	  return;
	}

      //  ****  Constants.

      EI = E;
      const double GAM = 1.0 + E / REV;
      const double GAM2 = GAM * GAM;
      const double BETA2 = (GAM2 - 1.0) / GAM2;
      const double CONST = PIELR2 * TREV / BETA2;

      CPS = E * (E + TREV);
      double CP = sqrt (CPS);
      double AMOL = pow (E / (E + REV), 2);
      double G12 = pow (GAM + 1.0, 2);
      BHA1 = AMOL * (2.0 * G12 - 1.0) / (GAM2 - 1.0);
      BHA2 = AMOL * (3.0 + 1.0 / G12);
      BHA3 = AMOL * 2.0 * GAM * (GAM - 1.0) / G12;
      BHA4 = AMOL * pow (GAM - 1.0, 2) / G12;

      //  ****  Trick: The resonance energy and the cutoff recoil energy of
      //        inner shells are varied to yield a smooth threshold. 

      double WM, WKP, QKP, WCMAX, WDMAX;
      if (UK > 1.0E-3)
	{
	  WM = 3.0 * WK - 2.0 * UK;
	  if (E > WM)
	    {
	      WKP = WK;
	      QKP = UK;
	    }
	  else
	    {
	      WKP = (E + 2.0 * UK) / 3.0;
	      QKP = UK * (E / WM);
	      WM = E;
	    }
	  WCMAX = E;
	  if (WM < WCMAX)
	    {
	      WDMAX = WM;
	    }
	  else
	    {
	      WDMAX = WCMAX;
	    }
	}
      else
	{
	  WM = E;
	  WKP = WK;
	  QKP = WK;
	  WCMAX = E;
	  WDMAX = WKP + 1.0;
	}

      //  ****  Distant interactions.


      double SDL1 = 0.0;
      double SDT1 = 0.0;
      double CPPS, CPP, A, B, QM, BA, RMU1;
      if (WDMAX > WTHR + 1.0E-6)
	{
	  CPPS = (E - WKP) * (E - WKP + TREV);
	  CPP = sqrt (CPPS);
	  A = 4.0 * CP * CPP;
	  B = pow (CP - CPP, 2);

	  if (WKP > 1.0E-6 * E)
	    {
	      QM = sqrt (pow (CP - CPP, 2) + pow (REV, 2)) - REV;
	    }
	  else
	    {
	      QM = WKP * WKP / (BETA2 * TREV);
	      QM = QM * (1.0 - QM * RTREV);
	    }
	  if (QM < QKP)
	    {
	      SDL1 = log (QKP * (QM + TREV) / (QM * (QKP + TREV)));

	      SDT1 = log (GAM2) - BETA2 - DELTA;
	      if (SDT1 < 0.0)
		{
		  SDT1 = 0.0;
		}

	      //  ****  Soft distant transport moments of orders 0-2.
	      if (WCCM > WTHR)
		{
		  BA = B / A;
		  RMU1 = (QKP * (QKP + TREV) - B) / A;
		  R0 = log ((RMU1 + BA) / BA);
		  R1 = RMU1 - BA * R0;
		  R2 = pow (BA, 2) * R0 + 0.5 * RMU1 * (RMU1 - 2.0 * BA);
		  R0 = R0 / WKP;
		  R1 = R1 / WKP;
		  R2 = R2 / WKP;
		  R0 = R0 + SDT1 / WKP;
		}
	    }
	}

      double SD1 = SDL1 + SDT1;
      double F0, F1, WL, WU;
      if (SD1 > 0.0)
	{
	  if (UK > 1.0E-3)
	    {
	      //  ****  Inner-shell excitations (triangle distribution).
	      F0 = 1.0 / pow (WM - UK, 2);
	      F1 = 2.0 * F0 * SD1 / WKP;
	      if (WCCM < UK)
		{
		  WL = UK;
		  WU = WDMAX;
		  H0 = F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		  H1 =
		    F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			  (pow (WU, 3) - pow (WL, 3)) / 3.0);
		  H2 =
		    F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			  (pow (WU, 4) - pow (WL, 4)) / 4.0);
		}
	      else
		{
		  if (WCCM > WDMAX)
		    {
		      WL = UK;
		      WU = WDMAX;
		      S0 =
			F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		      S1 =
			F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			      (pow (WU, 3) - pow (WL, 3)) / 3.0);
		      S2 =
			F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			      (pow (WU, 4) - pow (WL, 4)) / 4.0);
		    }
		  else
		    {
		      WL = WCCM;
		      WU = WDMAX;
		      H0 =
			F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		      H1 =
			F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			      (pow (WU, 3) - pow (WL, 3)) / 3.0);
		      H2 =
			F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			      (pow (WU, 4) - pow (WL, 4)) / 4.0);
		      WL = UK;
		      WU = WCCM;
		      S0 =
			F1 * (WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)) / 2.0);
		      S1 =
			F1 * (WM * (pow (WU, 2) - pow (WL, 2)) / 2.0 -
			      (pow (WU, 3) - pow (WL, 3)) / 3.0);
		      S2 =
			F1 * (WM * (pow (WU, 3) - pow (WL, 3)) / 3.0 -
			      (pow (WU, 4) - pow (WL, 4)) / 4.0);
		    }
		  double F2 =
		    F0 * (2.0 * WM * (WU - WL) - (pow (WU, 2) - pow (WL, 2)));
		  R0 = F2 * R0;
		  R1 = F2 * R1;
		  R2 = F2 * R2;
		}
	    }
	  else
	    {
	      //  ****  Outer-shell excitations (delta oscillator).
	      if (WCCM < WKP)
		{
		  H1 = SD1;
		  H0 = SD1 / WKP;
		  H2 = SD1 * WKP;
		}
	      else
		{
		  S1 = SD1;
		  S0 = SD1 / WKP;
		  S2 = SD1 * WKP;
		}
	    }
	}

      //  ****  Close collisions (Bhabha's cross section).

      if (WCMAX < WTHR + 1.0E-6)
	{
	}
      else
	{
	  if (WCCM < WTHR)		// No soft interactions.
	    {
	      WL = WTHR;
	      WU = WCMAX;
	      H0 =
		H0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
		BHA2 * (WU - WL) / pow (E,
					2) - BHA3 * (pow (WU, 2) - pow (WL,
									2)) /
		(2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
					     pow (WL, 3)) / (3.0 * pow (E, 4));

	      H1 =
		H1 + log (WU / WL) - BHA1 * (WU - WL) / E + BHA2 * (pow (WU, 2) -
								    pow (WL,
									 2)) /
		(2.0 * pow (E, 2)) - BHA3 * (pow (WU, 3) -
					     pow (WL, 3)) / (3.0 * pow (E,
									3)) +
		BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

	      H2 =
		H2 + WU - WL - BHA1 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * E) +
		BHA2 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 2)) -
		BHA3 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 3)) +
		BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
	    }
	  else
	    {
	      if (WCCM > WCMAX)
		{
		  WL = WTHR;
		  WU = WCMAX;
		  S0 =
		    S0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
		    BHA2 * (WU - WL) / pow (E,
					    2) - BHA3 * (pow (WU, 2) - pow (WL,
									    2)) /
		    (2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
						 pow (WL, 3)) / (3.0 * pow (E,
									    4));

		  S1 =
		    S1 + log (WU / WL) - BHA1 * (WU - WL) / E +
		    BHA2 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (E, 2)) -
		    BHA3 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 3)) +
		    BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

		  S2 =
		    S2 + WU - WL - BHA1 * (pow (WU, 2) -
					   pow (WL,
						2)) / (2.0 * E) + BHA2 * (pow (WU,
									       3)
									  -
									  pow (WL,
									       3))
		    / (3.0 * pow (E, 2)) - BHA3 * (pow (WU, 4) -
						   pow (WL, 4)) / (4.0 * pow (E,
									      3))
		    + BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
		}
	      else
		{
		  WL = WCCM;
		  WU = WCMAX;
		  H0 =
		    H0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
		    BHA2 * (WU - WL) / pow (E,
					    2) - BHA3 * (pow (WU, 2) - pow (WL,
									    2)) /
		    (2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
						 pow (WL, 3)) / (3.0 * pow (E,
									    4));

		  H1 =
		    H1 + log (WU / WL) - BHA1 * (WU - WL) / E +
		    BHA2 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (E, 2)) -
		    BHA3 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 3)) +
		    BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

		  H2 =
		    H2 + WU - WL - BHA1 * (pow (WU, 2) -
					   pow (WL,
						2)) / (2.0 * E) + BHA2 * (pow (WU,
									       3)
									  -
									  pow (WL,
									       3))
		    / (3.0 * pow (E, 2)) - BHA3 * (pow (WU, 4) -
						   pow (WL, 4)) / (4.0 * pow (E,
									      3))
		    + BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
		  WL = WTHR;
		  WU = WCCM;
		  S0 =
		    S0 + (1.0 / WL) - (1.0 / WU) - BHA1 * log (WU / WL) / E +
		    BHA2 * (WU - WL) / pow (E,
					    2) - BHA3 * (pow (WU, 2) - pow (WL,
									    2)) /
		    (2.0 * pow (E, 3)) + BHA4 * (pow (WU, 3) -
						 pow (WL, 3)) / (3.0 * pow (E,
									    4));

		  S1 =
		    S1 + log (WU / WL) - BHA1 * (WU - WL) / E +
		    BHA2 * (pow (WU, 2) - pow (WL, 2)) / (2.0 * pow (E, 2)) -
		    BHA3 * (pow (WU, 3) - pow (WL, 3)) / (3.0 * pow (E, 3)) +
		    BHA4 * (pow (WU, 4) - pow (WL, 4)) / (4.0 * pow (E, 4));

		  S2 =
		    S2 + WU - WL - BHA1 * (pow (WU, 2) -
					   pow (WL,
						2)) / (2.0 * E) + BHA2 * (pow (WU,
									       3)
									  -
									  pow (WL,
									       3))
		    / (3.0 * pow (E, 2)) - BHA3 * (pow (WU, 4) -
						   pow (WL, 4)) / (4.0 * pow (E,
									      3))
		    + BHA4 * (pow (WU, 5) - pow (WL, 5)) / (5.0 * pow (E, 4));
		}
	      //  ****  Soft close transport moments of orders 0-2.
	      double CP2S = (E - WL) * (E - WL + TREV);
	      double CP2 = sqrt (CP2S);
	      double RMU2 =
		(WL * (WL + TREV) - pow (CP - CP2, 2)) / (4.0 * CP * CP2);
	      double CP3S, CP3, RMU3;
	      if (WU < E - 1.0)
		{
		  CP3S = (E - WU) * (E - WU + TREV);
		  CP3 = sqrt (CP3S);
		  RMU3 =
		    (WU * (WU + TREV) - pow (CP - CP3, 2)) / (4.0 * CP * CP3);
		}
	      else
		{
		  RMU3 = 0.5;
		}
	      MOM = 0;
	      R0 = R0 + SUMGA (&materialCreator::PINaDS, RMU2, RMU3, 1.0E-7);
	      MOM = 1;
	      R1 = R1 + SUMGA (&materialCreator::PINaDS, RMU2, RMU3, 1.0E-7);
	      MOM = 2;
	      R2 = R2 + SUMGA (&materialCreator::PINaDS, RMU2, RMU3, 1.0E-7);
	    }
	}

      H0 = CONST * H0;
      H1 = CONST * H1;
      H2 = CONST * H2;
      S0 = CONST * S0;
      S1 = CONST * S1;
      S2 = CONST * S2;
      R0 = CONST * R0;
      R1 = CONST * R1;
      R2 = CONST * R2;

    }

    //  *********************************************************************
    //                       SUBROUTINE SORT2
    //  *********************************************************************
    void materialCreator::SORT2 (double *X, double *Y, int &N)
    {
      //  This subroutine sorts a table (X,Y) of a function with n data points.
      //  A discontinuity of the function is described by giving twice the abs-
      //  cissa. It is assumed that the function is strictly positive (negative
      //  values of Y are set to zero).

      const int NP_S = 12000;
      std::vector<int> IORDER(NP_S);

      if (N > NP_S)
	{
	  printf ("NP =%7d\n", N);
	  ErrorFunction (1903);
	  return;
	}

      if (N == 1)
	{
	  return;
	}
      for (int I = 0; I < N; I++)
	{
	  IORDER[I] = I + 1;
	  if (Y[I] < 1.0E-75)
	    {
	      Y[I] = 1.0E-75;
	    }
	}

      int IMIN;
      double XMIN;
      for (int I = 0; I < N - 1; I++)
	{
	  IMIN = I + 1;
	  XMIN = X[I];
	  for (int J = I + 1; J < N; J++)
	    {
	      if (X[J] < XMIN)
		{
		  IMIN = J + 1;
		  XMIN = X[J];
		}
	    }
	  double SAVE = X[I];
	  X[I] = X[IMIN - 1];
	  X[IMIN - 1] = SAVE;
	  SAVE = Y[I];
	  Y[I] = Y[IMIN - 1];
	  Y[IMIN - 1] = SAVE;
	  int ISAVE = IORDER[I];
	  IORDER[I] = IORDER[IMIN - 1];
	  IORDER[IMIN - 1] = ISAVE;
	  if (I + 1 == 1)
	    {
	      continue;
	    }
	  if (IORDER[I] < IORDER[I - 1] && fabs (X[I] - X[I - 1]) < 1.0E-15)
	    {
	      SAVE = X[I - 1];
	      X[I - 1] = X[I];
	      X[I] = SAVE;
	      SAVE = Y[I - 1];
	      Y[I - 1] = Y[I];
	      Y[I] = SAVE;
	      ISAVE = IORDER[I - 1];
	      IORDER[I - 1] = IORDER[I];
	      IORDER[I] = ISAVE;
	    }
	}
      int I = N;
      if (IORDER[I - 1] < IORDER[I - 1 - 1]
	  && fabs (X[I - 1] - X[I - 1 - 1]) < 1.0E-15)
	{
	  double SAVE = X[I - 1 - 1];
	  X[I - 1 - 1] = X[I - 1];
	  X[I - 1] = SAVE;
	  SAVE = Y[I - 1 - 1];
	  Y[I - 1 - 1] = Y[I - 1];
	  Y[I - 1] = SAVE;
	}
    }

    //  *********************************************************************
    //                       FUNCTION SUMGA
    //  *********************************************************************
    double materialCreator::SUMGA (std::function<double(materialCreator*, double)> FCT,
				   double XL, double XU, double TOL)
    {
      //  This function calculates the value SUMGA of the integral of the
      //  (external) function FCT over the interval (XL,XU) using the 20-point
      //  Gauss quadrature method with an adaptive-bisection scheme.

      //  TOL is the tolerance, i.e. maximum allowed relative error; it should
      //  not be less than 1.0D-13. A warning message is written in unit 6 when
      //  the required accuracy is not attained. The common block CSUMGA can be
      //  used to transfer the error flag IERGA and the number of calculated
      //  function values to the calling program.

      //                                        Francesc Salvat. 2 April, 2012.

      const int NP_S = 10;
      const int NP2_S = 2 * NP_S;
      const int NP4 = 4 * NP_S;
      const int NOIT = 130;
      const int NOIT5 = NOIT / 5;
      const int NCALLT = 100000;

      double XM[NP_S], XP[NP_S];
      double S[NOIT], SN[NOIT], XR[NOIT], XRN[NOIT];
      //  Output error codes:
      //     IERGA = 0, no problem, the calculation has converged.
      //           = 1, too many open subintervals.
      //           = 2, too many function calls.
      //           = 3, subintervals are too narrow.

      //  ****  Gauss 20-point integration formula.
      //  Abscissas.
      double X[NP_S] =
	{ 7.6526521133497334E-02, 2.2778585114164508E-01, 3.7370608871541956E-01,
	  5.1086700195082710E-01, 6.3605368072651503E-01, 7.4633190646015079E-01,
	  8.3911697182221882E-01, 9.1223442825132591E-01, 9.6397192727791379E-01,
	  9.9312859918509492E-01 };
      //  Weights.
      double W[NP_S] =
	{ 1.5275338713072585E-01, 1.4917298647260375E-01, 1.4209610931838205E-01,
	  1.3168863844917663E-01, 1.1819453196151842E-01, 1.0193011981724044E-01,
	  8.3276741576704749E-02, 6.2672048334109064E-02, 4.0601429800386941E-02,
	  1.7614007139152118E-02 };

      for (int I = 0; I < NP_S; I++)
	{
	  XM[I] = 1.0 - X[I];
	  XP[I] = 1.0 + X[I];
	}
      //  ****  Global and partial tolerances.

      double TOL1;			// Global tolerance.

      if (TOL < 1.0E-13)
	{
	  TOL1 = 1.0E-13;
	}
      else
	{
	  TOL1 = TOL;
	}

      if (TOL1 > 1.0E-5)
	{
	  TOL1 = 1.0E-5;
	}

      double TOL2 = TOL1;		// Effective tolerance.
      double TOL3 = 1.0E-13;	// Round-off protection.
      double SUMGA_RETURN = 0.0;	//Valor que torna la funcio
      IERGA = 0;
      //  ****  Straight integration from XL to XU.
      double H = XU - XL;
      double HH = 0.5 * H;
      double X1 = XL;
      double SP = W[0] * (FCT (this, X1 + XM[0] * HH) + FCT (this, X1 + XP[0] * HH));
      for (int J = 1; J < NP_S; J++)
	{
	  SP = SP + W[J] * (FCT (this, X1 + XM[J] * HH) + FCT (this, X1 + XP[J] * HH));
	}
      S[0] = SP * HH;
      XR[0] = X1;
      NCALL = NP2_S;
      int NOI = 1;
      int IDONE = 1;		// To prevent a compilation warning.

      //  ****  Adaptive-bisection scheme.

      bool Eixir = false;
      int NOIP;
      double SUMR;
      while (!Eixir)
	{
	  Eixir = true;
	  H = HH;			// Subinterval length.
	  HH = 0.5 * H;
	  double AHH = fabs (HH);
	  if (TOL2 > 0.01 * TOL1)
	    {
	      TOL2 = TOL2 * 0.5;
	    }
	  SUMR = 0.0;
	  NOIP = NOI;
	  NOI = 0;
	  bool Eixir2 = false;
	  for (int I = 0; I < NOIP; I++)
	    {
	      double SI = S[I];	// Bisect the I-th open interval.

	      X1 = XR[I];
	      if (AHH < fabs (X1) * TOL3)
		{
		  IERGA = 3;
		}			// The interval is too narrow.
	      SP = W[0] * (FCT (this, X1 + XM[0] * HH) + FCT (this, X1 + XP[0] * HH));
	      for (int J = 1; J < NP_S; J++)
		{
		  SP =
		    SP + W[J] * (FCT (this, X1 + XM[J] * HH) + FCT (this, X1 + XP[J] * HH));
		}
	      double S1 = SP * HH;

	      double X2 = X1 + H;
	      if (AHH < fabs (X2) * TOL3)
		{
		  IERGA = 3;
		}			// The interval is too narrow.
	      SP = W[0] * (FCT (this, X2 + XM[0] * HH) + FCT (this, X2 + XP[0] * HH));
	      for (int J = 1; J < NP_S; J++)
		{
		  SP =
		    SP + W[J] * (FCT (this, X2 + XM[J] * HH) + FCT (this, X2 + XP[J] * HH));
		}
	      double S2 = SP * HH;

	      IDONE = I + 1;
	      NCALL = NCALL + NP4;
	      double S12 = S1 + S2;	// Sum of integrals on the two subintervals.
	      if (fabs (S12 - SI) <
		  ((TOL2 * fabs (S12) > 1.0E-35) ? TOL2 * fabs (S12) : 1.0E-35))
		{
		  //  ****  The integral over the parent interval has converged.
		  SUMGA_RETURN = SUMGA_RETURN + S12;
		}
	      else
		{
		  SUMR = SUMR + S12;
		  NOI = NOI + 2;
		  if (NOI < NOIT)
		    {
		      //  ****  Store open intervals.
		      SN[NOI - 2] = S1;
		      XRN[NOI - 2] = X1;
		      SN[NOI - 1] = S2;
		      XRN[NOI - 1] = X2;
		    }
		  else
		    {
		      //  ****  Too many open intervals.
		      IERGA = 1;
		      Eixir2 = true;
		      break;
		    }
		}
	      if (NCALL > NCALLT)
		{
		  //  ****  Too many calls to FCT.
		  IERGA = 2;
		  Eixir2 = true;
		  break;
		}
	    }
	  if (Eixir2)
	    {
	      break;
	    }

	  //  ****  Analysis of partial results and error control.

	  if (IERGA == 3)		// Intervals are too narrow.
	    {
	      if (NOI < NOIT5)
		{
		  IERGA = 0;	// The result is probably correct.
		  SUMGA_RETURN = SUMGA_RETURN + SUMR;
		  return SUMGA_RETURN;
		}
	      break;
	    }

	  if (IERGA == 0)
	    {
	      double Aux_Double = TOL1 * fabs (SUMGA_RETURN + SUMR);
	      if (Aux_Double < 1.0E-35)
		{
		  Aux_Double = 1.0E-35;
		}
	      if (fabs (SUMR) < Aux_Double || NOI == 0)
		{
		  return SUMGA_RETURN;
		}
	      else
		{
		  for (int I = 0; I < NOI; I++)
		    {
		      S[I] = SN[I];
		      XR[I] = XRN[I];
		    }
		  Eixir = false;
		  continue;
		}
	    }
	}

      //  ****  Warning (low accuracy) message.

      if (IDONE < NOIP)
	{
	  for (int I = IDONE; I < NOIP; I++)
	    {
	      SUMR = SUMR + S[I];
	    }
	  NOI = NOI + (NOIP - IDONE);
	}
      SUMGA_RETURN = SUMGA_RETURN + SUMR;
      if (ISGAW == 0)
	{
	  return SUMGA_RETURN;
	}
      printf ("  >>> SUMGA. Gauss adaptive-bisection quadrature.\n");
      printf ("  XL =%15.8E, XU =%15.8E, TOL =%8.1E\n", XL, XU, TOL);
      if (fabs (SUMGA_RETURN) > 1.0E-35)
	{
	  double RERR = fabs (SUMR) / fabs (SUMGA_RETURN);
	  printf ("  SUMGA =%22.15E, relative error =%8.1E\n", SUMGA_RETURN,
		  RERR);
	}
      else
	{
	  double AERR = fabs (SUMR);
	  printf ("  SUMGA =%22.15E, absolute error =%8.1E\n", SUMGA_RETURN,
		  AERR);
	}
      printf ("  NCALL =%6d, open subintervals =%4d, H =%10.3E\n", NCALL, NOI,
	      HH);
      if (IERGA == 1)
	{
	  printf ("  IERGA = 1, too many open subintervals.\n");
	}
      else if (IERGA == 2)
	{
	  printf ("  IERGA = 2, too many function calls.\n");
	}
      else if (IERGA == 3)
	{
	  printf ("  IERGA = 3, subintervals are too narrow.\n");
	}
      printf ("  WARNING: the required accuracy has not been attained.\n");

      return SUMGA_RETURN;		//MIRAR

    }

    //  *********************************************************************
    //                       FUNCTION PINaDS
    //  *********************************************************************
    double materialCreator::PINaDS (double RMU)
    {

      //using namespace CPIN01;
    
      //  Angular differential cross section for soft close inelastic colli-
      //  sions of positrons.

      double AUX = 2.0 * RMU * (1.0 - RMU);
      double DENOM = CPIN01.EI * AUX + REV;
      double W = CPIN01.CPS * AUX / DENOM;
      double DWDMU = CPIN01.CPS * REV * (2.0 - 4.0 * RMU) / pow (DENOM, 2);
      double WE = W / CPIN01.EI;
      double PINaDS_RETURN = (1.0 - WE *
			      (CPIN01.BHA1 - WE * (CPIN01.BHA2 - WE * (CPIN01.BHA3 - WE * CPIN01.BHA4)))) *
	DWDMU * pow (RMU,CPIN01.MOM) / pow (W, 2);
      return PINaDS_RETURN;
    }

    //  *********************************************************************
    //                       FUNCTION EINaDS
    //  *********************************************************************
    double materialCreator::EINaDS (double RMU)
    {
      //  Angular differential cross section for soft close inelastic colli-
      //  sions of electrons.
      //

      //using namespace CEIN01;

      double EINaDS_RETURN;
      double AUX = 2.0 * RMU * (1.0 - RMU);
      double DENOM = CEIN01.EI * AUX + REV;
      double W = CEIN01.CPS * AUX / DENOM;
      double DWDMU = CEIN01.CPS * REV * (2.0 - 4.0 * RMU) / pow (DENOM, 2);
      EINaDS_RETURN =
	(1.0 + pow (W / (CEIN01.EE - W), 2) - (1.0 - CEIN01.AMOL) * (W / (CEIN01.EE - W)) +
	 CEIN01.AMOL * pow (W / CEIN01.EE, 2)) * DWDMU * pow (RMU, CEIN01.MOM) / pow (W, 2);
      return EINaDS_RETURN;
    }

    //  *********************************************************************
    //                        FUNCTION GCOaD
    //  *********************************************************************
    double materialCreator::GCOaD (double CDT)
    {
      //  Single differential cross section for photon Compton scattering by
      //  electrons in the IO-th shell, differential in the direction of the
      //  scattered photon only. Evaluated from the incoherent scattering
      //  function.

      //  The energy E of the primary photon is entered through common CGCO00.
      //  The output value GCOaD is the DCS per electron in units of PIELR2.

      const double RREV = 1.0 / REV;
      const double D2 = 1.4142135623731;
      const double D1 = 1.0 / D2;
      const double D12 = 0.5;

      //Get CGCO00 variables
      double& EE = CGCO00.EE;
      int& IOSC = CGCO00.IOSC;
      
      double GCOaD_RETURN;
      if (EE < UICO[IOSC - 1])
	{
	  GCOaD_RETURN = 0.0;
	  return GCOaD_RETURN;
	}
      //  ****  Energy of the Compton line.
      double CDT1 = 1.0 - CDT;
      double EOEC = 1.0 + (EE * RREV) * CDT1;
      double ECOE = 1.0 / EOEC;
      //  ****  Klein-Nishina X-factor.
      double XKN = EOEC + ECOE - 1.0 + CDT * CDT;
      //  ****  Incoherent scattering function (analytical profile).
      double AUX = EE * (EE - UICO[IOSC - 1]) * CDT1;
      double PIMAX =
	(AUX -
	 REV * UICO[IOSC - 1]) / (REV * sqrt (AUX + AUX +
						  pow (UICO[IOSC - 1], 2)));
      double SIA;
      if (PIMAX > 0.0)
	{
	  SIA =
	    1.0 - 0.5 * exp (D12 - pow (D1 + D2 * FJ0[IOSC - 1] * PIMAX, 2));
	}
      else
	{
	  SIA = 0.5 * exp (D12 - pow (D1 - D2 * FJ0[IOSC - 1] * PIMAX, 2));
	}
      //  ****  1st order correction, integral of Pz times the Compton profile.
      //        Calculated approximately using a free-electron gas profile.
      double PF = 3.0 / (4.0 * FJ0[IOSC - 1]);
      double QCOE2, P2, DSPZ;
      if (fabs (PIMAX) < PF)
	{
	  QCOE2 = 1.0 + pow (ECOE, 2) - 2.0 * ECOE * CDT;
	  P2 = pow (PIMAX, 2);
	  DSPZ =
	    sqrt (QCOE2) * (1.0 + ECOE * (ECOE - CDT) / QCOE2) * FJ0[IOSC -
									 1] *
	    0.25 * (2 * P2 - pow (P2, 2) / pow (PF, 2) - pow (PF, 2));
	  if (DSPZ > -SIA)
	    {
	      SIA = SIA + DSPZ;
	    }
	  else
	    {
	      SIA = 0.0;
	    }
	}
      //  ****  Differential cross section (per electron, in units of PIELR2).
      GCOaD_RETURN = pow (ECOE, 2) * XKN * SIA;
      return GCOaD_RETURN;
    }

    //Create material auxiliary functions
    int createMat(const std::string& name,
		  const double density,
		  const std::vector<massFraction>& composition,
		  std::string& errorString,
		  const std::string& filenameIn){

      //This function creates a material file with the provided data:
      //
      // name        : Descriptive material name. Is used to define the material
      //               filename if "filenameIn" is not provided 
      // density     : Material density in g/cm**3
      // composition : Composition vector. Each position defines a element
      //               atomic number and mass fraction
      // errorString : If the material creation fails, the error message is stored in
      // filenameIn  : If provided it is used as the material filename
      //
      // return 0 on success, other values on material creation error.
      
      //Clear error string
      errorString.clear();

      std::string filename = filenameIn;
      if(filename.empty())
	filename = name + ".mat";
      
      //Create a material creator instance
      materialCreator* creator = new materialCreator();

      //Create a stream to read the material information
      std::stringstream matStream;

      matStream << 1 << std::endl;
      matStream << name << std::endl;
      matStream << composition.size() << std::endl;
      
      if(composition.size() > 1){
	matStream << 2 << std::endl;
	for(const auto& element : composition){
	  matStream << element.Z << " "
		    << element.fraction << std::endl;
	}
      }
      else{
	matStream << composition[0].Z << std::endl;
      }
      
      matStream << 2 << std::endl;
      matStream << density << std::endl;
      matStream << 2 << std::endl;
      matStream << filename << std::endl;

      creator->PEMATW(matStream, true, filename);
      if(creator->IRETRN != 0){
	errorString = creator->REASON;
	int err = creator->IRETRN;
	delete creator;
	return err;
      }
      delete creator;
      return 0;
    }


    int createMat(const unsigned matID,
		  const std::string& filename,
		  std::string& errorString){

      //This function creates a predefined material file with the provided data:
      //
      // name        : Descriptive material name. Is used to define the material
      //               filename if "filenameIn" is not provided 
      // matID       : Material number in the predefined material list
      //               atomic number and mass fraction
      // errorString : If the material creation fails, the error message is stored in
      // filenameIn  : If provided it is used as the material filename
      //
      // return 0 on success, other values on material creation error.
      
      //Clear error string
      errorString.clear();
      
      //Create a material creator instance
      materialCreator* creator = new materialCreator();

      //Create a stream to read the material information
      std::stringstream matStream;

      matStream << 2 << std::endl;
      matStream << matID << std::endl;
      matStream << 2 << std::endl;
      matStream << filename << std::endl;

      creator->PEMATW(matStream, true, filename);
      if(creator->IRETRN != 0){
	errorString = creator->REASON;
	int err = creator->IRETRN;
	delete creator;
	return err;
      }
      delete creator;
      return 0;
    }
    

  } // namespace penMaterialCreator
} // namespace penred

